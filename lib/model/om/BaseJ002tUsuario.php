<?php

/**
 * Base class that represents a row from the 'j002t_usuario' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.3.0-dev on:
 *
 * Wed Nov 11 13:50:03 2015
 *
 * @package    lib.model.om
 */
abstract class BaseJ002tUsuario extends BaseObject  implements Persistent {


  const PEER = 'J002tUsuarioPeer';

	/**
	 * The Peer class.
	 * Instance provides a convenient way of calling static methods on a class
	 * that calling code may not be able to identify.
	 * @var        J002tUsuarioPeer
	 */
	protected static $peer;

	/**
	 * The value for the co_usuario field.
	 * @var        string
	 */
	protected $co_usuario;

	/**
	 * The value for the tx_indicador field.
	 * @var        string
	 */
	protected $tx_indicador;

	/**
	 * The value for the nb_empleado field.
	 * @var        string
	 */
	protected $nb_empleado;

	/**
	 * The value for the ap_empleado field.
	 * @var        string
	 */
	protected $ap_empleado;

	/**
	 * The value for the co_division field.
	 * @var        string
	 */
	protected $co_division;

	/**
	 * The value for the co_rol field.
	 * @var        string
	 */
	protected $co_rol;

	/**
	 * The value for the co_region field.
	 * @var        string
	 */
	protected $co_region;

	/**
	 * The value for the co_negocio field.
	 * @var        string
	 */
	protected $co_negocio;

	/**
	 * @var        J008tDivision
	 */
	protected $aJ008tDivision;

	/**
	 * @var        J003tRol
	 */
	protected $aJ003tRol;

	/**
	 * @var        J007tRegion
	 */
	protected $aJ007tRegion;

	/**
	 * @var        J014tNegocio
	 */
	protected $aJ014tNegocio;

	/**
	 * @var        array C024tRecurso[] Collection to store aggregation of C024tRecurso objects.
	 */
	protected $collC024tRecursosRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collC024tRecursosRelatedByCoUsuarioCreated.
	 */
	private $lastC024tRecursoRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array C024tRecurso[] Collection to store aggregation of C024tRecurso objects.
	 */
	protected $collC024tRecursosRelatedByCoUsuarioUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collC024tRecursosRelatedByCoUsuarioUpdated.
	 */
	private $lastC024tRecursoRelatedByCoUsuarioUpdatedCriteria = null;

	/**
	 * @var        array J005tTransaccion[] Collection to store aggregation of J005tTransaccion objects.
	 */
	protected $collJ005tTransaccions;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ005tTransaccions.
	 */
	private $lastJ005tTransaccionCriteria = null;

	/**
	 * @var        array J010tEvaluacion[] Collection to store aggregation of J010tEvaluacion objects.
	 */
	protected $collJ010tEvaluacions;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ010tEvaluacions.
	 */
	private $lastJ010tEvaluacionCriteria = null;

	/**
	 * @var        array J012tCronograma[] Collection to store aggregation of J012tCronograma objects.
	 */
	protected $collJ012tCronogramas;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ012tCronogramas.
	 */
	private $lastJ012tCronogramaCriteria = null;

	/**
	 * @var        array J016tForense[] Collection to store aggregation of J016tForense objects.
	 */
	protected $collJ016tForensesRelatedByCoUsuarioApertura;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ016tForensesRelatedByCoUsuarioApertura.
	 */
	private $lastJ016tForenseRelatedByCoUsuarioAperturaCriteria = null;

	/**
	 * @var        array J016tForense[] Collection to store aggregation of J016tForense objects.
	 */
	protected $collJ016tForensesRelatedByCoUsuarioCierre;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ016tForensesRelatedByCoUsuarioCierre.
	 */
	private $lastJ016tForenseRelatedByCoUsuarioCierreCriteria = null;

	/**
	 * @var        array J016tForense[] Collection to store aggregation of J016tForense objects.
	 */
	protected $collJ016tForensesRelatedByCoUsuarioUpdate;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ016tForensesRelatedByCoUsuarioUpdate.
	 */
	private $lastJ016tForenseRelatedByCoUsuarioUpdateCriteria = null;

	/**
	 * @var        array J017tAlcanceForense[] Collection to store aggregation of J017tAlcanceForense objects.
	 */
	protected $collJ017tAlcanceForensesRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ017tAlcanceForensesRelatedByCoUsuarioCreated.
	 */
	private $lastJ017tAlcanceForenseRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J017tAlcanceForense[] Collection to store aggregation of J017tAlcanceForense objects.
	 */
	protected $collJ017tAlcanceForensesRelatedByCoUsuarioUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ017tAlcanceForensesRelatedByCoUsuarioUpdated.
	 */
	private $lastJ017tAlcanceForenseRelatedByCoUsuarioUpdatedCriteria = null;

	/**
	 * @var        array J018tInformeForense[] Collection to store aggregation of J018tInformeForense objects.
	 */
	protected $collJ018tInformeForensesRelatedByCoRevisa;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ018tInformeForensesRelatedByCoRevisa.
	 */
	private $lastJ018tInformeForenseRelatedByCoRevisaCriteria = null;

	/**
	 * @var        array J018tInformeForense[] Collection to store aggregation of J018tInformeForense objects.
	 */
	protected $collJ018tInformeForensesRelatedByCoAprueba;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ018tInformeForensesRelatedByCoAprueba.
	 */
	private $lastJ018tInformeForenseRelatedByCoApruebaCriteria = null;

	/**
	 * @var        array J018tInformeForense[] Collection to store aggregation of J018tInformeForense objects.
	 */
	protected $collJ018tInformeForensesRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ018tInformeForensesRelatedByCoUsuarioCreated.
	 */
	private $lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J018tInformeForense[] Collection to store aggregation of J018tInformeForense objects.
	 */
	protected $collJ018tInformeForensesRelatedByCoUsuarioUpdate;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ018tInformeForensesRelatedByCoUsuarioUpdate.
	 */
	private $lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria = null;

	/**
	 * @var        array J019tParticipantes[] Collection to store aggregation of J019tParticipantes objects.
	 */
	protected $collJ019tParticipantess;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ019tParticipantess.
	 */
	private $lastJ019tParticipantesCriteria = null;

	/**
	 * @var        array J020tActaAcc[] Collection to store aggregation of J020tActaAcc objects.
	 */
	protected $collJ020tActaAccsRelatedByCoElabora;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ020tActaAccsRelatedByCoElabora.
	 */
	private $lastJ020tActaAccRelatedByCoElaboraCriteria = null;

	/**
	 * @var        array J020tActaAcc[] Collection to store aggregation of J020tActaAcc objects.
	 */
	protected $collJ020tActaAccsRelatedByCoDestruye;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ020tActaAccsRelatedByCoDestruye.
	 */
	private $lastJ020tActaAccRelatedByCoDestruyeCriteria = null;

	/**
	 * @var        array J020tActaAcc[] Collection to store aggregation of J020tActaAcc objects.
	 */
	protected $collJ020tActaAccsRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ020tActaAccsRelatedByCoUsuarioCreated.
	 */
	private $lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J020tActaAcc[] Collection to store aggregation of J020tActaAcc objects.
	 */
	protected $collJ020tActaAccsRelatedByCoUsuarioUpdate;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ020tActaAccsRelatedByCoUsuarioUpdate.
	 */
	private $lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria = null;

	/**
	 * @var        array J021tActaAie[] Collection to store aggregation of J021tActaAie objects.
	 */
	protected $collJ021tActaAiesRelatedByCoElabora;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ021tActaAiesRelatedByCoElabora.
	 */
	private $lastJ021tActaAieRelatedByCoElaboraCriteria = null;

	/**
	 * @var        array J021tActaAie[] Collection to store aggregation of J021tActaAie objects.
	 */
	protected $collJ021tActaAiesRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ021tActaAiesRelatedByCoUsuarioCreated.
	 */
	private $lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J021tActaAie[] Collection to store aggregation of J021tActaAie objects.
	 */
	protected $collJ021tActaAiesRelatedByCoUsuarioUpdate;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ021tActaAiesRelatedByCoUsuarioUpdate.
	 */
	private $lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria = null;

	/**
	 * @var        array J022tActaAnie[] Collection to store aggregation of J022tActaAnie objects.
	 */
	protected $collJ022tActaAniesRelatedByCoElabora;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ022tActaAniesRelatedByCoElabora.
	 */
	private $lastJ022tActaAnieRelatedByCoElaboraCriteria = null;

	/**
	 * @var        array J022tActaAnie[] Collection to store aggregation of J022tActaAnie objects.
	 */
	protected $collJ022tActaAniesRelatedByCoCustodioNiega;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ022tActaAniesRelatedByCoCustodioNiega.
	 */
	private $lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria = null;

	/**
	 * @var        array J022tActaAnie[] Collection to store aggregation of J022tActaAnie objects.
	 */
	protected $collJ022tActaAniesRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ022tActaAniesRelatedByCoUsuarioCreated.
	 */
	private $lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J022tActaAnie[] Collection to store aggregation of J022tActaAnie objects.
	 */
	protected $collJ022tActaAniesRelatedByCoUsuarioUpdate;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ022tActaAniesRelatedByCoUsuarioUpdate.
	 */
	private $lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria = null;

	/**
	 * @var        array J023tEvidencia[] Collection to store aggregation of J023tEvidencia objects.
	 */
	protected $collJ023tEvidenciasRelatedByCoRegistro;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ023tEvidenciasRelatedByCoRegistro.
	 */
	private $lastJ023tEvidenciaRelatedByCoRegistroCriteria = null;

	/**
	 * @var        array J023tEvidencia[] Collection to store aggregation of J023tEvidencia objects.
	 */
	protected $collJ023tEvidenciasRelatedByCoColecta;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ023tEvidenciasRelatedByCoColecta.
	 */
	private $lastJ023tEvidenciaRelatedByCoColectaCriteria = null;

	/**
	 * @var        array J023tEvidencia[] Collection to store aggregation of J023tEvidencia objects.
	 */
	protected $collJ023tEvidenciasRelatedByCoCustodioSti;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ023tEvidenciasRelatedByCoCustodioSti.
	 */
	private $lastJ023tEvidenciaRelatedByCoCustodioStiCriteria = null;

	/**
	 * @var        array J023tEvidencia[] Collection to store aggregation of J023tEvidencia objects.
	 */
	protected $collJ023tEvidenciasRelatedByCoUpdateAt;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ023tEvidenciasRelatedByCoUpdateAt.
	 */
	private $lastJ023tEvidenciaRelatedByCoUpdateAtCriteria = null;

	/**
	 * @var        array J025tTipoEvidencia[] Collection to store aggregation of J025tTipoEvidencia objects.
	 */
	protected $collJ025tTipoEvidenciasRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ025tTipoEvidenciasRelatedByCoUsuarioCreated.
	 */
	private $lastJ025tTipoEvidenciaRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J025tTipoEvidencia[] Collection to store aggregation of J025tTipoEvidencia objects.
	 */
	protected $collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated.
	 */
	private $lastJ025tTipoEvidenciaRelatedByCoUsuarioUpdatedCriteria = null;

	/**
	 * @var        array J026tEstadoEvidencia[] Collection to store aggregation of J026tEstadoEvidencia objects.
	 */
	protected $collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated.
	 */
	private $lastJ026tEstadoEvidenciaRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J026tEstadoEvidencia[] Collection to store aggregation of J026tEstadoEvidencia objects.
	 */
	protected $collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated.
	 */
	private $lastJ026tEstadoEvidenciaRelatedByCoUsuarioUpdatedCriteria = null;

	/**
	 * @var        array J027tLugarSeguro[] Collection to store aggregation of J027tLugarSeguro objects.
	 */
	protected $collJ027tLugarSegurosRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ027tLugarSegurosRelatedByCoUsuarioCreated.
	 */
	private $lastJ027tLugarSeguroRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J027tLugarSeguro[] Collection to store aggregation of J027tLugarSeguro objects.
	 */
	protected $collJ027tLugarSegurosRelatedByCoUsuarioUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ027tLugarSegurosRelatedByCoUsuarioUpdated.
	 */
	private $lastJ027tLugarSeguroRelatedByCoUsuarioUpdatedCriteria = null;

	/**
	 * @var        array J028tRepositorio[] Collection to store aggregation of J028tRepositorio objects.
	 */
	protected $collJ028tRepositoriosRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ028tRepositoriosRelatedByCoUsuarioCreated.
	 */
	private $lastJ028tRepositorioRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J028tRepositorio[] Collection to store aggregation of J028tRepositorio objects.
	 */
	protected $collJ028tRepositoriosRelatedByCoUsuarioUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ028tRepositoriosRelatedByCoUsuarioUpdated.
	 */
	private $lastJ028tRepositorioRelatedByCoUsuarioUpdatedCriteria = null;

	/**
	 * @var        array J030tInformeRecomendaciones[] Collection to store aggregation of J030tInformeRecomendaciones objects.
	 */
	protected $collJ030tInformeRecomendacionessRelatedByCoRevisa;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ030tInformeRecomendacionessRelatedByCoRevisa.
	 */
	private $lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria = null;

	/**
	 * @var        array J030tInformeRecomendaciones[] Collection to store aggregation of J030tInformeRecomendaciones objects.
	 */
	protected $collJ030tInformeRecomendacionessRelatedByCoAprueba;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ030tInformeRecomendacionessRelatedByCoAprueba.
	 */
	private $lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria = null;

	/**
	 * @var        array J030tInformeRecomendaciones[] Collection to store aggregation of J030tInformeRecomendaciones objects.
	 */
	protected $collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated.
	 */
	private $lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J030tInformeRecomendaciones[] Collection to store aggregation of J030tInformeRecomendaciones objects.
	 */
	protected $collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate.
	 */
	private $lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria = null;

	/**
	 * @var        array J031tAccionRecomendada[] Collection to store aggregation of J031tAccionRecomendada objects.
	 */
	protected $collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar.
	 */
	private $lastJ031tAccionRecomendadaRelatedByCoResponsableStiEjecutarCriteria = null;

	/**
	 * @var        array J031tAccionRecomendada[] Collection to store aggregation of J031tAccionRecomendada objects.
	 */
	protected $collJ031tAccionRecomendadasRelatedByCoCreatedAt;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ031tAccionRecomendadasRelatedByCoCreatedAt.
	 */
	private $lastJ031tAccionRecomendadaRelatedByCoCreatedAtCriteria = null;

	/**
	 * @var        array J031tAccionRecomendada[] Collection to store aggregation of J031tAccionRecomendada objects.
	 */
	protected $collJ031tAccionRecomendadasRelatedByCoUpdateAt;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ031tAccionRecomendadasRelatedByCoUpdateAt.
	 */
	private $lastJ031tAccionRecomendadaRelatedByCoUpdateAtCriteria = null;

	/**
	 * @var        array J034tIncidente[] Collection to store aggregation of J034tIncidente objects.
	 */
	protected $collJ034tIncidentesRelatedByCoUsuarioApertura;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ034tIncidentesRelatedByCoUsuarioApertura.
	 */
	private $lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria = null;

	/**
	 * @var        array J034tIncidente[] Collection to store aggregation of J034tIncidente objects.
	 */
	protected $collJ034tIncidentesRelatedByCoUsuarioEscala;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ034tIncidentesRelatedByCoUsuarioEscala.
	 */
	private $lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria = null;

	/**
	 * @var        array J034tIncidente[] Collection to store aggregation of J034tIncidente objects.
	 */
	protected $collJ034tIncidentesRelatedByCoUsuarioCierre;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ034tIncidentesRelatedByCoUsuarioCierre.
	 */
	private $lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria = null;

	/**
	 * @var        array J034tIncidente[] Collection to store aggregation of J034tIncidente objects.
	 */
	protected $collJ034tIncidentesRelatedByCoUsuarioUpdate;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ034tIncidentesRelatedByCoUsuarioUpdate.
	 */
	private $lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria = null;

	/**
	 * @var        array J042tEstadoIncidente[] Collection to store aggregation of J042tEstadoIncidente objects.
	 */
	protected $collJ042tEstadoIncidentesRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ042tEstadoIncidentesRelatedByCoUsuarioCreated.
	 */
	private $lastJ042tEstadoIncidenteRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J042tEstadoIncidente[] Collection to store aggregation of J042tEstadoIncidente objects.
	 */
	protected $collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated.
	 */
	private $lastJ042tEstadoIncidenteRelatedByCoUsuarioUpdatedCriteria = null;

	/**
	 * @var        array J047tDocumentoNormativo[] Collection to store aggregation of J047tDocumentoNormativo objects.
	 */
	protected $collJ047tDocumentoNormativosRelatedByCoAprueba1;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ047tDocumentoNormativosRelatedByCoAprueba1.
	 */
	private $lastJ047tDocumentoNormativoRelatedByCoAprueba1Criteria = null;

	/**
	 * @var        array J047tDocumentoNormativo[] Collection to store aggregation of J047tDocumentoNormativo objects.
	 */
	protected $collJ047tDocumentoNormativosRelatedByCoAprueba2;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ047tDocumentoNormativosRelatedByCoAprueba2.
	 */
	private $lastJ047tDocumentoNormativoRelatedByCoAprueba2Criteria = null;

	/**
	 * @var        array J047tDocumentoNormativo[] Collection to store aggregation of J047tDocumentoNormativo objects.
	 */
	protected $collJ047tDocumentoNormativosRelatedByCoElimina1;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ047tDocumentoNormativosRelatedByCoElimina1.
	 */
	private $lastJ047tDocumentoNormativoRelatedByCoElimina1Criteria = null;

	/**
	 * @var        array J047tDocumentoNormativo[] Collection to store aggregation of J047tDocumentoNormativo objects.
	 */
	protected $collJ047tDocumentoNormativosRelatedByCoElimina2;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ047tDocumentoNormativosRelatedByCoElimina2.
	 */
	private $lastJ047tDocumentoNormativoRelatedByCoElimina2Criteria = null;

	/**
	 * @var        array J047tDocumentoNormativo[] Collection to store aggregation of J047tDocumentoNormativo objects.
	 */
	protected $collJ047tDocumentoNormativosRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ047tDocumentoNormativosRelatedByCoUsuarioCreated.
	 */
	private $lastJ047tDocumentoNormativoRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J047tDocumentoNormativo[] Collection to store aggregation of J047tDocumentoNormativo objects.
	 */
	protected $collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated.
	 */
	private $lastJ047tDocumentoNormativoRelatedByCoUsuarioUpdatedCriteria = null;

	/**
	 * @var        array J048tEstadoDocumento[] Collection to store aggregation of J048tEstadoDocumento objects.
	 */
	protected $collJ048tEstadoDocumentosRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ048tEstadoDocumentosRelatedByCoUsuarioCreated.
	 */
	private $lastJ048tEstadoDocumentoRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J048tEstadoDocumento[] Collection to store aggregation of J048tEstadoDocumento objects.
	 */
	protected $collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated.
	 */
	private $lastJ048tEstadoDocumentoRelatedByCoUsuarioUpdatedCriteria = null;

	/**
	 * @var        array J049tTipoMarco[] Collection to store aggregation of J049tTipoMarco objects.
	 */
	protected $collJ049tTipoMarcosRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ049tTipoMarcosRelatedByCoUsuarioCreated.
	 */
	private $lastJ049tTipoMarcoRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J049tTipoMarco[] Collection to store aggregation of J049tTipoMarco objects.
	 */
	protected $collJ049tTipoMarcosRelatedByCoUsuarioUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ049tTipoMarcosRelatedByCoUsuarioUpdated.
	 */
	private $lastJ049tTipoMarcoRelatedByCoUsuarioUpdatedCriteria = null;

	/**
	 * @var        array J050tInformeMarco[] Collection to store aggregation of J050tInformeMarco objects.
	 */
	protected $collJ050tInformeMarcosRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ050tInformeMarcosRelatedByCoUsuarioCreated.
	 */
	private $lastJ050tInformeMarcoRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J050tInformeMarco[] Collection to store aggregation of J050tInformeMarco objects.
	 */
	protected $collJ050tInformeMarcosRelatedByCoUsuarioUpdate;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ050tInformeMarcosRelatedByCoUsuarioUpdate.
	 */
	private $lastJ050tInformeMarcoRelatedByCoUsuarioUpdateCriteria = null;

	/**
	 * @var        array J051tTipoRevision[] Collection to store aggregation of J051tTipoRevision objects.
	 */
	protected $collJ051tTipoRevisionsRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ051tTipoRevisionsRelatedByCoUsuarioCreated.
	 */
	private $lastJ051tTipoRevisionRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J051tTipoRevision[] Collection to store aggregation of J051tTipoRevision objects.
	 */
	protected $collJ051tTipoRevisionsRelatedByCoUsuarioUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ051tTipoRevisionsRelatedByCoUsuarioUpdated.
	 */
	private $lastJ051tTipoRevisionRelatedByCoUsuarioUpdatedCriteria = null;

	/**
	 * @var        array J052tTipoJustificacion[] Collection to store aggregation of J052tTipoJustificacion objects.
	 */
	protected $collJ052tTipoJustificacionsRelatedByCoUsuarioCreated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ052tTipoJustificacionsRelatedByCoUsuarioCreated.
	 */
	private $lastJ052tTipoJustificacionRelatedByCoUsuarioCreatedCriteria = null;

	/**
	 * @var        array J052tTipoJustificacion[] Collection to store aggregation of J052tTipoJustificacion objects.
	 */
	protected $collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated;

	/**
	 * @var        Criteria The criteria used to select the current contents of collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated.
	 */
	private $lastJ052tTipoJustificacionRelatedByCoUsuarioUpdatedCriteria = null;

	/**
	 * Flag to prevent endless save loop, if this object is referenced
	 * by another object which falls in this transaction.
	 * @var        boolean
	 */
	protected $alreadyInSave = false;

	/**
	 * Flag to prevent endless validation loop, if this object is referenced
	 * by another object which falls in this transaction.
	 * @var        boolean
	 */
	protected $alreadyInValidation = false;

	/**
	 * Initializes internal state of BaseJ002tUsuario object.
	 * @see        applyDefaults()
	 */
	public function __construct()
	{
		parent::__construct();
		$this->applyDefaultValues();
	}

	/**
	 * Applies default values to this object.
	 * This method should be called from the object's constructor (or
	 * equivalent initialization method).
	 * @see        __construct()
	 */
	public function applyDefaultValues()
	{
	}

	/**
	 * Get the [co_usuario] column value.
	 * 
	 * @return     string
	 */
	public function getCoUsuario()
	{
		return $this->co_usuario;
	}

	/**
	 * Get the [tx_indicador] column value.
	 * 
	 * @return     string
	 */
	public function getTxIndicador()
	{
		return $this->tx_indicador;
	}

	/**
	 * Get the [nb_empleado] column value.
	 * 
	 * @return     string
	 */
	public function getNbEmpleado()
	{
		return $this->nb_empleado;
	}

	/**
	 * Get the [ap_empleado] column value.
	 * 
	 * @return     string
	 */
	public function getApEmpleado()
	{
		return $this->ap_empleado;
	}

	/**
	 * Get the [co_division] column value.
	 * 
	 * @return     string
	 */
	public function getCoDivision()
	{
		return $this->co_division;
	}

	/**
	 * Get the [co_rol] column value.
	 * 
	 * @return     string
	 */
	public function getCoRol()
	{
		return $this->co_rol;
	}

	/**
	 * Get the [co_region] column value.
	 * 
	 * @return     string
	 */
	public function getCoRegion()
	{
		return $this->co_region;
	}

	/**
	 * Get the [co_negocio] column value.
	 * 
	 * @return     string
	 */
	public function getCoNegocio()
	{
		return $this->co_negocio;
	}

	/**
	 * Set the value of [co_usuario] column.
	 * 
	 * @param      string $v new value
	 * @return     J002tUsuario The current object (for fluent API support)
	 */
	public function setCoUsuario($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->co_usuario !== $v) {
			$this->co_usuario = $v;
			$this->modifiedColumns[] = J002tUsuarioPeer::CO_USUARIO;
		}

		return $this;
	} // setCoUsuario()

	/**
	 * Set the value of [tx_indicador] column.
	 * 
	 * @param      string $v new value
	 * @return     J002tUsuario The current object (for fluent API support)
	 */
	public function setTxIndicador($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->tx_indicador !== $v) {
			$this->tx_indicador = $v;
			$this->modifiedColumns[] = J002tUsuarioPeer::TX_INDICADOR;
		}

		return $this;
	} // setTxIndicador()

	/**
	 * Set the value of [nb_empleado] column.
	 * 
	 * @param      string $v new value
	 * @return     J002tUsuario The current object (for fluent API support)
	 */
	public function setNbEmpleado($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->nb_empleado !== $v) {
			$this->nb_empleado = $v;
			$this->modifiedColumns[] = J002tUsuarioPeer::NB_EMPLEADO;
		}

		return $this;
	} // setNbEmpleado()

	/**
	 * Set the value of [ap_empleado] column.
	 * 
	 * @param      string $v new value
	 * @return     J002tUsuario The current object (for fluent API support)
	 */
	public function setApEmpleado($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->ap_empleado !== $v) {
			$this->ap_empleado = $v;
			$this->modifiedColumns[] = J002tUsuarioPeer::AP_EMPLEADO;
		}

		return $this;
	} // setApEmpleado()

	/**
	 * Set the value of [co_division] column.
	 * 
	 * @param      string $v new value
	 * @return     J002tUsuario The current object (for fluent API support)
	 */
	public function setCoDivision($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->co_division !== $v) {
			$this->co_division = $v;
			$this->modifiedColumns[] = J002tUsuarioPeer::CO_DIVISION;
		}

		if ($this->aJ008tDivision !== null && $this->aJ008tDivision->getCoDivision() !== $v) {
			$this->aJ008tDivision = null;
		}

		return $this;
	} // setCoDivision()

	/**
	 * Set the value of [co_rol] column.
	 * 
	 * @param      string $v new value
	 * @return     J002tUsuario The current object (for fluent API support)
	 */
	public function setCoRol($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->co_rol !== $v) {
			$this->co_rol = $v;
			$this->modifiedColumns[] = J002tUsuarioPeer::CO_ROL;
		}

		if ($this->aJ003tRol !== null && $this->aJ003tRol->getCoRol() !== $v) {
			$this->aJ003tRol = null;
		}

		return $this;
	} // setCoRol()

	/**
	 * Set the value of [co_region] column.
	 * 
	 * @param      string $v new value
	 * @return     J002tUsuario The current object (for fluent API support)
	 */
	public function setCoRegion($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->co_region !== $v) {
			$this->co_region = $v;
			$this->modifiedColumns[] = J002tUsuarioPeer::CO_REGION;
		}

		if ($this->aJ007tRegion !== null && $this->aJ007tRegion->getCoRegion() !== $v) {
			$this->aJ007tRegion = null;
		}

		return $this;
	} // setCoRegion()

	/**
	 * Set the value of [co_negocio] column.
	 * 
	 * @param      string $v new value
	 * @return     J002tUsuario The current object (for fluent API support)
	 */
	public function setCoNegocio($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->co_negocio !== $v) {
			$this->co_negocio = $v;
			$this->modifiedColumns[] = J002tUsuarioPeer::CO_NEGOCIO;
		}

		if ($this->aJ014tNegocio !== null && $this->aJ014tNegocio->getCoNegocio() !== $v) {
			$this->aJ014tNegocio = null;
		}

		return $this;
	} // setCoNegocio()

	/**
	 * Indicates whether the columns in this object are only set to default values.
	 *
	 * This method can be used in conjunction with isModified() to indicate whether an object is both
	 * modified _and_ has some values set which are non-default.
	 *
	 * @return     boolean Whether the columns in this object are only been set with default values.
	 */
	public function hasOnlyDefaultValues()
	{
			// First, ensure that we don't have any columns that have been modified which aren't default columns.
			if (array_diff($this->modifiedColumns, array())) {
				return false;
			}

		// otherwise, everything was equal, so return TRUE
		return true;
	} // hasOnlyDefaultValues()

	/**
	 * Hydrates (populates) the object variables with values from the database resultset.
	 *
	 * An offset (0-based "start column") is specified so that objects can be hydrated
	 * with a subset of the columns in the resultset rows.  This is needed, for example,
	 * for results of JOIN queries where the resultset row includes columns from two or
	 * more tables.
	 *
	 * @param      array $row The row returned by PDOStatement->fetch(PDO::FETCH_NUM)
	 * @param      int $startcol 0-based offset column which indicates which restultset column to start with.
	 * @param      boolean $rehydrate Whether this object is being re-hydrated from the database.
	 * @return     int next starting column
	 * @throws     PropelException  - Any caught Exception will be rewrapped as a PropelException.
	 */
	public function hydrate($row, $startcol = 0, $rehydrate = false)
	{
		try {

			$this->co_usuario = ($row[$startcol + 0] !== null) ? (string) $row[$startcol + 0] : null;
			$this->tx_indicador = ($row[$startcol + 1] !== null) ? (string) $row[$startcol + 1] : null;
			$this->nb_empleado = ($row[$startcol + 2] !== null) ? (string) $row[$startcol + 2] : null;
			$this->ap_empleado = ($row[$startcol + 3] !== null) ? (string) $row[$startcol + 3] : null;
			$this->co_division = ($row[$startcol + 4] !== null) ? (string) $row[$startcol + 4] : null;
			$this->co_rol = ($row[$startcol + 5] !== null) ? (string) $row[$startcol + 5] : null;
			$this->co_region = ($row[$startcol + 6] !== null) ? (string) $row[$startcol + 6] : null;
			$this->co_negocio = ($row[$startcol + 7] !== null) ? (string) $row[$startcol + 7] : null;
			$this->resetModified();

			$this->setNew(false);

			if ($rehydrate) {
				$this->ensureConsistency();
			}

			// FIXME - using NUM_COLUMNS may be clearer.
			return $startcol + 8; // 8 = J002tUsuarioPeer::NUM_COLUMNS - J002tUsuarioPeer::NUM_LAZY_LOAD_COLUMNS).

		} catch (Exception $e) {
			throw new PropelException("Error populating J002tUsuario object", $e);
		}
	}

	/**
	 * Checks and repairs the internal consistency of the object.
	 *
	 * This method is executed after an already-instantiated object is re-hydrated
	 * from the database.  It exists to check any foreign keys to make sure that
	 * the objects related to the current object are correct based on foreign key.
	 *
	 * You can override this method in the stub class, but you should always invoke
	 * the base method from the overridden method (i.e. parent::ensureConsistency()),
	 * in case your model changes.
	 *
	 * @throws     PropelException
	 */
	public function ensureConsistency()
	{

		if ($this->aJ008tDivision !== null && $this->co_division !== $this->aJ008tDivision->getCoDivision()) {
			$this->aJ008tDivision = null;
		}
		if ($this->aJ003tRol !== null && $this->co_rol !== $this->aJ003tRol->getCoRol()) {
			$this->aJ003tRol = null;
		}
		if ($this->aJ007tRegion !== null && $this->co_region !== $this->aJ007tRegion->getCoRegion()) {
			$this->aJ007tRegion = null;
		}
		if ($this->aJ014tNegocio !== null && $this->co_negocio !== $this->aJ014tNegocio->getCoNegocio()) {
			$this->aJ014tNegocio = null;
		}
	} // ensureConsistency

	/**
	 * Reloads this object from datastore based on primary key and (optionally) resets all associated objects.
	 *
	 * This will only work if the object has been saved and has a valid primary key set.
	 *
	 * @param      boolean $deep (optional) Whether to also de-associated any related objects.
	 * @param      PropelPDO $con (optional) The PropelPDO connection to use.
	 * @return     void
	 * @throws     PropelException - if this object is deleted, unsaved or doesn't have pk match in db
	 */
	public function reload($deep = false, PropelPDO $con = null)
	{
		if ($this->isDeleted()) {
			throw new PropelException("Cannot reload a deleted object.");
		}

		if ($this->isNew()) {
			throw new PropelException("Cannot reload an unsaved object.");
		}

		if ($con === null) {
			$con = Propel::getConnection(J002tUsuarioPeer::DATABASE_NAME, Propel::CONNECTION_READ);
		}

		// We don't need to alter the object instance pool; we're just modifying this instance
		// already in the pool.

		$stmt = J002tUsuarioPeer::doSelectStmt($this->buildPkeyCriteria(), $con);
		$row = $stmt->fetch(PDO::FETCH_NUM);
		$stmt->closeCursor();
		if (!$row) {
			throw new PropelException('Cannot find matching row in the database to reload object values.');
		}
		$this->hydrate($row, 0, true); // rehydrate

		if ($deep) {  // also de-associate any related objects?

			$this->aJ008tDivision = null;
			$this->aJ003tRol = null;
			$this->aJ007tRegion = null;
			$this->aJ014tNegocio = null;
			$this->collC024tRecursosRelatedByCoUsuarioCreated = null;
			$this->lastC024tRecursoRelatedByCoUsuarioCreatedCriteria = null;

			$this->collC024tRecursosRelatedByCoUsuarioUpdated = null;
			$this->lastC024tRecursoRelatedByCoUsuarioUpdatedCriteria = null;

			$this->collJ005tTransaccions = null;
			$this->lastJ005tTransaccionCriteria = null;

			$this->collJ010tEvaluacions = null;
			$this->lastJ010tEvaluacionCriteria = null;

			$this->collJ012tCronogramas = null;
			$this->lastJ012tCronogramaCriteria = null;

			$this->collJ016tForensesRelatedByCoUsuarioApertura = null;
			$this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria = null;

			$this->collJ016tForensesRelatedByCoUsuarioCierre = null;
			$this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria = null;

			$this->collJ016tForensesRelatedByCoUsuarioUpdate = null;
			$this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria = null;

			$this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated = null;
			$this->lastJ017tAlcanceForenseRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated = null;
			$this->lastJ017tAlcanceForenseRelatedByCoUsuarioUpdatedCriteria = null;

			$this->collJ018tInformeForensesRelatedByCoRevisa = null;
			$this->lastJ018tInformeForenseRelatedByCoRevisaCriteria = null;

			$this->collJ018tInformeForensesRelatedByCoAprueba = null;
			$this->lastJ018tInformeForenseRelatedByCoApruebaCriteria = null;

			$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = null;
			$this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = null;
			$this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria = null;

			$this->collJ019tParticipantess = null;
			$this->lastJ019tParticipantesCriteria = null;

			$this->collJ020tActaAccsRelatedByCoElabora = null;
			$this->lastJ020tActaAccRelatedByCoElaboraCriteria = null;

			$this->collJ020tActaAccsRelatedByCoDestruye = null;
			$this->lastJ020tActaAccRelatedByCoDestruyeCriteria = null;

			$this->collJ020tActaAccsRelatedByCoUsuarioCreated = null;
			$this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = null;
			$this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria = null;

			$this->collJ021tActaAiesRelatedByCoElabora = null;
			$this->lastJ021tActaAieRelatedByCoElaboraCriteria = null;

			$this->collJ021tActaAiesRelatedByCoUsuarioCreated = null;
			$this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = null;
			$this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria = null;

			$this->collJ022tActaAniesRelatedByCoElabora = null;
			$this->lastJ022tActaAnieRelatedByCoElaboraCriteria = null;

			$this->collJ022tActaAniesRelatedByCoCustodioNiega = null;
			$this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria = null;

			$this->collJ022tActaAniesRelatedByCoUsuarioCreated = null;
			$this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = null;
			$this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria = null;

			$this->collJ023tEvidenciasRelatedByCoRegistro = null;
			$this->lastJ023tEvidenciaRelatedByCoRegistroCriteria = null;

			$this->collJ023tEvidenciasRelatedByCoColecta = null;
			$this->lastJ023tEvidenciaRelatedByCoColectaCriteria = null;

			$this->collJ023tEvidenciasRelatedByCoCustodioSti = null;
			$this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria = null;

			$this->collJ023tEvidenciasRelatedByCoUpdateAt = null;
			$this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria = null;

			$this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated = null;
			$this->lastJ025tTipoEvidenciaRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated = null;
			$this->lastJ025tTipoEvidenciaRelatedByCoUsuarioUpdatedCriteria = null;

			$this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated = null;
			$this->lastJ026tEstadoEvidenciaRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated = null;
			$this->lastJ026tEstadoEvidenciaRelatedByCoUsuarioUpdatedCriteria = null;

			$this->collJ027tLugarSegurosRelatedByCoUsuarioCreated = null;
			$this->lastJ027tLugarSeguroRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated = null;
			$this->lastJ027tLugarSeguroRelatedByCoUsuarioUpdatedCriteria = null;

			$this->collJ028tRepositoriosRelatedByCoUsuarioCreated = null;
			$this->lastJ028tRepositorioRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ028tRepositoriosRelatedByCoUsuarioUpdated = null;
			$this->lastJ028tRepositorioRelatedByCoUsuarioUpdatedCriteria = null;

			$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = null;
			$this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria = null;

			$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = null;
			$this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria = null;

			$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = null;
			$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = null;
			$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria = null;

			$this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar = null;
			$this->lastJ031tAccionRecomendadaRelatedByCoResponsableStiEjecutarCriteria = null;

			$this->collJ031tAccionRecomendadasRelatedByCoCreatedAt = null;
			$this->lastJ031tAccionRecomendadaRelatedByCoCreatedAtCriteria = null;

			$this->collJ031tAccionRecomendadasRelatedByCoUpdateAt = null;
			$this->lastJ031tAccionRecomendadaRelatedByCoUpdateAtCriteria = null;

			$this->collJ034tIncidentesRelatedByCoUsuarioApertura = null;
			$this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria = null;

			$this->collJ034tIncidentesRelatedByCoUsuarioEscala = null;
			$this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria = null;

			$this->collJ034tIncidentesRelatedByCoUsuarioCierre = null;
			$this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria = null;

			$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = null;
			$this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria = null;

			$this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated = null;
			$this->lastJ042tEstadoIncidenteRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated = null;
			$this->lastJ042tEstadoIncidenteRelatedByCoUsuarioUpdatedCriteria = null;

			$this->collJ047tDocumentoNormativosRelatedByCoAprueba1 = null;
			$this->lastJ047tDocumentoNormativoRelatedByCoAprueba1Criteria = null;

			$this->collJ047tDocumentoNormativosRelatedByCoAprueba2 = null;
			$this->lastJ047tDocumentoNormativoRelatedByCoAprueba2Criteria = null;

			$this->collJ047tDocumentoNormativosRelatedByCoElimina1 = null;
			$this->lastJ047tDocumentoNormativoRelatedByCoElimina1Criteria = null;

			$this->collJ047tDocumentoNormativosRelatedByCoElimina2 = null;
			$this->lastJ047tDocumentoNormativoRelatedByCoElimina2Criteria = null;

			$this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated = null;
			$this->lastJ047tDocumentoNormativoRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated = null;
			$this->lastJ047tDocumentoNormativoRelatedByCoUsuarioUpdatedCriteria = null;

			$this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated = null;
			$this->lastJ048tEstadoDocumentoRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated = null;
			$this->lastJ048tEstadoDocumentoRelatedByCoUsuarioUpdatedCriteria = null;

			$this->collJ049tTipoMarcosRelatedByCoUsuarioCreated = null;
			$this->lastJ049tTipoMarcoRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated = null;
			$this->lastJ049tTipoMarcoRelatedByCoUsuarioUpdatedCriteria = null;

			$this->collJ050tInformeMarcosRelatedByCoUsuarioCreated = null;
			$this->lastJ050tInformeMarcoRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate = null;
			$this->lastJ050tInformeMarcoRelatedByCoUsuarioUpdateCriteria = null;

			$this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated = null;
			$this->lastJ051tTipoRevisionRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated = null;
			$this->lastJ051tTipoRevisionRelatedByCoUsuarioUpdatedCriteria = null;

			$this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated = null;
			$this->lastJ052tTipoJustificacionRelatedByCoUsuarioCreatedCriteria = null;

			$this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated = null;
			$this->lastJ052tTipoJustificacionRelatedByCoUsuarioUpdatedCriteria = null;

		} // if (deep)
	}

	/**
	 * Removes this object from datastore and sets delete attribute.
	 *
	 * @param      PropelPDO $con
	 * @return     void
	 * @throws     PropelException
	 * @see        BaseObject::setDeleted()
	 * @see        BaseObject::isDeleted()
	 */
	public function delete(PropelPDO $con = null)
	{

    foreach (sfMixer::getCallables('BaseJ002tUsuario:delete:pre') as $callable)
    {
      $ret = call_user_func($callable, $this, $con);
      if ($ret)
      {
        return;
      }
    }


		if ($this->isDeleted()) {
			throw new PropelException("This object has already been deleted.");
		}

		if ($con === null) {
			$con = Propel::getConnection(J002tUsuarioPeer::DATABASE_NAME, Propel::CONNECTION_WRITE);
		}
		
		$con->beginTransaction();
		try {
			J002tUsuarioPeer::doDelete($this, $con);
			$this->setDeleted(true);
			$con->commit();
		} catch (PropelException $e) {
			$con->rollBack();
			throw $e;
		}
	

    foreach (sfMixer::getCallables('BaseJ002tUsuario:delete:post') as $callable)
    {
      call_user_func($callable, $this, $con);
    }

  }
	/**
	 * Persists this object to the database.
	 *
	 * If the object is new, it inserts it; otherwise an update is performed.
	 * All modified related objects will also be persisted in the doSave()
	 * method.  This method wraps all precipitate database operations in a
	 * single transaction.
	 *
	 * @param      PropelPDO $con
	 * @return     int The number of rows affected by this insert/update and any referring fk objects' save() operations.
	 * @throws     PropelException
	 * @see        doSave()
	 */
	public function save(PropelPDO $con = null)
	{

    foreach (sfMixer::getCallables('BaseJ002tUsuario:save:pre') as $callable)
    {
      $affectedRows = call_user_func($callable, $this, $con);
      if (is_int($affectedRows))
      {
        return $affectedRows;
      }
    }


		if ($this->isDeleted()) {
			throw new PropelException("You cannot save an object that has been deleted.");
		}

		if ($con === null) {
			$con = Propel::getConnection(J002tUsuarioPeer::DATABASE_NAME, Propel::CONNECTION_WRITE);
		}
		
		$con->beginTransaction();
		try {
			$affectedRows = $this->doSave($con);
			$con->commit();
    foreach (sfMixer::getCallables('BaseJ002tUsuario:save:post') as $callable)
    {
      call_user_func($callable, $this, $con, $affectedRows);
    }

			J002tUsuarioPeer::addInstanceToPool($this);
			return $affectedRows;
		} catch (PropelException $e) {
			$con->rollBack();
			throw $e;
		}
	}

	/**
	 * Performs the work of inserting or updating the row in the database.
	 *
	 * If the object is new, it inserts it; otherwise an update is performed.
	 * All related objects are also updated in this method.
	 *
	 * @param      PropelPDO $con
	 * @return     int The number of rows affected by this insert/update and any referring fk objects' save() operations.
	 * @throws     PropelException
	 * @see        save()
	 */
	protected function doSave(PropelPDO $con)
	{
		$affectedRows = 0; // initialize var to track total num of affected rows
		if (!$this->alreadyInSave) {
			$this->alreadyInSave = true;

			// We call the save method on the following object(s) if they
			// were passed to this object by their coresponding set
			// method.  This object relates to these object(s) by a
			// foreign key reference.

			if ($this->aJ008tDivision !== null) {
				if ($this->aJ008tDivision->isModified() || $this->aJ008tDivision->isNew()) {
					$affectedRows += $this->aJ008tDivision->save($con);
				}
				$this->setJ008tDivision($this->aJ008tDivision);
			}

			if ($this->aJ003tRol !== null) {
				if ($this->aJ003tRol->isModified() || $this->aJ003tRol->isNew()) {
					$affectedRows += $this->aJ003tRol->save($con);
				}
				$this->setJ003tRol($this->aJ003tRol);
			}

			if ($this->aJ007tRegion !== null) {
				if ($this->aJ007tRegion->isModified() || $this->aJ007tRegion->isNew()) {
					$affectedRows += $this->aJ007tRegion->save($con);
				}
				$this->setJ007tRegion($this->aJ007tRegion);
			}

			if ($this->aJ014tNegocio !== null) {
				if ($this->aJ014tNegocio->isModified() || $this->aJ014tNegocio->isNew()) {
					$affectedRows += $this->aJ014tNegocio->save($con);
				}
				$this->setJ014tNegocio($this->aJ014tNegocio);
			}

			if ($this->isNew() ) {
				$this->modifiedColumns[] = J002tUsuarioPeer::CO_USUARIO;
			}

			// If this object has been modified, then save it to the database.
			if ($this->isModified()) {
				if ($this->isNew()) {
					$pk = J002tUsuarioPeer::doInsert($this, $con);
					$affectedRows += 1; // we are assuming that there is only 1 row per doInsert() which
										 // should always be true here (even though technically
										 // BasePeer::doInsert() can insert multiple rows).

					$this->setCoUsuario($pk);  //[IMV] update autoincrement primary key

					$this->setNew(false);
				} else {
					$affectedRows += J002tUsuarioPeer::doUpdate($this, $con);
				}

				$this->resetModified(); // [HL] After being saved an object is no longer 'modified'
			}

			if ($this->collC024tRecursosRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collC024tRecursosRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collC024tRecursosRelatedByCoUsuarioUpdated !== null) {
				foreach ($this->collC024tRecursosRelatedByCoUsuarioUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ005tTransaccions !== null) {
				foreach ($this->collJ005tTransaccions as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ010tEvaluacions !== null) {
				foreach ($this->collJ010tEvaluacions as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ012tCronogramas !== null) {
				foreach ($this->collJ012tCronogramas as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ016tForensesRelatedByCoUsuarioApertura !== null) {
				foreach ($this->collJ016tForensesRelatedByCoUsuarioApertura as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ016tForensesRelatedByCoUsuarioCierre !== null) {
				foreach ($this->collJ016tForensesRelatedByCoUsuarioCierre as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ016tForensesRelatedByCoUsuarioUpdate !== null) {
				foreach ($this->collJ016tForensesRelatedByCoUsuarioUpdate as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated !== null) {
				foreach ($this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ018tInformeForensesRelatedByCoRevisa !== null) {
				foreach ($this->collJ018tInformeForensesRelatedByCoRevisa as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ018tInformeForensesRelatedByCoAprueba !== null) {
				foreach ($this->collJ018tInformeForensesRelatedByCoAprueba as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ018tInformeForensesRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ018tInformeForensesRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ018tInformeForensesRelatedByCoUsuarioUpdate !== null) {
				foreach ($this->collJ018tInformeForensesRelatedByCoUsuarioUpdate as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ019tParticipantess !== null) {
				foreach ($this->collJ019tParticipantess as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ020tActaAccsRelatedByCoElabora !== null) {
				foreach ($this->collJ020tActaAccsRelatedByCoElabora as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ020tActaAccsRelatedByCoDestruye !== null) {
				foreach ($this->collJ020tActaAccsRelatedByCoDestruye as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ020tActaAccsRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ020tActaAccsRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ020tActaAccsRelatedByCoUsuarioUpdate !== null) {
				foreach ($this->collJ020tActaAccsRelatedByCoUsuarioUpdate as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ021tActaAiesRelatedByCoElabora !== null) {
				foreach ($this->collJ021tActaAiesRelatedByCoElabora as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ021tActaAiesRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ021tActaAiesRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ021tActaAiesRelatedByCoUsuarioUpdate !== null) {
				foreach ($this->collJ021tActaAiesRelatedByCoUsuarioUpdate as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ022tActaAniesRelatedByCoElabora !== null) {
				foreach ($this->collJ022tActaAniesRelatedByCoElabora as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ022tActaAniesRelatedByCoCustodioNiega !== null) {
				foreach ($this->collJ022tActaAniesRelatedByCoCustodioNiega as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ022tActaAniesRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ022tActaAniesRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ022tActaAniesRelatedByCoUsuarioUpdate !== null) {
				foreach ($this->collJ022tActaAniesRelatedByCoUsuarioUpdate as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ023tEvidenciasRelatedByCoRegistro !== null) {
				foreach ($this->collJ023tEvidenciasRelatedByCoRegistro as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ023tEvidenciasRelatedByCoColecta !== null) {
				foreach ($this->collJ023tEvidenciasRelatedByCoColecta as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ023tEvidenciasRelatedByCoCustodioSti !== null) {
				foreach ($this->collJ023tEvidenciasRelatedByCoCustodioSti as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ023tEvidenciasRelatedByCoUpdateAt !== null) {
				foreach ($this->collJ023tEvidenciasRelatedByCoUpdateAt as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated !== null) {
				foreach ($this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated !== null) {
				foreach ($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ027tLugarSegurosRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ027tLugarSegurosRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated !== null) {
				foreach ($this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ028tRepositoriosRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ028tRepositoriosRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ028tRepositoriosRelatedByCoUsuarioUpdated !== null) {
				foreach ($this->collJ028tRepositoriosRelatedByCoUsuarioUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ030tInformeRecomendacionessRelatedByCoRevisa !== null) {
				foreach ($this->collJ030tInformeRecomendacionessRelatedByCoRevisa as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ030tInformeRecomendacionessRelatedByCoAprueba !== null) {
				foreach ($this->collJ030tInformeRecomendacionessRelatedByCoAprueba as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate !== null) {
				foreach ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar !== null) {
				foreach ($this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ031tAccionRecomendadasRelatedByCoCreatedAt !== null) {
				foreach ($this->collJ031tAccionRecomendadasRelatedByCoCreatedAt as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ031tAccionRecomendadasRelatedByCoUpdateAt !== null) {
				foreach ($this->collJ031tAccionRecomendadasRelatedByCoUpdateAt as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ034tIncidentesRelatedByCoUsuarioApertura !== null) {
				foreach ($this->collJ034tIncidentesRelatedByCoUsuarioApertura as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ034tIncidentesRelatedByCoUsuarioEscala !== null) {
				foreach ($this->collJ034tIncidentesRelatedByCoUsuarioEscala as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ034tIncidentesRelatedByCoUsuarioCierre !== null) {
				foreach ($this->collJ034tIncidentesRelatedByCoUsuarioCierre as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ034tIncidentesRelatedByCoUsuarioUpdate !== null) {
				foreach ($this->collJ034tIncidentesRelatedByCoUsuarioUpdate as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated !== null) {
				foreach ($this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ047tDocumentoNormativosRelatedByCoAprueba1 !== null) {
				foreach ($this->collJ047tDocumentoNormativosRelatedByCoAprueba1 as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ047tDocumentoNormativosRelatedByCoAprueba2 !== null) {
				foreach ($this->collJ047tDocumentoNormativosRelatedByCoAprueba2 as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ047tDocumentoNormativosRelatedByCoElimina1 !== null) {
				foreach ($this->collJ047tDocumentoNormativosRelatedByCoElimina1 as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ047tDocumentoNormativosRelatedByCoElimina2 !== null) {
				foreach ($this->collJ047tDocumentoNormativosRelatedByCoElimina2 as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated !== null) {
				foreach ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated !== null) {
				foreach ($this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ049tTipoMarcosRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ049tTipoMarcosRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated !== null) {
				foreach ($this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ050tInformeMarcosRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ050tInformeMarcosRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate !== null) {
				foreach ($this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated !== null) {
				foreach ($this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated !== null) {
				foreach ($this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated !== null) {
				foreach ($this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			$this->alreadyInSave = false;

		}
		return $affectedRows;
	} // doSave()

	/**
	 * Array of ValidationFailed objects.
	 * @var        array ValidationFailed[]
	 */
	protected $validationFailures = array();

	/**
	 * Gets any ValidationFailed objects that resulted from last call to validate().
	 *
	 *
	 * @return     array ValidationFailed[]
	 * @see        validate()
	 */
	public function getValidationFailures()
	{
		return $this->validationFailures;
	}

	/**
	 * Validates the objects modified field values and all objects related to this table.
	 *
	 * If $columns is either a column name or an array of column names
	 * only those columns are validated.
	 *
	 * @param      mixed $columns Column name or an array of column names.
	 * @return     boolean Whether all columns pass validation.
	 * @see        doValidate()
	 * @see        getValidationFailures()
	 */
	public function validate($columns = null)
	{
		$res = $this->doValidate($columns);
		if ($res === true) {
			$this->validationFailures = array();
			return true;
		} else {
			$this->validationFailures = $res;
			return false;
		}
	}

	/**
	 * This function performs the validation work for complex object models.
	 *
	 * In addition to checking the current object, all related objects will
	 * also be validated.  If all pass then <code>true</code> is returned; otherwise
	 * an aggreagated array of ValidationFailed objects will be returned.
	 *
	 * @param      array $columns Array of column names to validate.
	 * @return     mixed <code>true</code> if all validations pass; array of <code>ValidationFailed</code> objets otherwise.
	 */
	protected function doValidate($columns = null)
	{
		if (!$this->alreadyInValidation) {
			$this->alreadyInValidation = true;
			$retval = null;

			$failureMap = array();


			// We call the validate method on the following object(s) if they
			// were passed to this object by their coresponding set
			// method.  This object relates to these object(s) by a
			// foreign key reference.

			if ($this->aJ008tDivision !== null) {
				if (!$this->aJ008tDivision->validate($columns)) {
					$failureMap = array_merge($failureMap, $this->aJ008tDivision->getValidationFailures());
				}
			}

			if ($this->aJ003tRol !== null) {
				if (!$this->aJ003tRol->validate($columns)) {
					$failureMap = array_merge($failureMap, $this->aJ003tRol->getValidationFailures());
				}
			}

			if ($this->aJ007tRegion !== null) {
				if (!$this->aJ007tRegion->validate($columns)) {
					$failureMap = array_merge($failureMap, $this->aJ007tRegion->getValidationFailures());
				}
			}

			if ($this->aJ014tNegocio !== null) {
				if (!$this->aJ014tNegocio->validate($columns)) {
					$failureMap = array_merge($failureMap, $this->aJ014tNegocio->getValidationFailures());
				}
			}


			if (($retval = J002tUsuarioPeer::doValidate($this, $columns)) !== true) {
				$failureMap = array_merge($failureMap, $retval);
			}


				if ($this->collC024tRecursosRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collC024tRecursosRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collC024tRecursosRelatedByCoUsuarioUpdated !== null) {
					foreach ($this->collC024tRecursosRelatedByCoUsuarioUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ005tTransaccions !== null) {
					foreach ($this->collJ005tTransaccions as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ010tEvaluacions !== null) {
					foreach ($this->collJ010tEvaluacions as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ012tCronogramas !== null) {
					foreach ($this->collJ012tCronogramas as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ016tForensesRelatedByCoUsuarioApertura !== null) {
					foreach ($this->collJ016tForensesRelatedByCoUsuarioApertura as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ016tForensesRelatedByCoUsuarioCierre !== null) {
					foreach ($this->collJ016tForensesRelatedByCoUsuarioCierre as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ016tForensesRelatedByCoUsuarioUpdate !== null) {
					foreach ($this->collJ016tForensesRelatedByCoUsuarioUpdate as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated !== null) {
					foreach ($this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ018tInformeForensesRelatedByCoRevisa !== null) {
					foreach ($this->collJ018tInformeForensesRelatedByCoRevisa as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ018tInformeForensesRelatedByCoAprueba !== null) {
					foreach ($this->collJ018tInformeForensesRelatedByCoAprueba as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ018tInformeForensesRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ018tInformeForensesRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ018tInformeForensesRelatedByCoUsuarioUpdate !== null) {
					foreach ($this->collJ018tInformeForensesRelatedByCoUsuarioUpdate as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ019tParticipantess !== null) {
					foreach ($this->collJ019tParticipantess as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ020tActaAccsRelatedByCoElabora !== null) {
					foreach ($this->collJ020tActaAccsRelatedByCoElabora as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ020tActaAccsRelatedByCoDestruye !== null) {
					foreach ($this->collJ020tActaAccsRelatedByCoDestruye as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ020tActaAccsRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ020tActaAccsRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ020tActaAccsRelatedByCoUsuarioUpdate !== null) {
					foreach ($this->collJ020tActaAccsRelatedByCoUsuarioUpdate as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ021tActaAiesRelatedByCoElabora !== null) {
					foreach ($this->collJ021tActaAiesRelatedByCoElabora as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ021tActaAiesRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ021tActaAiesRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ021tActaAiesRelatedByCoUsuarioUpdate !== null) {
					foreach ($this->collJ021tActaAiesRelatedByCoUsuarioUpdate as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ022tActaAniesRelatedByCoElabora !== null) {
					foreach ($this->collJ022tActaAniesRelatedByCoElabora as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ022tActaAniesRelatedByCoCustodioNiega !== null) {
					foreach ($this->collJ022tActaAniesRelatedByCoCustodioNiega as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ022tActaAniesRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ022tActaAniesRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ022tActaAniesRelatedByCoUsuarioUpdate !== null) {
					foreach ($this->collJ022tActaAniesRelatedByCoUsuarioUpdate as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ023tEvidenciasRelatedByCoRegistro !== null) {
					foreach ($this->collJ023tEvidenciasRelatedByCoRegistro as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ023tEvidenciasRelatedByCoColecta !== null) {
					foreach ($this->collJ023tEvidenciasRelatedByCoColecta as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ023tEvidenciasRelatedByCoCustodioSti !== null) {
					foreach ($this->collJ023tEvidenciasRelatedByCoCustodioSti as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ023tEvidenciasRelatedByCoUpdateAt !== null) {
					foreach ($this->collJ023tEvidenciasRelatedByCoUpdateAt as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated !== null) {
					foreach ($this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated !== null) {
					foreach ($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ027tLugarSegurosRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ027tLugarSegurosRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated !== null) {
					foreach ($this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ028tRepositoriosRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ028tRepositoriosRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ028tRepositoriosRelatedByCoUsuarioUpdated !== null) {
					foreach ($this->collJ028tRepositoriosRelatedByCoUsuarioUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ030tInformeRecomendacionessRelatedByCoRevisa !== null) {
					foreach ($this->collJ030tInformeRecomendacionessRelatedByCoRevisa as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ030tInformeRecomendacionessRelatedByCoAprueba !== null) {
					foreach ($this->collJ030tInformeRecomendacionessRelatedByCoAprueba as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate !== null) {
					foreach ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar !== null) {
					foreach ($this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ031tAccionRecomendadasRelatedByCoCreatedAt !== null) {
					foreach ($this->collJ031tAccionRecomendadasRelatedByCoCreatedAt as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ031tAccionRecomendadasRelatedByCoUpdateAt !== null) {
					foreach ($this->collJ031tAccionRecomendadasRelatedByCoUpdateAt as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ034tIncidentesRelatedByCoUsuarioApertura !== null) {
					foreach ($this->collJ034tIncidentesRelatedByCoUsuarioApertura as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ034tIncidentesRelatedByCoUsuarioEscala !== null) {
					foreach ($this->collJ034tIncidentesRelatedByCoUsuarioEscala as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ034tIncidentesRelatedByCoUsuarioCierre !== null) {
					foreach ($this->collJ034tIncidentesRelatedByCoUsuarioCierre as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ034tIncidentesRelatedByCoUsuarioUpdate !== null) {
					foreach ($this->collJ034tIncidentesRelatedByCoUsuarioUpdate as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated !== null) {
					foreach ($this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ047tDocumentoNormativosRelatedByCoAprueba1 !== null) {
					foreach ($this->collJ047tDocumentoNormativosRelatedByCoAprueba1 as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ047tDocumentoNormativosRelatedByCoAprueba2 !== null) {
					foreach ($this->collJ047tDocumentoNormativosRelatedByCoAprueba2 as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ047tDocumentoNormativosRelatedByCoElimina1 !== null) {
					foreach ($this->collJ047tDocumentoNormativosRelatedByCoElimina1 as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ047tDocumentoNormativosRelatedByCoElimina2 !== null) {
					foreach ($this->collJ047tDocumentoNormativosRelatedByCoElimina2 as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated !== null) {
					foreach ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated !== null) {
					foreach ($this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ049tTipoMarcosRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ049tTipoMarcosRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated !== null) {
					foreach ($this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ050tInformeMarcosRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ050tInformeMarcosRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate !== null) {
					foreach ($this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated !== null) {
					foreach ($this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated !== null) {
					foreach ($this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated !== null) {
					foreach ($this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}


			$this->alreadyInValidation = false;
		}

		return (!empty($failureMap) ? $failureMap : true);
	}

	/**
	 * Retrieves a field from the object by name passed in as a string.
	 *
	 * @param      string $name name
	 * @param      string $type The type of fieldname the $name is of:
	 *                     one of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME
	 *                     BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM
	 * @return     mixed Value of field.
	 */
	public function getByName($name, $type = BasePeer::TYPE_PHPNAME)
	{
		$pos = J002tUsuarioPeer::translateFieldName($name, $type, BasePeer::TYPE_NUM);
		$field = $this->getByPosition($pos);
		return $field;
	}

	/**
	 * Retrieves a field from the object by Position as specified in the xml schema.
	 * Zero-based.
	 *
	 * @param      int $pos position in xml schema
	 * @return     mixed Value of field at $pos
	 */
	public function getByPosition($pos)
	{
		switch($pos) {
			case 0:
				return $this->getCoUsuario();
				break;
			case 1:
				return $this->getTxIndicador();
				break;
			case 2:
				return $this->getNbEmpleado();
				break;
			case 3:
				return $this->getApEmpleado();
				break;
			case 4:
				return $this->getCoDivision();
				break;
			case 5:
				return $this->getCoRol();
				break;
			case 6:
				return $this->getCoRegion();
				break;
			case 7:
				return $this->getCoNegocio();
				break;
			default:
				return null;
				break;
		} // switch()
	}

	/**
	 * Exports the object as an array.
	 *
	 * You can specify the key type of the array by passing one of the class
	 * type constants.
	 *
	 * @param      string $keyType (optional) One of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME
	 *                        BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM. Defaults to BasePeer::TYPE_PHPNAME.
	 * @param      boolean $includeLazyLoadColumns (optional) Whether to include lazy loaded columns.  Defaults to TRUE.
	 * @return     an associative array containing the field names (as keys) and field values
	 */
	public function toArray($keyType = BasePeer::TYPE_PHPNAME, $includeLazyLoadColumns = true)
	{
		$keys = J002tUsuarioPeer::getFieldNames($keyType);
		$result = array(
			$keys[0] => $this->getCoUsuario(),
			$keys[1] => $this->getTxIndicador(),
			$keys[2] => $this->getNbEmpleado(),
			$keys[3] => $this->getApEmpleado(),
			$keys[4] => $this->getCoDivision(),
			$keys[5] => $this->getCoRol(),
			$keys[6] => $this->getCoRegion(),
			$keys[7] => $this->getCoNegocio(),
		);
		return $result;
	}

	/**
	 * Sets a field from the object by name passed in as a string.
	 *
	 * @param      string $name peer name
	 * @param      mixed $value field value
	 * @param      string $type The type of fieldname the $name is of:
	 *                     one of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME
	 *                     BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM
	 * @return     void
	 */
	public function setByName($name, $value, $type = BasePeer::TYPE_PHPNAME)
	{
		$pos = J002tUsuarioPeer::translateFieldName($name, $type, BasePeer::TYPE_NUM);
		return $this->setByPosition($pos, $value);
	}

	/**
	 * Sets a field from the object by Position as specified in the xml schema.
	 * Zero-based.
	 *
	 * @param      int $pos position in xml schema
	 * @param      mixed $value field value
	 * @return     void
	 */
	public function setByPosition($pos, $value)
	{
		switch($pos) {
			case 0:
				$this->setCoUsuario($value);
				break;
			case 1:
				$this->setTxIndicador($value);
				break;
			case 2:
				$this->setNbEmpleado($value);
				break;
			case 3:
				$this->setApEmpleado($value);
				break;
			case 4:
				$this->setCoDivision($value);
				break;
			case 5:
				$this->setCoRol($value);
				break;
			case 6:
				$this->setCoRegion($value);
				break;
			case 7:
				$this->setCoNegocio($value);
				break;
		} // switch()
	}

	/**
	 * Populates the object using an array.
	 *
	 * This is particularly useful when populating an object from one of the
	 * request arrays (e.g. $_POST).  This method goes through the column
	 * names, checking to see whether a matching key exists in populated
	 * array. If so the setByName() method is called for that column.
	 *
	 * You can specify the key type of the array by additionally passing one
	 * of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME,
	 * BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM.
	 * The default key type is the column's phpname (e.g. 'AuthorId')
	 *
	 * @param      array  $arr     An array to populate the object from.
	 * @param      string $keyType The type of keys the array uses.
	 * @return     void
	 */
	public function fromArray($arr, $keyType = BasePeer::TYPE_PHPNAME)
	{
		$keys = J002tUsuarioPeer::getFieldNames($keyType);

		if (array_key_exists($keys[0], $arr)) $this->setCoUsuario($arr[$keys[0]]);
		if (array_key_exists($keys[1], $arr)) $this->setTxIndicador($arr[$keys[1]]);
		if (array_key_exists($keys[2], $arr)) $this->setNbEmpleado($arr[$keys[2]]);
		if (array_key_exists($keys[3], $arr)) $this->setApEmpleado($arr[$keys[3]]);
		if (array_key_exists($keys[4], $arr)) $this->setCoDivision($arr[$keys[4]]);
		if (array_key_exists($keys[5], $arr)) $this->setCoRol($arr[$keys[5]]);
		if (array_key_exists($keys[6], $arr)) $this->setCoRegion($arr[$keys[6]]);
		if (array_key_exists($keys[7], $arr)) $this->setCoNegocio($arr[$keys[7]]);
	}

	/**
	 * Build a Criteria object containing the values of all modified columns in this object.
	 *
	 * @return     Criteria The Criteria object containing all modified values.
	 */
	public function buildCriteria()
	{
		$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);

		if ($this->isColumnModified(J002tUsuarioPeer::CO_USUARIO)) $criteria->add(J002tUsuarioPeer::CO_USUARIO, $this->co_usuario);
		if ($this->isColumnModified(J002tUsuarioPeer::TX_INDICADOR)) $criteria->add(J002tUsuarioPeer::TX_INDICADOR, $this->tx_indicador);
		if ($this->isColumnModified(J002tUsuarioPeer::NB_EMPLEADO)) $criteria->add(J002tUsuarioPeer::NB_EMPLEADO, $this->nb_empleado);
		if ($this->isColumnModified(J002tUsuarioPeer::AP_EMPLEADO)) $criteria->add(J002tUsuarioPeer::AP_EMPLEADO, $this->ap_empleado);
		if ($this->isColumnModified(J002tUsuarioPeer::CO_DIVISION)) $criteria->add(J002tUsuarioPeer::CO_DIVISION, $this->co_division);
		if ($this->isColumnModified(J002tUsuarioPeer::CO_ROL)) $criteria->add(J002tUsuarioPeer::CO_ROL, $this->co_rol);
		if ($this->isColumnModified(J002tUsuarioPeer::CO_REGION)) $criteria->add(J002tUsuarioPeer::CO_REGION, $this->co_region);
		if ($this->isColumnModified(J002tUsuarioPeer::CO_NEGOCIO)) $criteria->add(J002tUsuarioPeer::CO_NEGOCIO, $this->co_negocio);

		return $criteria;
	}

	/**
	 * Builds a Criteria object containing the primary key for this object.
	 *
	 * Unlike buildCriteria() this method includes the primary key values regardless
	 * of whether or not they have been modified.
	 *
	 * @return     Criteria The Criteria object containing value(s) for primary key(s).
	 */
	public function buildPkeyCriteria()
	{
		$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);

		$criteria->add(J002tUsuarioPeer::CO_USUARIO, $this->co_usuario);

		return $criteria;
	}

	/**
	 * Returns the primary key for this object (row).
	 * @return     string
	 */
	public function getPrimaryKey()
	{
		return $this->getCoUsuario();
	}

	/**
	 * Generic method to set the primary key (co_usuario column).
	 *
	 * @param      string $key Primary key.
	 * @return     void
	 */
	public function setPrimaryKey($key)
	{
		$this->setCoUsuario($key);
	}

	/**
	 * Sets contents of passed object to values from current object.
	 *
	 * If desired, this method can also make copies of all associated (fkey referrers)
	 * objects.
	 *
	 * @param      object $copyObj An object of J002tUsuario (or compatible) type.
	 * @param      boolean $deepCopy Whether to also copy all rows that refer (by fkey) to the current row.
	 * @throws     PropelException
	 */
	public function copyInto($copyObj, $deepCopy = false)
	{

		$copyObj->setTxIndicador($this->tx_indicador);

		$copyObj->setNbEmpleado($this->nb_empleado);

		$copyObj->setApEmpleado($this->ap_empleado);

		$copyObj->setCoDivision($this->co_division);

		$copyObj->setCoRol($this->co_rol);

		$copyObj->setCoRegion($this->co_region);

		$copyObj->setCoNegocio($this->co_negocio);


		if ($deepCopy) {
			// important: temporarily setNew(false) because this affects the behavior of
			// the getter/setter methods for fkey referrer objects.
			$copyObj->setNew(false);

			foreach ($this->getC024tRecursosRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addC024tRecursoRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getC024tRecursosRelatedByCoUsuarioUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addC024tRecursoRelatedByCoUsuarioUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ005tTransaccions() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ005tTransaccion($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ010tEvaluacions() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ010tEvaluacion($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ012tCronogramas() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ012tCronograma($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ016tForensesRelatedByCoUsuarioApertura() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ016tForenseRelatedByCoUsuarioApertura($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ016tForensesRelatedByCoUsuarioCierre() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ016tForenseRelatedByCoUsuarioCierre($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ016tForensesRelatedByCoUsuarioUpdate() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ016tForenseRelatedByCoUsuarioUpdate($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ017tAlcanceForensesRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ017tAlcanceForenseRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ017tAlcanceForensesRelatedByCoUsuarioUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ017tAlcanceForenseRelatedByCoUsuarioUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ018tInformeForensesRelatedByCoRevisa() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ018tInformeForenseRelatedByCoRevisa($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ018tInformeForensesRelatedByCoAprueba() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ018tInformeForenseRelatedByCoAprueba($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ018tInformeForensesRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ018tInformeForenseRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ018tInformeForensesRelatedByCoUsuarioUpdate() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ018tInformeForenseRelatedByCoUsuarioUpdate($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ019tParticipantess() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ019tParticipantes($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ020tActaAccsRelatedByCoElabora() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ020tActaAccRelatedByCoElabora($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ020tActaAccsRelatedByCoDestruye() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ020tActaAccRelatedByCoDestruye($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ020tActaAccsRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ020tActaAccRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ020tActaAccsRelatedByCoUsuarioUpdate() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ020tActaAccRelatedByCoUsuarioUpdate($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ021tActaAiesRelatedByCoElabora() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ021tActaAieRelatedByCoElabora($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ021tActaAiesRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ021tActaAieRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ021tActaAiesRelatedByCoUsuarioUpdate() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ021tActaAieRelatedByCoUsuarioUpdate($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ022tActaAniesRelatedByCoElabora() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ022tActaAnieRelatedByCoElabora($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ022tActaAniesRelatedByCoCustodioNiega() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ022tActaAnieRelatedByCoCustodioNiega($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ022tActaAniesRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ022tActaAnieRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ022tActaAniesRelatedByCoUsuarioUpdate() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ022tActaAnieRelatedByCoUsuarioUpdate($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ023tEvidenciasRelatedByCoRegistro() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ023tEvidenciaRelatedByCoRegistro($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ023tEvidenciasRelatedByCoColecta() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ023tEvidenciaRelatedByCoColecta($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ023tEvidenciasRelatedByCoCustodioSti() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ023tEvidenciaRelatedByCoCustodioSti($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ023tEvidenciasRelatedByCoUpdateAt() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ023tEvidenciaRelatedByCoUpdateAt($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ025tTipoEvidenciasRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ025tTipoEvidenciaRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ025tTipoEvidenciasRelatedByCoUsuarioUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ025tTipoEvidenciaRelatedByCoUsuarioUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ026tEstadoEvidenciasRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ026tEstadoEvidenciaRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ026tEstadoEvidenciaRelatedByCoUsuarioUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ027tLugarSegurosRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ027tLugarSeguroRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ027tLugarSegurosRelatedByCoUsuarioUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ027tLugarSeguroRelatedByCoUsuarioUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ028tRepositoriosRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ028tRepositorioRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ028tRepositoriosRelatedByCoUsuarioUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ028tRepositorioRelatedByCoUsuarioUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ030tInformeRecomendacionessRelatedByCoRevisa() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ030tInformeRecomendacionesRelatedByCoRevisa($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ030tInformeRecomendacionessRelatedByCoAprueba() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ030tInformeRecomendacionesRelatedByCoAprueba($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ030tInformeRecomendacionessRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ030tInformeRecomendacionesRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ030tInformeRecomendacionesRelatedByCoUsuarioUpdate($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ031tAccionRecomendadaRelatedByCoResponsableStiEjecutar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ031tAccionRecomendadasRelatedByCoCreatedAt() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ031tAccionRecomendadaRelatedByCoCreatedAt($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ031tAccionRecomendadasRelatedByCoUpdateAt() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ031tAccionRecomendadaRelatedByCoUpdateAt($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ034tIncidentesRelatedByCoUsuarioApertura() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ034tIncidenteRelatedByCoUsuarioApertura($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ034tIncidentesRelatedByCoUsuarioEscala() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ034tIncidenteRelatedByCoUsuarioEscala($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ034tIncidentesRelatedByCoUsuarioCierre() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ034tIncidenteRelatedByCoUsuarioCierre($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ034tIncidentesRelatedByCoUsuarioUpdate() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ034tIncidenteRelatedByCoUsuarioUpdate($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ042tEstadoIncidentesRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ042tEstadoIncidenteRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ042tEstadoIncidentesRelatedByCoUsuarioUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ042tEstadoIncidenteRelatedByCoUsuarioUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ047tDocumentoNormativosRelatedByCoAprueba1() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ047tDocumentoNormativoRelatedByCoAprueba1($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ047tDocumentoNormativosRelatedByCoAprueba2() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ047tDocumentoNormativoRelatedByCoAprueba2($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ047tDocumentoNormativosRelatedByCoElimina1() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ047tDocumentoNormativoRelatedByCoElimina1($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ047tDocumentoNormativosRelatedByCoElimina2() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ047tDocumentoNormativoRelatedByCoElimina2($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ047tDocumentoNormativosRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ047tDocumentoNormativoRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ047tDocumentoNormativosRelatedByCoUsuarioUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ047tDocumentoNormativoRelatedByCoUsuarioUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ048tEstadoDocumentosRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ048tEstadoDocumentoRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ048tEstadoDocumentosRelatedByCoUsuarioUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ048tEstadoDocumentoRelatedByCoUsuarioUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ049tTipoMarcosRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ049tTipoMarcoRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ049tTipoMarcosRelatedByCoUsuarioUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ049tTipoMarcoRelatedByCoUsuarioUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ050tInformeMarcosRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ050tInformeMarcoRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ050tInformeMarcosRelatedByCoUsuarioUpdate() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ050tInformeMarcoRelatedByCoUsuarioUpdate($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ051tTipoRevisionsRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ051tTipoRevisionRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ051tTipoRevisionsRelatedByCoUsuarioUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ051tTipoRevisionRelatedByCoUsuarioUpdated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ052tTipoJustificacionsRelatedByCoUsuarioCreated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ052tTipoJustificacionRelatedByCoUsuarioCreated($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getJ052tTipoJustificacionsRelatedByCoUsuarioUpdated() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addJ052tTipoJustificacionRelatedByCoUsuarioUpdated($relObj->copy($deepCopy));
				}
			}

		} // if ($deepCopy)


		$copyObj->setNew(true);

		$copyObj->setCoUsuario(NULL); // this is a auto-increment column, so set to default value

	}

	/**
	 * Makes a copy of this object that will be inserted as a new row in table when saved.
	 * It creates a new object filling in the simple attributes, but skipping any primary
	 * keys that are defined for the table.
	 *
	 * If desired, this method can also make copies of all associated (fkey referrers)
	 * objects.
	 *
	 * @param      boolean $deepCopy Whether to also copy all rows that refer (by fkey) to the current row.
	 * @return     J002tUsuario Clone of current object.
	 * @throws     PropelException
	 */
	public function copy($deepCopy = false)
	{
		// we use get_class(), because this might be a subclass
		$clazz = get_class($this);
		$copyObj = new $clazz();
		$this->copyInto($copyObj, $deepCopy);
		return $copyObj;
	}

	/**
	 * Returns a peer instance associated with this om.
	 *
	 * Since Peer classes are not to have any instance attributes, this method returns the
	 * same instance for all member of this class. The method could therefore
	 * be static, but this would prevent one from overriding the behavior.
	 *
	 * @return     J002tUsuarioPeer
	 */
	public function getPeer()
	{
		if (self::$peer === null) {
			self::$peer = new J002tUsuarioPeer();
		}
		return self::$peer;
	}

	/**
	 * Declares an association between this object and a J008tDivision object.
	 *
	 * @param      J008tDivision $v
	 * @return     J002tUsuario The current object (for fluent API support)
	 * @throws     PropelException
	 */
	public function setJ008tDivision(J008tDivision $v = null)
	{
		if ($v === null) {
			$this->setCoDivision(NULL);
		} else {
			$this->setCoDivision($v->getCoDivision());
		}

		$this->aJ008tDivision = $v;

		// Add binding for other direction of this n:n relationship.
		// If this object has already been added to the J008tDivision object, it will not be re-added.
		if ($v !== null) {
			$v->addJ002tUsuario($this);
		}

		return $this;
	}


	/**
	 * Get the associated J008tDivision object
	 *
	 * @param      PropelPDO Optional Connection object.
	 * @return     J008tDivision The associated J008tDivision object.
	 * @throws     PropelException
	 */
	public function getJ008tDivision(PropelPDO $con = null)
	{
		if ($this->aJ008tDivision === null && (($this->co_division !== "" && $this->co_division !== null))) {
			$c = new Criteria(J008tDivisionPeer::DATABASE_NAME);
			$c->add(J008tDivisionPeer::CO_DIVISION, $this->co_division);
			$this->aJ008tDivision = J008tDivisionPeer::doSelectOne($c, $con);
			/* The following can be used additionally to
			   guarantee the related object contains a reference
			   to this object.  This level of coupling may, however, be
			   undesirable since it could result in an only partially populated collection
			   in the referenced object.
			   $this->aJ008tDivision->addJ002tUsuarios($this);
			 */
		}
		return $this->aJ008tDivision;
	}

	/**
	 * Declares an association between this object and a J003tRol object.
	 *
	 * @param      J003tRol $v
	 * @return     J002tUsuario The current object (for fluent API support)
	 * @throws     PropelException
	 */
	public function setJ003tRol(J003tRol $v = null)
	{
		if ($v === null) {
			$this->setCoRol(NULL);
		} else {
			$this->setCoRol($v->getCoRol());
		}

		$this->aJ003tRol = $v;

		// Add binding for other direction of this n:n relationship.
		// If this object has already been added to the J003tRol object, it will not be re-added.
		if ($v !== null) {
			$v->addJ002tUsuario($this);
		}

		return $this;
	}


	/**
	 * Get the associated J003tRol object
	 *
	 * @param      PropelPDO Optional Connection object.
	 * @return     J003tRol The associated J003tRol object.
	 * @throws     PropelException
	 */
	public function getJ003tRol(PropelPDO $con = null)
	{
		if ($this->aJ003tRol === null && (($this->co_rol !== "" && $this->co_rol !== null))) {
			$c = new Criteria(J003tRolPeer::DATABASE_NAME);
			$c->add(J003tRolPeer::CO_ROL, $this->co_rol);
			$this->aJ003tRol = J003tRolPeer::doSelectOne($c, $con);
			/* The following can be used additionally to
			   guarantee the related object contains a reference
			   to this object.  This level of coupling may, however, be
			   undesirable since it could result in an only partially populated collection
			   in the referenced object.
			   $this->aJ003tRol->addJ002tUsuarios($this);
			 */
		}
		return $this->aJ003tRol;
	}

	/**
	 * Declares an association between this object and a J007tRegion object.
	 *
	 * @param      J007tRegion $v
	 * @return     J002tUsuario The current object (for fluent API support)
	 * @throws     PropelException
	 */
	public function setJ007tRegion(J007tRegion $v = null)
	{
		if ($v === null) {
			$this->setCoRegion(NULL);
		} else {
			$this->setCoRegion($v->getCoRegion());
		}

		$this->aJ007tRegion = $v;

		// Add binding for other direction of this n:n relationship.
		// If this object has already been added to the J007tRegion object, it will not be re-added.
		if ($v !== null) {
			$v->addJ002tUsuario($this);
		}

		return $this;
	}


	/**
	 * Get the associated J007tRegion object
	 *
	 * @param      PropelPDO Optional Connection object.
	 * @return     J007tRegion The associated J007tRegion object.
	 * @throws     PropelException
	 */
	public function getJ007tRegion(PropelPDO $con = null)
	{
		if ($this->aJ007tRegion === null && (($this->co_region !== "" && $this->co_region !== null))) {
			$c = new Criteria(J007tRegionPeer::DATABASE_NAME);
			$c->add(J007tRegionPeer::CO_REGION, $this->co_region);
			$this->aJ007tRegion = J007tRegionPeer::doSelectOne($c, $con);
			/* The following can be used additionally to
			   guarantee the related object contains a reference
			   to this object.  This level of coupling may, however, be
			   undesirable since it could result in an only partially populated collection
			   in the referenced object.
			   $this->aJ007tRegion->addJ002tUsuarios($this);
			 */
		}
		return $this->aJ007tRegion;
	}

	/**
	 * Declares an association between this object and a J014tNegocio object.
	 *
	 * @param      J014tNegocio $v
	 * @return     J002tUsuario The current object (for fluent API support)
	 * @throws     PropelException
	 */
	public function setJ014tNegocio(J014tNegocio $v = null)
	{
		if ($v === null) {
			$this->setCoNegocio(NULL);
		} else {
			$this->setCoNegocio($v->getCoNegocio());
		}

		$this->aJ014tNegocio = $v;

		// Add binding for other direction of this n:n relationship.
		// If this object has already been added to the J014tNegocio object, it will not be re-added.
		if ($v !== null) {
			$v->addJ002tUsuario($this);
		}

		return $this;
	}


	/**
	 * Get the associated J014tNegocio object
	 *
	 * @param      PropelPDO Optional Connection object.
	 * @return     J014tNegocio The associated J014tNegocio object.
	 * @throws     PropelException
	 */
	public function getJ014tNegocio(PropelPDO $con = null)
	{
		if ($this->aJ014tNegocio === null && (($this->co_negocio !== "" && $this->co_negocio !== null))) {
			$c = new Criteria(J014tNegocioPeer::DATABASE_NAME);
			$c->add(J014tNegocioPeer::CO_NEGOCIO, $this->co_negocio);
			$this->aJ014tNegocio = J014tNegocioPeer::doSelectOne($c, $con);
			/* The following can be used additionally to
			   guarantee the related object contains a reference
			   to this object.  This level of coupling may, however, be
			   undesirable since it could result in an only partially populated collection
			   in the referenced object.
			   $this->aJ014tNegocio->addJ002tUsuarios($this);
			 */
		}
		return $this->aJ014tNegocio;
	}

	/**
	 * Clears out the collC024tRecursosRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addC024tRecursosRelatedByCoUsuarioCreated()
	 */
	public function clearC024tRecursosRelatedByCoUsuarioCreated()
	{
		$this->collC024tRecursosRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collC024tRecursosRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collC024tRecursosRelatedByCoUsuarioCreated collection to an empty array (like clearcollC024tRecursosRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initC024tRecursosRelatedByCoUsuarioCreated()
	{
		$this->collC024tRecursosRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of C024tRecurso objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related C024tRecursosRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array C024tRecurso[]
	 * @throws     PropelException
	 */
	public function getC024tRecursosRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collC024tRecursosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collC024tRecursosRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(C024tRecursoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				C024tRecursoPeer::addSelectColumns($criteria);
				$this->collC024tRecursosRelatedByCoUsuarioCreated = C024tRecursoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(C024tRecursoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				C024tRecursoPeer::addSelectColumns($criteria);
				if (!isset($this->lastC024tRecursoRelatedByCoUsuarioCreatedCriteria) || !$this->lastC024tRecursoRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collC024tRecursosRelatedByCoUsuarioCreated = C024tRecursoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastC024tRecursoRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collC024tRecursosRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related C024tRecurso objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related C024tRecurso objects.
	 * @throws     PropelException
	 */
	public function countC024tRecursosRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collC024tRecursosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(C024tRecursoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = C024tRecursoPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(C024tRecursoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastC024tRecursoRelatedByCoUsuarioCreatedCriteria) || !$this->lastC024tRecursoRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = C024tRecursoPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collC024tRecursosRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collC024tRecursosRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a C024tRecurso object to this object
	 * through the C024tRecurso foreign key attribute.
	 *
	 * @param      C024tRecurso $l C024tRecurso
	 * @return     void
	 * @throws     PropelException
	 */
	public function addC024tRecursoRelatedByCoUsuarioCreated(C024tRecurso $l)
	{
		if ($this->collC024tRecursosRelatedByCoUsuarioCreated === null) {
			$this->initC024tRecursosRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collC024tRecursosRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collC024tRecursosRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}

	/**
	 * Clears out the collC024tRecursosRelatedByCoUsuarioUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addC024tRecursosRelatedByCoUsuarioUpdated()
	 */
	public function clearC024tRecursosRelatedByCoUsuarioUpdated()
	{
		$this->collC024tRecursosRelatedByCoUsuarioUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collC024tRecursosRelatedByCoUsuarioUpdated collection (array).
	 *
	 * By default this just sets the collC024tRecursosRelatedByCoUsuarioUpdated collection to an empty array (like clearcollC024tRecursosRelatedByCoUsuarioUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initC024tRecursosRelatedByCoUsuarioUpdated()
	{
		$this->collC024tRecursosRelatedByCoUsuarioUpdated = array();
	}

	/**
	 * Gets an array of C024tRecurso objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related C024tRecursosRelatedByCoUsuarioUpdated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array C024tRecurso[]
	 * @throws     PropelException
	 */
	public function getC024tRecursosRelatedByCoUsuarioUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collC024tRecursosRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
			   $this->collC024tRecursosRelatedByCoUsuarioUpdated = array();
			} else {

				$criteria->add(C024tRecursoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				C024tRecursoPeer::addSelectColumns($criteria);
				$this->collC024tRecursosRelatedByCoUsuarioUpdated = C024tRecursoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(C024tRecursoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				C024tRecursoPeer::addSelectColumns($criteria);
				if (!isset($this->lastC024tRecursoRelatedByCoUsuarioUpdatedCriteria) || !$this->lastC024tRecursoRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$this->collC024tRecursosRelatedByCoUsuarioUpdated = C024tRecursoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastC024tRecursoRelatedByCoUsuarioUpdatedCriteria = $criteria;
		return $this->collC024tRecursosRelatedByCoUsuarioUpdated;
	}

	/**
	 * Returns the number of related C024tRecurso objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related C024tRecurso objects.
	 * @throws     PropelException
	 */
	public function countC024tRecursosRelatedByCoUsuarioUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collC024tRecursosRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(C024tRecursoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				$count = C024tRecursoPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(C024tRecursoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				if (!isset($this->lastC024tRecursoRelatedByCoUsuarioUpdatedCriteria) || !$this->lastC024tRecursoRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$count = C024tRecursoPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collC024tRecursosRelatedByCoUsuarioUpdated);
				}
			} else {
				$count = count($this->collC024tRecursosRelatedByCoUsuarioUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a C024tRecurso object to this object
	 * through the C024tRecurso foreign key attribute.
	 *
	 * @param      C024tRecurso $l C024tRecurso
	 * @return     void
	 * @throws     PropelException
	 */
	public function addC024tRecursoRelatedByCoUsuarioUpdated(C024tRecurso $l)
	{
		if ($this->collC024tRecursosRelatedByCoUsuarioUpdated === null) {
			$this->initC024tRecursosRelatedByCoUsuarioUpdated();
		}
		if (!in_array($l, $this->collC024tRecursosRelatedByCoUsuarioUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collC024tRecursosRelatedByCoUsuarioUpdated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdated($this);
		}
	}

	/**
	 * Clears out the collJ005tTransaccions collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ005tTransaccions()
	 */
	public function clearJ005tTransaccions()
	{
		$this->collJ005tTransaccions = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ005tTransaccions collection (array).
	 *
	 * By default this just sets the collJ005tTransaccions collection to an empty array (like clearcollJ005tTransaccions());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ005tTransaccions()
	{
		$this->collJ005tTransaccions = array();
	}

	/**
	 * Gets an array of J005tTransaccion objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J005tTransaccions from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J005tTransaccion[]
	 * @throws     PropelException
	 */
	public function getJ005tTransaccions($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ005tTransaccions === null) {
			if ($this->isNew()) {
			   $this->collJ005tTransaccions = array();
			} else {

				$criteria->add(J005tTransaccionPeer::CO_USUARIO, $this->co_usuario);

				J005tTransaccionPeer::addSelectColumns($criteria);
				$this->collJ005tTransaccions = J005tTransaccionPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J005tTransaccionPeer::CO_USUARIO, $this->co_usuario);

				J005tTransaccionPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ005tTransaccionCriteria) || !$this->lastJ005tTransaccionCriteria->equals($criteria)) {
					$this->collJ005tTransaccions = J005tTransaccionPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ005tTransaccionCriteria = $criteria;
		return $this->collJ005tTransaccions;
	}

	/**
	 * Returns the number of related J005tTransaccion objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J005tTransaccion objects.
	 * @throws     PropelException
	 */
	public function countJ005tTransaccions(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ005tTransaccions === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J005tTransaccionPeer::CO_USUARIO, $this->co_usuario);

				$count = J005tTransaccionPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J005tTransaccionPeer::CO_USUARIO, $this->co_usuario);

				if (!isset($this->lastJ005tTransaccionCriteria) || !$this->lastJ005tTransaccionCriteria->equals($criteria)) {
					$count = J005tTransaccionPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ005tTransaccions);
				}
			} else {
				$count = count($this->collJ005tTransaccions);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J005tTransaccion object to this object
	 * through the J005tTransaccion foreign key attribute.
	 *
	 * @param      J005tTransaccion $l J005tTransaccion
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ005tTransaccion(J005tTransaccion $l)
	{
		if ($this->collJ005tTransaccions === null) {
			$this->initJ005tTransaccions();
		}
		if (!in_array($l, $this->collJ005tTransaccions, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ005tTransaccions, $l);
			$l->setJ002tUsuario($this);
		}
	}

	/**
	 * Clears out the collJ010tEvaluacions collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ010tEvaluacions()
	 */
	public function clearJ010tEvaluacions()
	{
		$this->collJ010tEvaluacions = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ010tEvaluacions collection (array).
	 *
	 * By default this just sets the collJ010tEvaluacions collection to an empty array (like clearcollJ010tEvaluacions());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ010tEvaluacions()
	{
		$this->collJ010tEvaluacions = array();
	}

	/**
	 * Gets an array of J010tEvaluacion objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J010tEvaluacions from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J010tEvaluacion[]
	 * @throws     PropelException
	 */
	public function getJ010tEvaluacions($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ010tEvaluacions === null) {
			if ($this->isNew()) {
			   $this->collJ010tEvaluacions = array();
			} else {

				$criteria->add(J010tEvaluacionPeer::CO_USUARIO, $this->co_usuario);

				J010tEvaluacionPeer::addSelectColumns($criteria);
				$this->collJ010tEvaluacions = J010tEvaluacionPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J010tEvaluacionPeer::CO_USUARIO, $this->co_usuario);

				J010tEvaluacionPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ010tEvaluacionCriteria) || !$this->lastJ010tEvaluacionCriteria->equals($criteria)) {
					$this->collJ010tEvaluacions = J010tEvaluacionPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ010tEvaluacionCriteria = $criteria;
		return $this->collJ010tEvaluacions;
	}

	/**
	 * Returns the number of related J010tEvaluacion objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J010tEvaluacion objects.
	 * @throws     PropelException
	 */
	public function countJ010tEvaluacions(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ010tEvaluacions === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J010tEvaluacionPeer::CO_USUARIO, $this->co_usuario);

				$count = J010tEvaluacionPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J010tEvaluacionPeer::CO_USUARIO, $this->co_usuario);

				if (!isset($this->lastJ010tEvaluacionCriteria) || !$this->lastJ010tEvaluacionCriteria->equals($criteria)) {
					$count = J010tEvaluacionPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ010tEvaluacions);
				}
			} else {
				$count = count($this->collJ010tEvaluacions);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J010tEvaluacion object to this object
	 * through the J010tEvaluacion foreign key attribute.
	 *
	 * @param      J010tEvaluacion $l J010tEvaluacion
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ010tEvaluacion(J010tEvaluacion $l)
	{
		if ($this->collJ010tEvaluacions === null) {
			$this->initJ010tEvaluacions();
		}
		if (!in_array($l, $this->collJ010tEvaluacions, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ010tEvaluacions, $l);
			$l->setJ002tUsuario($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J010tEvaluacions from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ010tEvaluacionsJoinJ005tTransaccion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ010tEvaluacions === null) {
			if ($this->isNew()) {
				$this->collJ010tEvaluacions = array();
			} else {

				$criteria->add(J010tEvaluacionPeer::CO_USUARIO, $this->co_usuario);

				$this->collJ010tEvaluacions = J010tEvaluacionPeer::doSelectJoinJ005tTransaccion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J010tEvaluacionPeer::CO_USUARIO, $this->co_usuario);

			if (!isset($this->lastJ010tEvaluacionCriteria) || !$this->lastJ010tEvaluacionCriteria->equals($criteria)) {
				$this->collJ010tEvaluacions = J010tEvaluacionPeer::doSelectJoinJ005tTransaccion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ010tEvaluacionCriteria = $criteria;

		return $this->collJ010tEvaluacions;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J010tEvaluacions from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ010tEvaluacionsJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ010tEvaluacions === null) {
			if ($this->isNew()) {
				$this->collJ010tEvaluacions = array();
			} else {

				$criteria->add(J010tEvaluacionPeer::CO_USUARIO, $this->co_usuario);

				$this->collJ010tEvaluacions = J010tEvaluacionPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J010tEvaluacionPeer::CO_USUARIO, $this->co_usuario);

			if (!isset($this->lastJ010tEvaluacionCriteria) || !$this->lastJ010tEvaluacionCriteria->equals($criteria)) {
				$this->collJ010tEvaluacions = J010tEvaluacionPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ010tEvaluacionCriteria = $criteria;

		return $this->collJ010tEvaluacions;
	}

	/**
	 * Clears out the collJ012tCronogramas collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ012tCronogramas()
	 */
	public function clearJ012tCronogramas()
	{
		$this->collJ012tCronogramas = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ012tCronogramas collection (array).
	 *
	 * By default this just sets the collJ012tCronogramas collection to an empty array (like clearcollJ012tCronogramas());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ012tCronogramas()
	{
		$this->collJ012tCronogramas = array();
	}

	/**
	 * Gets an array of J012tCronograma objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J012tCronogramas from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J012tCronograma[]
	 * @throws     PropelException
	 */
	public function getJ012tCronogramas($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ012tCronogramas === null) {
			if ($this->isNew()) {
			   $this->collJ012tCronogramas = array();
			} else {

				$criteria->add(J012tCronogramaPeer::CO_USUARIO, $this->co_usuario);

				J012tCronogramaPeer::addSelectColumns($criteria);
				$this->collJ012tCronogramas = J012tCronogramaPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J012tCronogramaPeer::CO_USUARIO, $this->co_usuario);

				J012tCronogramaPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ012tCronogramaCriteria) || !$this->lastJ012tCronogramaCriteria->equals($criteria)) {
					$this->collJ012tCronogramas = J012tCronogramaPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ012tCronogramaCriteria = $criteria;
		return $this->collJ012tCronogramas;
	}

	/**
	 * Returns the number of related J012tCronograma objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J012tCronograma objects.
	 * @throws     PropelException
	 */
	public function countJ012tCronogramas(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ012tCronogramas === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J012tCronogramaPeer::CO_USUARIO, $this->co_usuario);

				$count = J012tCronogramaPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J012tCronogramaPeer::CO_USUARIO, $this->co_usuario);

				if (!isset($this->lastJ012tCronogramaCriteria) || !$this->lastJ012tCronogramaCriteria->equals($criteria)) {
					$count = J012tCronogramaPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ012tCronogramas);
				}
			} else {
				$count = count($this->collJ012tCronogramas);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J012tCronograma object to this object
	 * through the J012tCronograma foreign key attribute.
	 *
	 * @param      J012tCronograma $l J012tCronograma
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ012tCronograma(J012tCronograma $l)
	{
		if ($this->collJ012tCronogramas === null) {
			$this->initJ012tCronogramas();
		}
		if (!in_array($l, $this->collJ012tCronogramas, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ012tCronogramas, $l);
			$l->setJ002tUsuario($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J012tCronogramas from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ012tCronogramasJoinJ005tTransaccionRelatedByCoTransaccionEnlace($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ012tCronogramas === null) {
			if ($this->isNew()) {
				$this->collJ012tCronogramas = array();
			} else {

				$criteria->add(J012tCronogramaPeer::CO_USUARIO, $this->co_usuario);

				$this->collJ012tCronogramas = J012tCronogramaPeer::doSelectJoinJ005tTransaccionRelatedByCoTransaccionEnlace($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J012tCronogramaPeer::CO_USUARIO, $this->co_usuario);

			if (!isset($this->lastJ012tCronogramaCriteria) || !$this->lastJ012tCronogramaCriteria->equals($criteria)) {
				$this->collJ012tCronogramas = J012tCronogramaPeer::doSelectJoinJ005tTransaccionRelatedByCoTransaccionEnlace($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ012tCronogramaCriteria = $criteria;

		return $this->collJ012tCronogramas;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J012tCronogramas from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ012tCronogramasJoinJ005tTransaccionRelatedByCoTransaccion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ012tCronogramas === null) {
			if ($this->isNew()) {
				$this->collJ012tCronogramas = array();
			} else {

				$criteria->add(J012tCronogramaPeer::CO_USUARIO, $this->co_usuario);

				$this->collJ012tCronogramas = J012tCronogramaPeer::doSelectJoinJ005tTransaccionRelatedByCoTransaccion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J012tCronogramaPeer::CO_USUARIO, $this->co_usuario);

			if (!isset($this->lastJ012tCronogramaCriteria) || !$this->lastJ012tCronogramaCriteria->equals($criteria)) {
				$this->collJ012tCronogramas = J012tCronogramaPeer::doSelectJoinJ005tTransaccionRelatedByCoTransaccion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ012tCronogramaCriteria = $criteria;

		return $this->collJ012tCronogramas;
	}

	/**
	 * Clears out the collJ016tForensesRelatedByCoUsuarioApertura collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ016tForensesRelatedByCoUsuarioApertura()
	 */
	public function clearJ016tForensesRelatedByCoUsuarioApertura()
	{
		$this->collJ016tForensesRelatedByCoUsuarioApertura = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ016tForensesRelatedByCoUsuarioApertura collection (array).
	 *
	 * By default this just sets the collJ016tForensesRelatedByCoUsuarioApertura collection to an empty array (like clearcollJ016tForensesRelatedByCoUsuarioApertura());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ016tForensesRelatedByCoUsuarioApertura()
	{
		$this->collJ016tForensesRelatedByCoUsuarioApertura = array();
	}

	/**
	 * Gets an array of J016tForense objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J016tForensesRelatedByCoUsuarioApertura from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J016tForense[]
	 * @throws     PropelException
	 */
	public function getJ016tForensesRelatedByCoUsuarioApertura($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ016tForensesRelatedByCoUsuarioApertura === null) {
			if ($this->isNew()) {
			   $this->collJ016tForensesRelatedByCoUsuarioApertura = array();
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				J016tForensePeer::addSelectColumns($criteria);
				$this->collJ016tForensesRelatedByCoUsuarioApertura = J016tForensePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J016tForensePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				J016tForensePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria->equals($criteria)) {
					$this->collJ016tForensesRelatedByCoUsuarioApertura = J016tForensePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria = $criteria;
		return $this->collJ016tForensesRelatedByCoUsuarioApertura;
	}

	/**
	 * Returns the number of related J016tForense objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J016tForense objects.
	 * @throws     PropelException
	 */
	public function countJ016tForensesRelatedByCoUsuarioApertura(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ016tForensesRelatedByCoUsuarioApertura === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				$count = J016tForensePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J016tForensePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				if (!isset($this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria->equals($criteria)) {
					$count = J016tForensePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ016tForensesRelatedByCoUsuarioApertura);
				}
			} else {
				$count = count($this->collJ016tForensesRelatedByCoUsuarioApertura);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J016tForense object to this object
	 * through the J016tForense foreign key attribute.
	 *
	 * @param      J016tForense $l J016tForense
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ016tForenseRelatedByCoUsuarioApertura(J016tForense $l)
	{
		if ($this->collJ016tForensesRelatedByCoUsuarioApertura === null) {
			$this->initJ016tForensesRelatedByCoUsuarioApertura();
		}
		if (!in_array($l, $this->collJ016tForensesRelatedByCoUsuarioApertura, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ016tForensesRelatedByCoUsuarioApertura, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioApertura($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J016tForensesRelatedByCoUsuarioApertura from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ016tForensesRelatedByCoUsuarioAperturaJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ016tForensesRelatedByCoUsuarioApertura === null) {
			if ($this->isNew()) {
				$this->collJ016tForensesRelatedByCoUsuarioApertura = array();
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				$this->collJ016tForensesRelatedByCoUsuarioApertura = J016tForensePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J016tForensePeer::CO_USUARIO_APERTURA, $this->co_usuario);

			if (!isset($this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria->equals($criteria)) {
				$this->collJ016tForensesRelatedByCoUsuarioApertura = J016tForensePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria = $criteria;

		return $this->collJ016tForensesRelatedByCoUsuarioApertura;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J016tForensesRelatedByCoUsuarioApertura from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ016tForensesRelatedByCoUsuarioAperturaJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ016tForensesRelatedByCoUsuarioApertura === null) {
			if ($this->isNew()) {
				$this->collJ016tForensesRelatedByCoUsuarioApertura = array();
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				$this->collJ016tForensesRelatedByCoUsuarioApertura = J016tForensePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J016tForensePeer::CO_USUARIO_APERTURA, $this->co_usuario);

			if (!isset($this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria->equals($criteria)) {
				$this->collJ016tForensesRelatedByCoUsuarioApertura = J016tForensePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria = $criteria;

		return $this->collJ016tForensesRelatedByCoUsuarioApertura;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J016tForensesRelatedByCoUsuarioApertura from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ016tForensesRelatedByCoUsuarioAperturaJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ016tForensesRelatedByCoUsuarioApertura === null) {
			if ($this->isNew()) {
				$this->collJ016tForensesRelatedByCoUsuarioApertura = array();
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				$this->collJ016tForensesRelatedByCoUsuarioApertura = J016tForensePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J016tForensePeer::CO_USUARIO_APERTURA, $this->co_usuario);

			if (!isset($this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria->equals($criteria)) {
				$this->collJ016tForensesRelatedByCoUsuarioApertura = J016tForensePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria = $criteria;

		return $this->collJ016tForensesRelatedByCoUsuarioApertura;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J016tForensesRelatedByCoUsuarioApertura from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ016tForensesRelatedByCoUsuarioAperturaJoinJ017tAlcanceForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ016tForensesRelatedByCoUsuarioApertura === null) {
			if ($this->isNew()) {
				$this->collJ016tForensesRelatedByCoUsuarioApertura = array();
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				$this->collJ016tForensesRelatedByCoUsuarioApertura = J016tForensePeer::doSelectJoinJ017tAlcanceForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J016tForensePeer::CO_USUARIO_APERTURA, $this->co_usuario);

			if (!isset($this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria->equals($criteria)) {
				$this->collJ016tForensesRelatedByCoUsuarioApertura = J016tForensePeer::doSelectJoinJ017tAlcanceForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ016tForenseRelatedByCoUsuarioAperturaCriteria = $criteria;

		return $this->collJ016tForensesRelatedByCoUsuarioApertura;
	}

	/**
	 * Clears out the collJ016tForensesRelatedByCoUsuarioCierre collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ016tForensesRelatedByCoUsuarioCierre()
	 */
	public function clearJ016tForensesRelatedByCoUsuarioCierre()
	{
		$this->collJ016tForensesRelatedByCoUsuarioCierre = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ016tForensesRelatedByCoUsuarioCierre collection (array).
	 *
	 * By default this just sets the collJ016tForensesRelatedByCoUsuarioCierre collection to an empty array (like clearcollJ016tForensesRelatedByCoUsuarioCierre());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ016tForensesRelatedByCoUsuarioCierre()
	{
		$this->collJ016tForensesRelatedByCoUsuarioCierre = array();
	}

	/**
	 * Gets an array of J016tForense objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J016tForensesRelatedByCoUsuarioCierre from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J016tForense[]
	 * @throws     PropelException
	 */
	public function getJ016tForensesRelatedByCoUsuarioCierre($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ016tForensesRelatedByCoUsuarioCierre === null) {
			if ($this->isNew()) {
			   $this->collJ016tForensesRelatedByCoUsuarioCierre = array();
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				J016tForensePeer::addSelectColumns($criteria);
				$this->collJ016tForensesRelatedByCoUsuarioCierre = J016tForensePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J016tForensePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				J016tForensePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria->equals($criteria)) {
					$this->collJ016tForensesRelatedByCoUsuarioCierre = J016tForensePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria = $criteria;
		return $this->collJ016tForensesRelatedByCoUsuarioCierre;
	}

	/**
	 * Returns the number of related J016tForense objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J016tForense objects.
	 * @throws     PropelException
	 */
	public function countJ016tForensesRelatedByCoUsuarioCierre(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ016tForensesRelatedByCoUsuarioCierre === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				$count = J016tForensePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J016tForensePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				if (!isset($this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria->equals($criteria)) {
					$count = J016tForensePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ016tForensesRelatedByCoUsuarioCierre);
				}
			} else {
				$count = count($this->collJ016tForensesRelatedByCoUsuarioCierre);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J016tForense object to this object
	 * through the J016tForense foreign key attribute.
	 *
	 * @param      J016tForense $l J016tForense
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ016tForenseRelatedByCoUsuarioCierre(J016tForense $l)
	{
		if ($this->collJ016tForensesRelatedByCoUsuarioCierre === null) {
			$this->initJ016tForensesRelatedByCoUsuarioCierre();
		}
		if (!in_array($l, $this->collJ016tForensesRelatedByCoUsuarioCierre, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ016tForensesRelatedByCoUsuarioCierre, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCierre($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J016tForensesRelatedByCoUsuarioCierre from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ016tForensesRelatedByCoUsuarioCierreJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ016tForensesRelatedByCoUsuarioCierre === null) {
			if ($this->isNew()) {
				$this->collJ016tForensesRelatedByCoUsuarioCierre = array();
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				$this->collJ016tForensesRelatedByCoUsuarioCierre = J016tForensePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J016tForensePeer::CO_USUARIO_CIERRE, $this->co_usuario);

			if (!isset($this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria->equals($criteria)) {
				$this->collJ016tForensesRelatedByCoUsuarioCierre = J016tForensePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria = $criteria;

		return $this->collJ016tForensesRelatedByCoUsuarioCierre;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J016tForensesRelatedByCoUsuarioCierre from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ016tForensesRelatedByCoUsuarioCierreJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ016tForensesRelatedByCoUsuarioCierre === null) {
			if ($this->isNew()) {
				$this->collJ016tForensesRelatedByCoUsuarioCierre = array();
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				$this->collJ016tForensesRelatedByCoUsuarioCierre = J016tForensePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J016tForensePeer::CO_USUARIO_CIERRE, $this->co_usuario);

			if (!isset($this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria->equals($criteria)) {
				$this->collJ016tForensesRelatedByCoUsuarioCierre = J016tForensePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria = $criteria;

		return $this->collJ016tForensesRelatedByCoUsuarioCierre;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J016tForensesRelatedByCoUsuarioCierre from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ016tForensesRelatedByCoUsuarioCierreJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ016tForensesRelatedByCoUsuarioCierre === null) {
			if ($this->isNew()) {
				$this->collJ016tForensesRelatedByCoUsuarioCierre = array();
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				$this->collJ016tForensesRelatedByCoUsuarioCierre = J016tForensePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J016tForensePeer::CO_USUARIO_CIERRE, $this->co_usuario);

			if (!isset($this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria->equals($criteria)) {
				$this->collJ016tForensesRelatedByCoUsuarioCierre = J016tForensePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria = $criteria;

		return $this->collJ016tForensesRelatedByCoUsuarioCierre;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J016tForensesRelatedByCoUsuarioCierre from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ016tForensesRelatedByCoUsuarioCierreJoinJ017tAlcanceForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ016tForensesRelatedByCoUsuarioCierre === null) {
			if ($this->isNew()) {
				$this->collJ016tForensesRelatedByCoUsuarioCierre = array();
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				$this->collJ016tForensesRelatedByCoUsuarioCierre = J016tForensePeer::doSelectJoinJ017tAlcanceForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J016tForensePeer::CO_USUARIO_CIERRE, $this->co_usuario);

			if (!isset($this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria->equals($criteria)) {
				$this->collJ016tForensesRelatedByCoUsuarioCierre = J016tForensePeer::doSelectJoinJ017tAlcanceForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ016tForenseRelatedByCoUsuarioCierreCriteria = $criteria;

		return $this->collJ016tForensesRelatedByCoUsuarioCierre;
	}

	/**
	 * Clears out the collJ016tForensesRelatedByCoUsuarioUpdate collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ016tForensesRelatedByCoUsuarioUpdate()
	 */
	public function clearJ016tForensesRelatedByCoUsuarioUpdate()
	{
		$this->collJ016tForensesRelatedByCoUsuarioUpdate = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ016tForensesRelatedByCoUsuarioUpdate collection (array).
	 *
	 * By default this just sets the collJ016tForensesRelatedByCoUsuarioUpdate collection to an empty array (like clearcollJ016tForensesRelatedByCoUsuarioUpdate());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ016tForensesRelatedByCoUsuarioUpdate()
	{
		$this->collJ016tForensesRelatedByCoUsuarioUpdate = array();
	}

	/**
	 * Gets an array of J016tForense objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J016tForensesRelatedByCoUsuarioUpdate from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J016tForense[]
	 * @throws     PropelException
	 */
	public function getJ016tForensesRelatedByCoUsuarioUpdate($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ016tForensesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
			   $this->collJ016tForensesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				J016tForensePeer::addSelectColumns($criteria);
				$this->collJ016tForensesRelatedByCoUsuarioUpdate = J016tForensePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J016tForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				J016tForensePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
					$this->collJ016tForensesRelatedByCoUsuarioUpdate = J016tForensePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria = $criteria;
		return $this->collJ016tForensesRelatedByCoUsuarioUpdate;
	}

	/**
	 * Returns the number of related J016tForense objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J016tForense objects.
	 * @throws     PropelException
	 */
	public function countJ016tForensesRelatedByCoUsuarioUpdate(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ016tForensesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$count = J016tForensePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J016tForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				if (!isset($this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
					$count = J016tForensePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ016tForensesRelatedByCoUsuarioUpdate);
				}
			} else {
				$count = count($this->collJ016tForensesRelatedByCoUsuarioUpdate);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J016tForense object to this object
	 * through the J016tForense foreign key attribute.
	 *
	 * @param      J016tForense $l J016tForense
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ016tForenseRelatedByCoUsuarioUpdate(J016tForense $l)
	{
		if ($this->collJ016tForensesRelatedByCoUsuarioUpdate === null) {
			$this->initJ016tForensesRelatedByCoUsuarioUpdate();
		}
		if (!in_array($l, $this->collJ016tForensesRelatedByCoUsuarioUpdate, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ016tForensesRelatedByCoUsuarioUpdate, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdate($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J016tForensesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ016tForensesRelatedByCoUsuarioUpdateJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ016tForensesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ016tForensesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ016tForensesRelatedByCoUsuarioUpdate = J016tForensePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J016tForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ016tForensesRelatedByCoUsuarioUpdate = J016tForensePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ016tForensesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J016tForensesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ016tForensesRelatedByCoUsuarioUpdateJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ016tForensesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ016tForensesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ016tForensesRelatedByCoUsuarioUpdate = J016tForensePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J016tForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ016tForensesRelatedByCoUsuarioUpdate = J016tForensePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ016tForensesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J016tForensesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ016tForensesRelatedByCoUsuarioUpdateJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ016tForensesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ016tForensesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ016tForensesRelatedByCoUsuarioUpdate = J016tForensePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J016tForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ016tForensesRelatedByCoUsuarioUpdate = J016tForensePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ016tForensesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J016tForensesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ016tForensesRelatedByCoUsuarioUpdateJoinJ017tAlcanceForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ016tForensesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ016tForensesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J016tForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ016tForensesRelatedByCoUsuarioUpdate = J016tForensePeer::doSelectJoinJ017tAlcanceForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J016tForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ016tForensesRelatedByCoUsuarioUpdate = J016tForensePeer::doSelectJoinJ017tAlcanceForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ016tForenseRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ016tForensesRelatedByCoUsuarioUpdate;
	}

	/**
	 * Clears out the collJ017tAlcanceForensesRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ017tAlcanceForensesRelatedByCoUsuarioCreated()
	 */
	public function clearJ017tAlcanceForensesRelatedByCoUsuarioCreated()
	{
		$this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ017tAlcanceForensesRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ017tAlcanceForensesRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ017tAlcanceForensesRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ017tAlcanceForensesRelatedByCoUsuarioCreated()
	{
		$this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J017tAlcanceForense objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J017tAlcanceForensesRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J017tAlcanceForense[]
	 * @throws     PropelException
	 */
	public function getJ017tAlcanceForensesRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J017tAlcanceForensePeer::CO_USUARIO_CREATED, $this->co_usuario);

				J017tAlcanceForensePeer::addSelectColumns($criteria);
				$this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated = J017tAlcanceForensePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J017tAlcanceForensePeer::CO_USUARIO_CREATED, $this->co_usuario);

				J017tAlcanceForensePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ017tAlcanceForenseRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ017tAlcanceForenseRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated = J017tAlcanceForensePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ017tAlcanceForenseRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J017tAlcanceForense objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J017tAlcanceForense objects.
	 * @throws     PropelException
	 */
	public function countJ017tAlcanceForensesRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J017tAlcanceForensePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J017tAlcanceForensePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J017tAlcanceForensePeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ017tAlcanceForenseRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ017tAlcanceForenseRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J017tAlcanceForensePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J017tAlcanceForense object to this object
	 * through the J017tAlcanceForense foreign key attribute.
	 *
	 * @param      J017tAlcanceForense $l J017tAlcanceForense
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ017tAlcanceForenseRelatedByCoUsuarioCreated(J017tAlcanceForense $l)
	{
		if ($this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated === null) {
			$this->initJ017tAlcanceForensesRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}

	/**
	 * Clears out the collJ017tAlcanceForensesRelatedByCoUsuarioUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ017tAlcanceForensesRelatedByCoUsuarioUpdated()
	 */
	public function clearJ017tAlcanceForensesRelatedByCoUsuarioUpdated()
	{
		$this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ017tAlcanceForensesRelatedByCoUsuarioUpdated collection (array).
	 *
	 * By default this just sets the collJ017tAlcanceForensesRelatedByCoUsuarioUpdated collection to an empty array (like clearcollJ017tAlcanceForensesRelatedByCoUsuarioUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ017tAlcanceForensesRelatedByCoUsuarioUpdated()
	{
		$this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated = array();
	}

	/**
	 * Gets an array of J017tAlcanceForense objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J017tAlcanceForensesRelatedByCoUsuarioUpdated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J017tAlcanceForense[]
	 * @throws     PropelException
	 */
	public function getJ017tAlcanceForensesRelatedByCoUsuarioUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
			   $this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated = array();
			} else {

				$criteria->add(J017tAlcanceForensePeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J017tAlcanceForensePeer::addSelectColumns($criteria);
				$this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated = J017tAlcanceForensePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J017tAlcanceForensePeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J017tAlcanceForensePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ017tAlcanceForenseRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ017tAlcanceForenseRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated = J017tAlcanceForensePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ017tAlcanceForenseRelatedByCoUsuarioUpdatedCriteria = $criteria;
		return $this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated;
	}

	/**
	 * Returns the number of related J017tAlcanceForense objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J017tAlcanceForense objects.
	 * @throws     PropelException
	 */
	public function countJ017tAlcanceForensesRelatedByCoUsuarioUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J017tAlcanceForensePeer::CO_USUARIO_UPDATED, $this->co_usuario);

				$count = J017tAlcanceForensePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J017tAlcanceForensePeer::CO_USUARIO_UPDATED, $this->co_usuario);

				if (!isset($this->lastJ017tAlcanceForenseRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ017tAlcanceForenseRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$count = J017tAlcanceForensePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated);
				}
			} else {
				$count = count($this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J017tAlcanceForense object to this object
	 * through the J017tAlcanceForense foreign key attribute.
	 *
	 * @param      J017tAlcanceForense $l J017tAlcanceForense
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ017tAlcanceForenseRelatedByCoUsuarioUpdated(J017tAlcanceForense $l)
	{
		if ($this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated === null) {
			$this->initJ017tAlcanceForensesRelatedByCoUsuarioUpdated();
		}
		if (!in_array($l, $this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdated($this);
		}
	}

	/**
	 * Clears out the collJ018tInformeForensesRelatedByCoRevisa collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ018tInformeForensesRelatedByCoRevisa()
	 */
	public function clearJ018tInformeForensesRelatedByCoRevisa()
	{
		$this->collJ018tInformeForensesRelatedByCoRevisa = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ018tInformeForensesRelatedByCoRevisa collection (array).
	 *
	 * By default this just sets the collJ018tInformeForensesRelatedByCoRevisa collection to an empty array (like clearcollJ018tInformeForensesRelatedByCoRevisa());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ018tInformeForensesRelatedByCoRevisa()
	{
		$this->collJ018tInformeForensesRelatedByCoRevisa = array();
	}

	/**
	 * Gets an array of J018tInformeForense objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J018tInformeForensesRelatedByCoRevisa from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J018tInformeForense[]
	 * @throws     PropelException
	 */
	public function getJ018tInformeForensesRelatedByCoRevisa($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoRevisa === null) {
			if ($this->isNew()) {
			   $this->collJ018tInformeForensesRelatedByCoRevisa = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_REVISA, $this->co_usuario);

				J018tInformeForensePeer::addSelectColumns($criteria);
				$this->collJ018tInformeForensesRelatedByCoRevisa = J018tInformeForensePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J018tInformeForensePeer::CO_REVISA, $this->co_usuario);

				J018tInformeForensePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ018tInformeForenseRelatedByCoRevisaCriteria) || !$this->lastJ018tInformeForenseRelatedByCoRevisaCriteria->equals($criteria)) {
					$this->collJ018tInformeForensesRelatedByCoRevisa = J018tInformeForensePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoRevisaCriteria = $criteria;
		return $this->collJ018tInformeForensesRelatedByCoRevisa;
	}

	/**
	 * Returns the number of related J018tInformeForense objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J018tInformeForense objects.
	 * @throws     PropelException
	 */
	public function countJ018tInformeForensesRelatedByCoRevisa(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ018tInformeForensesRelatedByCoRevisa === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J018tInformeForensePeer::CO_REVISA, $this->co_usuario);

				$count = J018tInformeForensePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J018tInformeForensePeer::CO_REVISA, $this->co_usuario);

				if (!isset($this->lastJ018tInformeForenseRelatedByCoRevisaCriteria) || !$this->lastJ018tInformeForenseRelatedByCoRevisaCriteria->equals($criteria)) {
					$count = J018tInformeForensePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ018tInformeForensesRelatedByCoRevisa);
				}
			} else {
				$count = count($this->collJ018tInformeForensesRelatedByCoRevisa);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J018tInformeForense object to this object
	 * through the J018tInformeForense foreign key attribute.
	 *
	 * @param      J018tInformeForense $l J018tInformeForense
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ018tInformeForenseRelatedByCoRevisa(J018tInformeForense $l)
	{
		if ($this->collJ018tInformeForensesRelatedByCoRevisa === null) {
			$this->initJ018tInformeForensesRelatedByCoRevisa();
		}
		if (!in_array($l, $this->collJ018tInformeForensesRelatedByCoRevisa, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ018tInformeForensesRelatedByCoRevisa, $l);
			$l->setJ002tUsuarioRelatedByCoRevisa($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J018tInformeForensesRelatedByCoRevisa from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ018tInformeForensesRelatedByCoRevisaJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoRevisa === null) {
			if ($this->isNew()) {
				$this->collJ018tInformeForensesRelatedByCoRevisa = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_REVISA, $this->co_usuario);

				$this->collJ018tInformeForensesRelatedByCoRevisa = J018tInformeForensePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J018tInformeForensePeer::CO_REVISA, $this->co_usuario);

			if (!isset($this->lastJ018tInformeForenseRelatedByCoRevisaCriteria) || !$this->lastJ018tInformeForenseRelatedByCoRevisaCriteria->equals($criteria)) {
				$this->collJ018tInformeForensesRelatedByCoRevisa = J018tInformeForensePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoRevisaCriteria = $criteria;

		return $this->collJ018tInformeForensesRelatedByCoRevisa;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J018tInformeForensesRelatedByCoRevisa from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ018tInformeForensesRelatedByCoRevisaJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoRevisa === null) {
			if ($this->isNew()) {
				$this->collJ018tInformeForensesRelatedByCoRevisa = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_REVISA, $this->co_usuario);

				$this->collJ018tInformeForensesRelatedByCoRevisa = J018tInformeForensePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J018tInformeForensePeer::CO_REVISA, $this->co_usuario);

			if (!isset($this->lastJ018tInformeForenseRelatedByCoRevisaCriteria) || !$this->lastJ018tInformeForenseRelatedByCoRevisaCriteria->equals($criteria)) {
				$this->collJ018tInformeForensesRelatedByCoRevisa = J018tInformeForensePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoRevisaCriteria = $criteria;

		return $this->collJ018tInformeForensesRelatedByCoRevisa;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J018tInformeForensesRelatedByCoRevisa from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ018tInformeForensesRelatedByCoRevisaJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoRevisa === null) {
			if ($this->isNew()) {
				$this->collJ018tInformeForensesRelatedByCoRevisa = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_REVISA, $this->co_usuario);

				$this->collJ018tInformeForensesRelatedByCoRevisa = J018tInformeForensePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J018tInformeForensePeer::CO_REVISA, $this->co_usuario);

			if (!isset($this->lastJ018tInformeForenseRelatedByCoRevisaCriteria) || !$this->lastJ018tInformeForenseRelatedByCoRevisaCriteria->equals($criteria)) {
				$this->collJ018tInformeForensesRelatedByCoRevisa = J018tInformeForensePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoRevisaCriteria = $criteria;

		return $this->collJ018tInformeForensesRelatedByCoRevisa;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J018tInformeForensesRelatedByCoRevisa from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ018tInformeForensesRelatedByCoRevisaJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoRevisa === null) {
			if ($this->isNew()) {
				$this->collJ018tInformeForensesRelatedByCoRevisa = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_REVISA, $this->co_usuario);

				$this->collJ018tInformeForensesRelatedByCoRevisa = J018tInformeForensePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J018tInformeForensePeer::CO_REVISA, $this->co_usuario);

			if (!isset($this->lastJ018tInformeForenseRelatedByCoRevisaCriteria) || !$this->lastJ018tInformeForenseRelatedByCoRevisaCriteria->equals($criteria)) {
				$this->collJ018tInformeForensesRelatedByCoRevisa = J018tInformeForensePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoRevisaCriteria = $criteria;

		return $this->collJ018tInformeForensesRelatedByCoRevisa;
	}

	/**
	 * Clears out the collJ018tInformeForensesRelatedByCoAprueba collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ018tInformeForensesRelatedByCoAprueba()
	 */
	public function clearJ018tInformeForensesRelatedByCoAprueba()
	{
		$this->collJ018tInformeForensesRelatedByCoAprueba = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ018tInformeForensesRelatedByCoAprueba collection (array).
	 *
	 * By default this just sets the collJ018tInformeForensesRelatedByCoAprueba collection to an empty array (like clearcollJ018tInformeForensesRelatedByCoAprueba());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ018tInformeForensesRelatedByCoAprueba()
	{
		$this->collJ018tInformeForensesRelatedByCoAprueba = array();
	}

	/**
	 * Gets an array of J018tInformeForense objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J018tInformeForensesRelatedByCoAprueba from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J018tInformeForense[]
	 * @throws     PropelException
	 */
	public function getJ018tInformeForensesRelatedByCoAprueba($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoAprueba === null) {
			if ($this->isNew()) {
			   $this->collJ018tInformeForensesRelatedByCoAprueba = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_APRUEBA, $this->co_usuario);

				J018tInformeForensePeer::addSelectColumns($criteria);
				$this->collJ018tInformeForensesRelatedByCoAprueba = J018tInformeForensePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J018tInformeForensePeer::CO_APRUEBA, $this->co_usuario);

				J018tInformeForensePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ018tInformeForenseRelatedByCoApruebaCriteria) || !$this->lastJ018tInformeForenseRelatedByCoApruebaCriteria->equals($criteria)) {
					$this->collJ018tInformeForensesRelatedByCoAprueba = J018tInformeForensePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoApruebaCriteria = $criteria;
		return $this->collJ018tInformeForensesRelatedByCoAprueba;
	}

	/**
	 * Returns the number of related J018tInformeForense objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J018tInformeForense objects.
	 * @throws     PropelException
	 */
	public function countJ018tInformeForensesRelatedByCoAprueba(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ018tInformeForensesRelatedByCoAprueba === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J018tInformeForensePeer::CO_APRUEBA, $this->co_usuario);

				$count = J018tInformeForensePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J018tInformeForensePeer::CO_APRUEBA, $this->co_usuario);

				if (!isset($this->lastJ018tInformeForenseRelatedByCoApruebaCriteria) || !$this->lastJ018tInformeForenseRelatedByCoApruebaCriteria->equals($criteria)) {
					$count = J018tInformeForensePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ018tInformeForensesRelatedByCoAprueba);
				}
			} else {
				$count = count($this->collJ018tInformeForensesRelatedByCoAprueba);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J018tInformeForense object to this object
	 * through the J018tInformeForense foreign key attribute.
	 *
	 * @param      J018tInformeForense $l J018tInformeForense
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ018tInformeForenseRelatedByCoAprueba(J018tInformeForense $l)
	{
		if ($this->collJ018tInformeForensesRelatedByCoAprueba === null) {
			$this->initJ018tInformeForensesRelatedByCoAprueba();
		}
		if (!in_array($l, $this->collJ018tInformeForensesRelatedByCoAprueba, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ018tInformeForensesRelatedByCoAprueba, $l);
			$l->setJ002tUsuarioRelatedByCoAprueba($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J018tInformeForensesRelatedByCoAprueba from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ018tInformeForensesRelatedByCoApruebaJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoAprueba === null) {
			if ($this->isNew()) {
				$this->collJ018tInformeForensesRelatedByCoAprueba = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_APRUEBA, $this->co_usuario);

				$this->collJ018tInformeForensesRelatedByCoAprueba = J018tInformeForensePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J018tInformeForensePeer::CO_APRUEBA, $this->co_usuario);

			if (!isset($this->lastJ018tInformeForenseRelatedByCoApruebaCriteria) || !$this->lastJ018tInformeForenseRelatedByCoApruebaCriteria->equals($criteria)) {
				$this->collJ018tInformeForensesRelatedByCoAprueba = J018tInformeForensePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoApruebaCriteria = $criteria;

		return $this->collJ018tInformeForensesRelatedByCoAprueba;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J018tInformeForensesRelatedByCoAprueba from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ018tInformeForensesRelatedByCoApruebaJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoAprueba === null) {
			if ($this->isNew()) {
				$this->collJ018tInformeForensesRelatedByCoAprueba = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_APRUEBA, $this->co_usuario);

				$this->collJ018tInformeForensesRelatedByCoAprueba = J018tInformeForensePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J018tInformeForensePeer::CO_APRUEBA, $this->co_usuario);

			if (!isset($this->lastJ018tInformeForenseRelatedByCoApruebaCriteria) || !$this->lastJ018tInformeForenseRelatedByCoApruebaCriteria->equals($criteria)) {
				$this->collJ018tInformeForensesRelatedByCoAprueba = J018tInformeForensePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoApruebaCriteria = $criteria;

		return $this->collJ018tInformeForensesRelatedByCoAprueba;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J018tInformeForensesRelatedByCoAprueba from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ018tInformeForensesRelatedByCoApruebaJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoAprueba === null) {
			if ($this->isNew()) {
				$this->collJ018tInformeForensesRelatedByCoAprueba = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_APRUEBA, $this->co_usuario);

				$this->collJ018tInformeForensesRelatedByCoAprueba = J018tInformeForensePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J018tInformeForensePeer::CO_APRUEBA, $this->co_usuario);

			if (!isset($this->lastJ018tInformeForenseRelatedByCoApruebaCriteria) || !$this->lastJ018tInformeForenseRelatedByCoApruebaCriteria->equals($criteria)) {
				$this->collJ018tInformeForensesRelatedByCoAprueba = J018tInformeForensePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoApruebaCriteria = $criteria;

		return $this->collJ018tInformeForensesRelatedByCoAprueba;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J018tInformeForensesRelatedByCoAprueba from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ018tInformeForensesRelatedByCoApruebaJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoAprueba === null) {
			if ($this->isNew()) {
				$this->collJ018tInformeForensesRelatedByCoAprueba = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_APRUEBA, $this->co_usuario);

				$this->collJ018tInformeForensesRelatedByCoAprueba = J018tInformeForensePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J018tInformeForensePeer::CO_APRUEBA, $this->co_usuario);

			if (!isset($this->lastJ018tInformeForenseRelatedByCoApruebaCriteria) || !$this->lastJ018tInformeForenseRelatedByCoApruebaCriteria->equals($criteria)) {
				$this->collJ018tInformeForensesRelatedByCoAprueba = J018tInformeForensePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoApruebaCriteria = $criteria;

		return $this->collJ018tInformeForensesRelatedByCoAprueba;
	}

	/**
	 * Clears out the collJ018tInformeForensesRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ018tInformeForensesRelatedByCoUsuarioCreated()
	 */
	public function clearJ018tInformeForensesRelatedByCoUsuarioCreated()
	{
		$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ018tInformeForensesRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ018tInformeForensesRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ018tInformeForensesRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ018tInformeForensesRelatedByCoUsuarioCreated()
	{
		$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J018tInformeForense objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J018tInformeForensesRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J018tInformeForense[]
	 * @throws     PropelException
	 */
	public function getJ018tInformeForensesRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ018tInformeForensesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_USUARIO_CREATED, $this->co_usuario);

				J018tInformeForensePeer::addSelectColumns($criteria);
				$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = J018tInformeForensePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J018tInformeForensePeer::CO_USUARIO_CREATED, $this->co_usuario);

				J018tInformeForensePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = J018tInformeForensePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ018tInformeForensesRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J018tInformeForense objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J018tInformeForense objects.
	 * @throws     PropelException
	 */
	public function countJ018tInformeForensesRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ018tInformeForensesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J018tInformeForensePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J018tInformeForensePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J018tInformeForensePeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J018tInformeForensePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ018tInformeForensesRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ018tInformeForensesRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J018tInformeForense object to this object
	 * through the J018tInformeForense foreign key attribute.
	 *
	 * @param      J018tInformeForense $l J018tInformeForense
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ018tInformeForenseRelatedByCoUsuarioCreated(J018tInformeForense $l)
	{
		if ($this->collJ018tInformeForensesRelatedByCoUsuarioCreated === null) {
			$this->initJ018tInformeForensesRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ018tInformeForensesRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ018tInformeForensesRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J018tInformeForensesRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ018tInformeForensesRelatedByCoUsuarioCreatedJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = J018tInformeForensePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J018tInformeForensePeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = J018tInformeForensePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ018tInformeForensesRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J018tInformeForensesRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ018tInformeForensesRelatedByCoUsuarioCreatedJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = J018tInformeForensePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J018tInformeForensePeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = J018tInformeForensePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ018tInformeForensesRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J018tInformeForensesRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ018tInformeForensesRelatedByCoUsuarioCreatedJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = J018tInformeForensePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J018tInformeForensePeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = J018tInformeForensePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ018tInformeForensesRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J018tInformeForensesRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ018tInformeForensesRelatedByCoUsuarioCreatedJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = J018tInformeForensePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J018tInformeForensePeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = J018tInformeForensePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ018tInformeForensesRelatedByCoUsuarioCreated;
	}

	/**
	 * Clears out the collJ018tInformeForensesRelatedByCoUsuarioUpdate collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ018tInformeForensesRelatedByCoUsuarioUpdate()
	 */
	public function clearJ018tInformeForensesRelatedByCoUsuarioUpdate()
	{
		$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ018tInformeForensesRelatedByCoUsuarioUpdate collection (array).
	 *
	 * By default this just sets the collJ018tInformeForensesRelatedByCoUsuarioUpdate collection to an empty array (like clearcollJ018tInformeForensesRelatedByCoUsuarioUpdate());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ018tInformeForensesRelatedByCoUsuarioUpdate()
	{
		$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = array();
	}

	/**
	 * Gets an array of J018tInformeForense objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J018tInformeForensesRelatedByCoUsuarioUpdate from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J018tInformeForense[]
	 * @throws     PropelException
	 */
	public function getJ018tInformeForensesRelatedByCoUsuarioUpdate($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
			   $this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				J018tInformeForensePeer::addSelectColumns($criteria);
				$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = J018tInformeForensePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J018tInformeForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				J018tInformeForensePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
					$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = J018tInformeForensePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria = $criteria;
		return $this->collJ018tInformeForensesRelatedByCoUsuarioUpdate;
	}

	/**
	 * Returns the number of related J018tInformeForense objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J018tInformeForense objects.
	 * @throws     PropelException
	 */
	public function countJ018tInformeForensesRelatedByCoUsuarioUpdate(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ018tInformeForensesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J018tInformeForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$count = J018tInformeForensePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J018tInformeForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				if (!isset($this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
					$count = J018tInformeForensePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ018tInformeForensesRelatedByCoUsuarioUpdate);
				}
			} else {
				$count = count($this->collJ018tInformeForensesRelatedByCoUsuarioUpdate);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J018tInformeForense object to this object
	 * through the J018tInformeForense foreign key attribute.
	 *
	 * @param      J018tInformeForense $l J018tInformeForense
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ018tInformeForenseRelatedByCoUsuarioUpdate(J018tInformeForense $l)
	{
		if ($this->collJ018tInformeForensesRelatedByCoUsuarioUpdate === null) {
			$this->initJ018tInformeForensesRelatedByCoUsuarioUpdate();
		}
		if (!in_array($l, $this->collJ018tInformeForensesRelatedByCoUsuarioUpdate, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ018tInformeForensesRelatedByCoUsuarioUpdate, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdate($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J018tInformeForensesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ018tInformeForensesRelatedByCoUsuarioUpdateJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = J018tInformeForensePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J018tInformeForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = J018tInformeForensePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ018tInformeForensesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J018tInformeForensesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ018tInformeForensesRelatedByCoUsuarioUpdateJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = J018tInformeForensePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J018tInformeForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = J018tInformeForensePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ018tInformeForensesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J018tInformeForensesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ018tInformeForensesRelatedByCoUsuarioUpdateJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = J018tInformeForensePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J018tInformeForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = J018tInformeForensePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ018tInformeForensesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J018tInformeForensesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ018tInformeForensesRelatedByCoUsuarioUpdateJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ018tInformeForensesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J018tInformeForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = J018tInformeForensePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J018tInformeForensePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = J018tInformeForensePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ018tInformeForenseRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ018tInformeForensesRelatedByCoUsuarioUpdate;
	}

	/**
	 * Clears out the collJ019tParticipantess collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ019tParticipantess()
	 */
	public function clearJ019tParticipantess()
	{
		$this->collJ019tParticipantess = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ019tParticipantess collection (array).
	 *
	 * By default this just sets the collJ019tParticipantess collection to an empty array (like clearcollJ019tParticipantess());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ019tParticipantess()
	{
		$this->collJ019tParticipantess = array();
	}

	/**
	 * Gets an array of J019tParticipantes objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J019tParticipantess from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J019tParticipantes[]
	 * @throws     PropelException
	 */
	public function getJ019tParticipantess($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ019tParticipantess === null) {
			if ($this->isNew()) {
			   $this->collJ019tParticipantess = array();
			} else {

				$criteria->add(J019tParticipantesPeer::CO_USUARIO_ELABORA, $this->co_usuario);

				J019tParticipantesPeer::addSelectColumns($criteria);
				$this->collJ019tParticipantess = J019tParticipantesPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J019tParticipantesPeer::CO_USUARIO_ELABORA, $this->co_usuario);

				J019tParticipantesPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ019tParticipantesCriteria) || !$this->lastJ019tParticipantesCriteria->equals($criteria)) {
					$this->collJ019tParticipantess = J019tParticipantesPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ019tParticipantesCriteria = $criteria;
		return $this->collJ019tParticipantess;
	}

	/**
	 * Returns the number of related J019tParticipantes objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J019tParticipantes objects.
	 * @throws     PropelException
	 */
	public function countJ019tParticipantess(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ019tParticipantess === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J019tParticipantesPeer::CO_USUARIO_ELABORA, $this->co_usuario);

				$count = J019tParticipantesPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J019tParticipantesPeer::CO_USUARIO_ELABORA, $this->co_usuario);

				if (!isset($this->lastJ019tParticipantesCriteria) || !$this->lastJ019tParticipantesCriteria->equals($criteria)) {
					$count = J019tParticipantesPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ019tParticipantess);
				}
			} else {
				$count = count($this->collJ019tParticipantess);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J019tParticipantes object to this object
	 * through the J019tParticipantes foreign key attribute.
	 *
	 * @param      J019tParticipantes $l J019tParticipantes
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ019tParticipantes(J019tParticipantes $l)
	{
		if ($this->collJ019tParticipantess === null) {
			$this->initJ019tParticipantess();
		}
		if (!in_array($l, $this->collJ019tParticipantess, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ019tParticipantess, $l);
			$l->setJ002tUsuario($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J019tParticipantess from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ019tParticipantessJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ019tParticipantess === null) {
			if ($this->isNew()) {
				$this->collJ019tParticipantess = array();
			} else {

				$criteria->add(J019tParticipantesPeer::CO_USUARIO_ELABORA, $this->co_usuario);

				$this->collJ019tParticipantess = J019tParticipantesPeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J019tParticipantesPeer::CO_USUARIO_ELABORA, $this->co_usuario);

			if (!isset($this->lastJ019tParticipantesCriteria) || !$this->lastJ019tParticipantesCriteria->equals($criteria)) {
				$this->collJ019tParticipantess = J019tParticipantesPeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ019tParticipantesCriteria = $criteria;

		return $this->collJ019tParticipantess;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J019tParticipantess from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ019tParticipantessJoinJ018tInformeForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ019tParticipantess === null) {
			if ($this->isNew()) {
				$this->collJ019tParticipantess = array();
			} else {

				$criteria->add(J019tParticipantesPeer::CO_USUARIO_ELABORA, $this->co_usuario);

				$this->collJ019tParticipantess = J019tParticipantesPeer::doSelectJoinJ018tInformeForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J019tParticipantesPeer::CO_USUARIO_ELABORA, $this->co_usuario);

			if (!isset($this->lastJ019tParticipantesCriteria) || !$this->lastJ019tParticipantesCriteria->equals($criteria)) {
				$this->collJ019tParticipantess = J019tParticipantesPeer::doSelectJoinJ018tInformeForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ019tParticipantesCriteria = $criteria;

		return $this->collJ019tParticipantess;
	}

	/**
	 * Clears out the collJ020tActaAccsRelatedByCoElabora collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ020tActaAccsRelatedByCoElabora()
	 */
	public function clearJ020tActaAccsRelatedByCoElabora()
	{
		$this->collJ020tActaAccsRelatedByCoElabora = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ020tActaAccsRelatedByCoElabora collection (array).
	 *
	 * By default this just sets the collJ020tActaAccsRelatedByCoElabora collection to an empty array (like clearcollJ020tActaAccsRelatedByCoElabora());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ020tActaAccsRelatedByCoElabora()
	{
		$this->collJ020tActaAccsRelatedByCoElabora = array();
	}

	/**
	 * Gets an array of J020tActaAcc objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J020tActaAccsRelatedByCoElabora from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J020tActaAcc[]
	 * @throws     PropelException
	 */
	public function getJ020tActaAccsRelatedByCoElabora($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoElabora === null) {
			if ($this->isNew()) {
			   $this->collJ020tActaAccsRelatedByCoElabora = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_ELABORA, $this->co_usuario);

				J020tActaAccPeer::addSelectColumns($criteria);
				$this->collJ020tActaAccsRelatedByCoElabora = J020tActaAccPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J020tActaAccPeer::CO_ELABORA, $this->co_usuario);

				J020tActaAccPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ020tActaAccRelatedByCoElaboraCriteria) || !$this->lastJ020tActaAccRelatedByCoElaboraCriteria->equals($criteria)) {
					$this->collJ020tActaAccsRelatedByCoElabora = J020tActaAccPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ020tActaAccRelatedByCoElaboraCriteria = $criteria;
		return $this->collJ020tActaAccsRelatedByCoElabora;
	}

	/**
	 * Returns the number of related J020tActaAcc objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J020tActaAcc objects.
	 * @throws     PropelException
	 */
	public function countJ020tActaAccsRelatedByCoElabora(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ020tActaAccsRelatedByCoElabora === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J020tActaAccPeer::CO_ELABORA, $this->co_usuario);

				$count = J020tActaAccPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J020tActaAccPeer::CO_ELABORA, $this->co_usuario);

				if (!isset($this->lastJ020tActaAccRelatedByCoElaboraCriteria) || !$this->lastJ020tActaAccRelatedByCoElaboraCriteria->equals($criteria)) {
					$count = J020tActaAccPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ020tActaAccsRelatedByCoElabora);
				}
			} else {
				$count = count($this->collJ020tActaAccsRelatedByCoElabora);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J020tActaAcc object to this object
	 * through the J020tActaAcc foreign key attribute.
	 *
	 * @param      J020tActaAcc $l J020tActaAcc
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ020tActaAccRelatedByCoElabora(J020tActaAcc $l)
	{
		if ($this->collJ020tActaAccsRelatedByCoElabora === null) {
			$this->initJ020tActaAccsRelatedByCoElabora();
		}
		if (!in_array($l, $this->collJ020tActaAccsRelatedByCoElabora, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ020tActaAccsRelatedByCoElabora, $l);
			$l->setJ002tUsuarioRelatedByCoElabora($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J020tActaAccsRelatedByCoElabora from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ020tActaAccsRelatedByCoElaboraJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoElabora === null) {
			if ($this->isNew()) {
				$this->collJ020tActaAccsRelatedByCoElabora = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_ELABORA, $this->co_usuario);

				$this->collJ020tActaAccsRelatedByCoElabora = J020tActaAccPeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J020tActaAccPeer::CO_ELABORA, $this->co_usuario);

			if (!isset($this->lastJ020tActaAccRelatedByCoElaboraCriteria) || !$this->lastJ020tActaAccRelatedByCoElaboraCriteria->equals($criteria)) {
				$this->collJ020tActaAccsRelatedByCoElabora = J020tActaAccPeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ020tActaAccRelatedByCoElaboraCriteria = $criteria;

		return $this->collJ020tActaAccsRelatedByCoElabora;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J020tActaAccsRelatedByCoElabora from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ020tActaAccsRelatedByCoElaboraJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoElabora === null) {
			if ($this->isNew()) {
				$this->collJ020tActaAccsRelatedByCoElabora = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_ELABORA, $this->co_usuario);

				$this->collJ020tActaAccsRelatedByCoElabora = J020tActaAccPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J020tActaAccPeer::CO_ELABORA, $this->co_usuario);

			if (!isset($this->lastJ020tActaAccRelatedByCoElaboraCriteria) || !$this->lastJ020tActaAccRelatedByCoElaboraCriteria->equals($criteria)) {
				$this->collJ020tActaAccsRelatedByCoElabora = J020tActaAccPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ020tActaAccRelatedByCoElaboraCriteria = $criteria;

		return $this->collJ020tActaAccsRelatedByCoElabora;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J020tActaAccsRelatedByCoElabora from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ020tActaAccsRelatedByCoElaboraJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoElabora === null) {
			if ($this->isNew()) {
				$this->collJ020tActaAccsRelatedByCoElabora = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_ELABORA, $this->co_usuario);

				$this->collJ020tActaAccsRelatedByCoElabora = J020tActaAccPeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J020tActaAccPeer::CO_ELABORA, $this->co_usuario);

			if (!isset($this->lastJ020tActaAccRelatedByCoElaboraCriteria) || !$this->lastJ020tActaAccRelatedByCoElaboraCriteria->equals($criteria)) {
				$this->collJ020tActaAccsRelatedByCoElabora = J020tActaAccPeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ020tActaAccRelatedByCoElaboraCriteria = $criteria;

		return $this->collJ020tActaAccsRelatedByCoElabora;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J020tActaAccsRelatedByCoElabora from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ020tActaAccsRelatedByCoElaboraJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoElabora === null) {
			if ($this->isNew()) {
				$this->collJ020tActaAccsRelatedByCoElabora = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_ELABORA, $this->co_usuario);

				$this->collJ020tActaAccsRelatedByCoElabora = J020tActaAccPeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J020tActaAccPeer::CO_ELABORA, $this->co_usuario);

			if (!isset($this->lastJ020tActaAccRelatedByCoElaboraCriteria) || !$this->lastJ020tActaAccRelatedByCoElaboraCriteria->equals($criteria)) {
				$this->collJ020tActaAccsRelatedByCoElabora = J020tActaAccPeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ020tActaAccRelatedByCoElaboraCriteria = $criteria;

		return $this->collJ020tActaAccsRelatedByCoElabora;
	}

	/**
	 * Clears out the collJ020tActaAccsRelatedByCoDestruye collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ020tActaAccsRelatedByCoDestruye()
	 */
	public function clearJ020tActaAccsRelatedByCoDestruye()
	{
		$this->collJ020tActaAccsRelatedByCoDestruye = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ020tActaAccsRelatedByCoDestruye collection (array).
	 *
	 * By default this just sets the collJ020tActaAccsRelatedByCoDestruye collection to an empty array (like clearcollJ020tActaAccsRelatedByCoDestruye());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ020tActaAccsRelatedByCoDestruye()
	{
		$this->collJ020tActaAccsRelatedByCoDestruye = array();
	}

	/**
	 * Gets an array of J020tActaAcc objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J020tActaAccsRelatedByCoDestruye from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J020tActaAcc[]
	 * @throws     PropelException
	 */
	public function getJ020tActaAccsRelatedByCoDestruye($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoDestruye === null) {
			if ($this->isNew()) {
			   $this->collJ020tActaAccsRelatedByCoDestruye = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_DESTRUYE, $this->co_usuario);

				J020tActaAccPeer::addSelectColumns($criteria);
				$this->collJ020tActaAccsRelatedByCoDestruye = J020tActaAccPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J020tActaAccPeer::CO_DESTRUYE, $this->co_usuario);

				J020tActaAccPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ020tActaAccRelatedByCoDestruyeCriteria) || !$this->lastJ020tActaAccRelatedByCoDestruyeCriteria->equals($criteria)) {
					$this->collJ020tActaAccsRelatedByCoDestruye = J020tActaAccPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ020tActaAccRelatedByCoDestruyeCriteria = $criteria;
		return $this->collJ020tActaAccsRelatedByCoDestruye;
	}

	/**
	 * Returns the number of related J020tActaAcc objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J020tActaAcc objects.
	 * @throws     PropelException
	 */
	public function countJ020tActaAccsRelatedByCoDestruye(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ020tActaAccsRelatedByCoDestruye === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J020tActaAccPeer::CO_DESTRUYE, $this->co_usuario);

				$count = J020tActaAccPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J020tActaAccPeer::CO_DESTRUYE, $this->co_usuario);

				if (!isset($this->lastJ020tActaAccRelatedByCoDestruyeCriteria) || !$this->lastJ020tActaAccRelatedByCoDestruyeCriteria->equals($criteria)) {
					$count = J020tActaAccPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ020tActaAccsRelatedByCoDestruye);
				}
			} else {
				$count = count($this->collJ020tActaAccsRelatedByCoDestruye);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J020tActaAcc object to this object
	 * through the J020tActaAcc foreign key attribute.
	 *
	 * @param      J020tActaAcc $l J020tActaAcc
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ020tActaAccRelatedByCoDestruye(J020tActaAcc $l)
	{
		if ($this->collJ020tActaAccsRelatedByCoDestruye === null) {
			$this->initJ020tActaAccsRelatedByCoDestruye();
		}
		if (!in_array($l, $this->collJ020tActaAccsRelatedByCoDestruye, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ020tActaAccsRelatedByCoDestruye, $l);
			$l->setJ002tUsuarioRelatedByCoDestruye($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J020tActaAccsRelatedByCoDestruye from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ020tActaAccsRelatedByCoDestruyeJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoDestruye === null) {
			if ($this->isNew()) {
				$this->collJ020tActaAccsRelatedByCoDestruye = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_DESTRUYE, $this->co_usuario);

				$this->collJ020tActaAccsRelatedByCoDestruye = J020tActaAccPeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J020tActaAccPeer::CO_DESTRUYE, $this->co_usuario);

			if (!isset($this->lastJ020tActaAccRelatedByCoDestruyeCriteria) || !$this->lastJ020tActaAccRelatedByCoDestruyeCriteria->equals($criteria)) {
				$this->collJ020tActaAccsRelatedByCoDestruye = J020tActaAccPeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ020tActaAccRelatedByCoDestruyeCriteria = $criteria;

		return $this->collJ020tActaAccsRelatedByCoDestruye;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J020tActaAccsRelatedByCoDestruye from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ020tActaAccsRelatedByCoDestruyeJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoDestruye === null) {
			if ($this->isNew()) {
				$this->collJ020tActaAccsRelatedByCoDestruye = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_DESTRUYE, $this->co_usuario);

				$this->collJ020tActaAccsRelatedByCoDestruye = J020tActaAccPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J020tActaAccPeer::CO_DESTRUYE, $this->co_usuario);

			if (!isset($this->lastJ020tActaAccRelatedByCoDestruyeCriteria) || !$this->lastJ020tActaAccRelatedByCoDestruyeCriteria->equals($criteria)) {
				$this->collJ020tActaAccsRelatedByCoDestruye = J020tActaAccPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ020tActaAccRelatedByCoDestruyeCriteria = $criteria;

		return $this->collJ020tActaAccsRelatedByCoDestruye;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J020tActaAccsRelatedByCoDestruye from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ020tActaAccsRelatedByCoDestruyeJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoDestruye === null) {
			if ($this->isNew()) {
				$this->collJ020tActaAccsRelatedByCoDestruye = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_DESTRUYE, $this->co_usuario);

				$this->collJ020tActaAccsRelatedByCoDestruye = J020tActaAccPeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J020tActaAccPeer::CO_DESTRUYE, $this->co_usuario);

			if (!isset($this->lastJ020tActaAccRelatedByCoDestruyeCriteria) || !$this->lastJ020tActaAccRelatedByCoDestruyeCriteria->equals($criteria)) {
				$this->collJ020tActaAccsRelatedByCoDestruye = J020tActaAccPeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ020tActaAccRelatedByCoDestruyeCriteria = $criteria;

		return $this->collJ020tActaAccsRelatedByCoDestruye;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J020tActaAccsRelatedByCoDestruye from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ020tActaAccsRelatedByCoDestruyeJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoDestruye === null) {
			if ($this->isNew()) {
				$this->collJ020tActaAccsRelatedByCoDestruye = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_DESTRUYE, $this->co_usuario);

				$this->collJ020tActaAccsRelatedByCoDestruye = J020tActaAccPeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J020tActaAccPeer::CO_DESTRUYE, $this->co_usuario);

			if (!isset($this->lastJ020tActaAccRelatedByCoDestruyeCriteria) || !$this->lastJ020tActaAccRelatedByCoDestruyeCriteria->equals($criteria)) {
				$this->collJ020tActaAccsRelatedByCoDestruye = J020tActaAccPeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ020tActaAccRelatedByCoDestruyeCriteria = $criteria;

		return $this->collJ020tActaAccsRelatedByCoDestruye;
	}

	/**
	 * Clears out the collJ020tActaAccsRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ020tActaAccsRelatedByCoUsuarioCreated()
	 */
	public function clearJ020tActaAccsRelatedByCoUsuarioCreated()
	{
		$this->collJ020tActaAccsRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ020tActaAccsRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ020tActaAccsRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ020tActaAccsRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ020tActaAccsRelatedByCoUsuarioCreated()
	{
		$this->collJ020tActaAccsRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J020tActaAcc objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J020tActaAccsRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J020tActaAcc[]
	 * @throws     PropelException
	 */
	public function getJ020tActaAccsRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ020tActaAccsRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J020tActaAccPeer::addSelectColumns($criteria);
				$this->collJ020tActaAccsRelatedByCoUsuarioCreated = J020tActaAccPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J020tActaAccPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J020tActaAccPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ020tActaAccsRelatedByCoUsuarioCreated = J020tActaAccPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ020tActaAccsRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J020tActaAcc objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J020tActaAcc objects.
	 * @throws     PropelException
	 */
	public function countJ020tActaAccsRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ020tActaAccsRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J020tActaAccPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J020tActaAccPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J020tActaAccPeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J020tActaAccPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ020tActaAccsRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ020tActaAccsRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J020tActaAcc object to this object
	 * through the J020tActaAcc foreign key attribute.
	 *
	 * @param      J020tActaAcc $l J020tActaAcc
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ020tActaAccRelatedByCoUsuarioCreated(J020tActaAcc $l)
	{
		if ($this->collJ020tActaAccsRelatedByCoUsuarioCreated === null) {
			$this->initJ020tActaAccsRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ020tActaAccsRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ020tActaAccsRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J020tActaAccsRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ020tActaAccsRelatedByCoUsuarioCreatedJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ020tActaAccsRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ020tActaAccsRelatedByCoUsuarioCreated = J020tActaAccPeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J020tActaAccPeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ020tActaAccsRelatedByCoUsuarioCreated = J020tActaAccPeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ020tActaAccsRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J020tActaAccsRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ020tActaAccsRelatedByCoUsuarioCreatedJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ020tActaAccsRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ020tActaAccsRelatedByCoUsuarioCreated = J020tActaAccPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J020tActaAccPeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ020tActaAccsRelatedByCoUsuarioCreated = J020tActaAccPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ020tActaAccsRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J020tActaAccsRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ020tActaAccsRelatedByCoUsuarioCreatedJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ020tActaAccsRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ020tActaAccsRelatedByCoUsuarioCreated = J020tActaAccPeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J020tActaAccPeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ020tActaAccsRelatedByCoUsuarioCreated = J020tActaAccPeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ020tActaAccsRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J020tActaAccsRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ020tActaAccsRelatedByCoUsuarioCreatedJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ020tActaAccsRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ020tActaAccsRelatedByCoUsuarioCreated = J020tActaAccPeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J020tActaAccPeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ020tActaAccsRelatedByCoUsuarioCreated = J020tActaAccPeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ020tActaAccRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ020tActaAccsRelatedByCoUsuarioCreated;
	}

	/**
	 * Clears out the collJ020tActaAccsRelatedByCoUsuarioUpdate collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ020tActaAccsRelatedByCoUsuarioUpdate()
	 */
	public function clearJ020tActaAccsRelatedByCoUsuarioUpdate()
	{
		$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ020tActaAccsRelatedByCoUsuarioUpdate collection (array).
	 *
	 * By default this just sets the collJ020tActaAccsRelatedByCoUsuarioUpdate collection to an empty array (like clearcollJ020tActaAccsRelatedByCoUsuarioUpdate());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ020tActaAccsRelatedByCoUsuarioUpdate()
	{
		$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = array();
	}

	/**
	 * Gets an array of J020tActaAcc objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J020tActaAccsRelatedByCoUsuarioUpdate from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J020tActaAcc[]
	 * @throws     PropelException
	 */
	public function getJ020tActaAccsRelatedByCoUsuarioUpdate($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
			   $this->collJ020tActaAccsRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				J020tActaAccPeer::addSelectColumns($criteria);
				$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = J020tActaAccPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J020tActaAccPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				J020tActaAccPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
					$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = J020tActaAccPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria = $criteria;
		return $this->collJ020tActaAccsRelatedByCoUsuarioUpdate;
	}

	/**
	 * Returns the number of related J020tActaAcc objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J020tActaAcc objects.
	 * @throws     PropelException
	 */
	public function countJ020tActaAccsRelatedByCoUsuarioUpdate(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ020tActaAccsRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J020tActaAccPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$count = J020tActaAccPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J020tActaAccPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				if (!isset($this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
					$count = J020tActaAccPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ020tActaAccsRelatedByCoUsuarioUpdate);
				}
			} else {
				$count = count($this->collJ020tActaAccsRelatedByCoUsuarioUpdate);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J020tActaAcc object to this object
	 * through the J020tActaAcc foreign key attribute.
	 *
	 * @param      J020tActaAcc $l J020tActaAcc
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ020tActaAccRelatedByCoUsuarioUpdate(J020tActaAcc $l)
	{
		if ($this->collJ020tActaAccsRelatedByCoUsuarioUpdate === null) {
			$this->initJ020tActaAccsRelatedByCoUsuarioUpdate();
		}
		if (!in_array($l, $this->collJ020tActaAccsRelatedByCoUsuarioUpdate, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ020tActaAccsRelatedByCoUsuarioUpdate, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdate($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J020tActaAccsRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ020tActaAccsRelatedByCoUsuarioUpdateJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = J020tActaAccPeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J020tActaAccPeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = J020tActaAccPeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ020tActaAccsRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J020tActaAccsRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ020tActaAccsRelatedByCoUsuarioUpdateJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = J020tActaAccPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J020tActaAccPeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = J020tActaAccPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ020tActaAccsRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J020tActaAccsRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ020tActaAccsRelatedByCoUsuarioUpdateJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = J020tActaAccPeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J020tActaAccPeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = J020tActaAccPeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ020tActaAccsRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J020tActaAccsRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ020tActaAccsRelatedByCoUsuarioUpdateJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ020tActaAccsRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J020tActaAccPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = J020tActaAccPeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J020tActaAccPeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = J020tActaAccPeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ020tActaAccRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ020tActaAccsRelatedByCoUsuarioUpdate;
	}

	/**
	 * Clears out the collJ021tActaAiesRelatedByCoElabora collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ021tActaAiesRelatedByCoElabora()
	 */
	public function clearJ021tActaAiesRelatedByCoElabora()
	{
		$this->collJ021tActaAiesRelatedByCoElabora = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ021tActaAiesRelatedByCoElabora collection (array).
	 *
	 * By default this just sets the collJ021tActaAiesRelatedByCoElabora collection to an empty array (like clearcollJ021tActaAiesRelatedByCoElabora());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ021tActaAiesRelatedByCoElabora()
	{
		$this->collJ021tActaAiesRelatedByCoElabora = array();
	}

	/**
	 * Gets an array of J021tActaAie objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J021tActaAiesRelatedByCoElabora from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J021tActaAie[]
	 * @throws     PropelException
	 */
	public function getJ021tActaAiesRelatedByCoElabora($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ021tActaAiesRelatedByCoElabora === null) {
			if ($this->isNew()) {
			   $this->collJ021tActaAiesRelatedByCoElabora = array();
			} else {

				$criteria->add(J021tActaAiePeer::CO_ELABORA, $this->co_usuario);

				J021tActaAiePeer::addSelectColumns($criteria);
				$this->collJ021tActaAiesRelatedByCoElabora = J021tActaAiePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J021tActaAiePeer::CO_ELABORA, $this->co_usuario);

				J021tActaAiePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ021tActaAieRelatedByCoElaboraCriteria) || !$this->lastJ021tActaAieRelatedByCoElaboraCriteria->equals($criteria)) {
					$this->collJ021tActaAiesRelatedByCoElabora = J021tActaAiePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ021tActaAieRelatedByCoElaboraCriteria = $criteria;
		return $this->collJ021tActaAiesRelatedByCoElabora;
	}

	/**
	 * Returns the number of related J021tActaAie objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J021tActaAie objects.
	 * @throws     PropelException
	 */
	public function countJ021tActaAiesRelatedByCoElabora(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ021tActaAiesRelatedByCoElabora === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J021tActaAiePeer::CO_ELABORA, $this->co_usuario);

				$count = J021tActaAiePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J021tActaAiePeer::CO_ELABORA, $this->co_usuario);

				if (!isset($this->lastJ021tActaAieRelatedByCoElaboraCriteria) || !$this->lastJ021tActaAieRelatedByCoElaboraCriteria->equals($criteria)) {
					$count = J021tActaAiePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ021tActaAiesRelatedByCoElabora);
				}
			} else {
				$count = count($this->collJ021tActaAiesRelatedByCoElabora);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J021tActaAie object to this object
	 * through the J021tActaAie foreign key attribute.
	 *
	 * @param      J021tActaAie $l J021tActaAie
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ021tActaAieRelatedByCoElabora(J021tActaAie $l)
	{
		if ($this->collJ021tActaAiesRelatedByCoElabora === null) {
			$this->initJ021tActaAiesRelatedByCoElabora();
		}
		if (!in_array($l, $this->collJ021tActaAiesRelatedByCoElabora, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ021tActaAiesRelatedByCoElabora, $l);
			$l->setJ002tUsuarioRelatedByCoElabora($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J021tActaAiesRelatedByCoElabora from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ021tActaAiesRelatedByCoElaboraJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ021tActaAiesRelatedByCoElabora === null) {
			if ($this->isNew()) {
				$this->collJ021tActaAiesRelatedByCoElabora = array();
			} else {

				$criteria->add(J021tActaAiePeer::CO_ELABORA, $this->co_usuario);

				$this->collJ021tActaAiesRelatedByCoElabora = J021tActaAiePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J021tActaAiePeer::CO_ELABORA, $this->co_usuario);

			if (!isset($this->lastJ021tActaAieRelatedByCoElaboraCriteria) || !$this->lastJ021tActaAieRelatedByCoElaboraCriteria->equals($criteria)) {
				$this->collJ021tActaAiesRelatedByCoElabora = J021tActaAiePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ021tActaAieRelatedByCoElaboraCriteria = $criteria;

		return $this->collJ021tActaAiesRelatedByCoElabora;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J021tActaAiesRelatedByCoElabora from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ021tActaAiesRelatedByCoElaboraJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ021tActaAiesRelatedByCoElabora === null) {
			if ($this->isNew()) {
				$this->collJ021tActaAiesRelatedByCoElabora = array();
			} else {

				$criteria->add(J021tActaAiePeer::CO_ELABORA, $this->co_usuario);

				$this->collJ021tActaAiesRelatedByCoElabora = J021tActaAiePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J021tActaAiePeer::CO_ELABORA, $this->co_usuario);

			if (!isset($this->lastJ021tActaAieRelatedByCoElaboraCriteria) || !$this->lastJ021tActaAieRelatedByCoElaboraCriteria->equals($criteria)) {
				$this->collJ021tActaAiesRelatedByCoElabora = J021tActaAiePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ021tActaAieRelatedByCoElaboraCriteria = $criteria;

		return $this->collJ021tActaAiesRelatedByCoElabora;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J021tActaAiesRelatedByCoElabora from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ021tActaAiesRelatedByCoElaboraJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ021tActaAiesRelatedByCoElabora === null) {
			if ($this->isNew()) {
				$this->collJ021tActaAiesRelatedByCoElabora = array();
			} else {

				$criteria->add(J021tActaAiePeer::CO_ELABORA, $this->co_usuario);

				$this->collJ021tActaAiesRelatedByCoElabora = J021tActaAiePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J021tActaAiePeer::CO_ELABORA, $this->co_usuario);

			if (!isset($this->lastJ021tActaAieRelatedByCoElaboraCriteria) || !$this->lastJ021tActaAieRelatedByCoElaboraCriteria->equals($criteria)) {
				$this->collJ021tActaAiesRelatedByCoElabora = J021tActaAiePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ021tActaAieRelatedByCoElaboraCriteria = $criteria;

		return $this->collJ021tActaAiesRelatedByCoElabora;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J021tActaAiesRelatedByCoElabora from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ021tActaAiesRelatedByCoElaboraJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ021tActaAiesRelatedByCoElabora === null) {
			if ($this->isNew()) {
				$this->collJ021tActaAiesRelatedByCoElabora = array();
			} else {

				$criteria->add(J021tActaAiePeer::CO_ELABORA, $this->co_usuario);

				$this->collJ021tActaAiesRelatedByCoElabora = J021tActaAiePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J021tActaAiePeer::CO_ELABORA, $this->co_usuario);

			if (!isset($this->lastJ021tActaAieRelatedByCoElaboraCriteria) || !$this->lastJ021tActaAieRelatedByCoElaboraCriteria->equals($criteria)) {
				$this->collJ021tActaAiesRelatedByCoElabora = J021tActaAiePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ021tActaAieRelatedByCoElaboraCriteria = $criteria;

		return $this->collJ021tActaAiesRelatedByCoElabora;
	}

	/**
	 * Clears out the collJ021tActaAiesRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ021tActaAiesRelatedByCoUsuarioCreated()
	 */
	public function clearJ021tActaAiesRelatedByCoUsuarioCreated()
	{
		$this->collJ021tActaAiesRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ021tActaAiesRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ021tActaAiesRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ021tActaAiesRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ021tActaAiesRelatedByCoUsuarioCreated()
	{
		$this->collJ021tActaAiesRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J021tActaAie objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J021tActaAiesRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J021tActaAie[]
	 * @throws     PropelException
	 */
	public function getJ021tActaAiesRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ021tActaAiesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ021tActaAiesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J021tActaAiePeer::CO_USUARIO_CREATED, $this->co_usuario);

				J021tActaAiePeer::addSelectColumns($criteria);
				$this->collJ021tActaAiesRelatedByCoUsuarioCreated = J021tActaAiePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J021tActaAiePeer::CO_USUARIO_CREATED, $this->co_usuario);

				J021tActaAiePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ021tActaAiesRelatedByCoUsuarioCreated = J021tActaAiePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ021tActaAiesRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J021tActaAie objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J021tActaAie objects.
	 * @throws     PropelException
	 */
	public function countJ021tActaAiesRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ021tActaAiesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J021tActaAiePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J021tActaAiePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J021tActaAiePeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J021tActaAiePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ021tActaAiesRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ021tActaAiesRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J021tActaAie object to this object
	 * through the J021tActaAie foreign key attribute.
	 *
	 * @param      J021tActaAie $l J021tActaAie
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ021tActaAieRelatedByCoUsuarioCreated(J021tActaAie $l)
	{
		if ($this->collJ021tActaAiesRelatedByCoUsuarioCreated === null) {
			$this->initJ021tActaAiesRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ021tActaAiesRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ021tActaAiesRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J021tActaAiesRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ021tActaAiesRelatedByCoUsuarioCreatedJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ021tActaAiesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ021tActaAiesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J021tActaAiePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ021tActaAiesRelatedByCoUsuarioCreated = J021tActaAiePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J021tActaAiePeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ021tActaAiesRelatedByCoUsuarioCreated = J021tActaAiePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ021tActaAiesRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J021tActaAiesRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ021tActaAiesRelatedByCoUsuarioCreatedJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ021tActaAiesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ021tActaAiesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J021tActaAiePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ021tActaAiesRelatedByCoUsuarioCreated = J021tActaAiePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J021tActaAiePeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ021tActaAiesRelatedByCoUsuarioCreated = J021tActaAiePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ021tActaAiesRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J021tActaAiesRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ021tActaAiesRelatedByCoUsuarioCreatedJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ021tActaAiesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ021tActaAiesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J021tActaAiePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ021tActaAiesRelatedByCoUsuarioCreated = J021tActaAiePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J021tActaAiePeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ021tActaAiesRelatedByCoUsuarioCreated = J021tActaAiePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ021tActaAiesRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J021tActaAiesRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ021tActaAiesRelatedByCoUsuarioCreatedJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ021tActaAiesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ021tActaAiesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J021tActaAiePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ021tActaAiesRelatedByCoUsuarioCreated = J021tActaAiePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J021tActaAiePeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ021tActaAiesRelatedByCoUsuarioCreated = J021tActaAiePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ021tActaAieRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ021tActaAiesRelatedByCoUsuarioCreated;
	}

	/**
	 * Clears out the collJ021tActaAiesRelatedByCoUsuarioUpdate collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ021tActaAiesRelatedByCoUsuarioUpdate()
	 */
	public function clearJ021tActaAiesRelatedByCoUsuarioUpdate()
	{
		$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ021tActaAiesRelatedByCoUsuarioUpdate collection (array).
	 *
	 * By default this just sets the collJ021tActaAiesRelatedByCoUsuarioUpdate collection to an empty array (like clearcollJ021tActaAiesRelatedByCoUsuarioUpdate());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ021tActaAiesRelatedByCoUsuarioUpdate()
	{
		$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = array();
	}

	/**
	 * Gets an array of J021tActaAie objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J021tActaAiesRelatedByCoUsuarioUpdate from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J021tActaAie[]
	 * @throws     PropelException
	 */
	public function getJ021tActaAiesRelatedByCoUsuarioUpdate($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ021tActaAiesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
			   $this->collJ021tActaAiesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J021tActaAiePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				J021tActaAiePeer::addSelectColumns($criteria);
				$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = J021tActaAiePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J021tActaAiePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				J021tActaAiePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
					$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = J021tActaAiePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria = $criteria;
		return $this->collJ021tActaAiesRelatedByCoUsuarioUpdate;
	}

	/**
	 * Returns the number of related J021tActaAie objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J021tActaAie objects.
	 * @throws     PropelException
	 */
	public function countJ021tActaAiesRelatedByCoUsuarioUpdate(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ021tActaAiesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J021tActaAiePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$count = J021tActaAiePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J021tActaAiePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				if (!isset($this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
					$count = J021tActaAiePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ021tActaAiesRelatedByCoUsuarioUpdate);
				}
			} else {
				$count = count($this->collJ021tActaAiesRelatedByCoUsuarioUpdate);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J021tActaAie object to this object
	 * through the J021tActaAie foreign key attribute.
	 *
	 * @param      J021tActaAie $l J021tActaAie
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ021tActaAieRelatedByCoUsuarioUpdate(J021tActaAie $l)
	{
		if ($this->collJ021tActaAiesRelatedByCoUsuarioUpdate === null) {
			$this->initJ021tActaAiesRelatedByCoUsuarioUpdate();
		}
		if (!in_array($l, $this->collJ021tActaAiesRelatedByCoUsuarioUpdate, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ021tActaAiesRelatedByCoUsuarioUpdate, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdate($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J021tActaAiesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ021tActaAiesRelatedByCoUsuarioUpdateJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ021tActaAiesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J021tActaAiePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = J021tActaAiePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J021tActaAiePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = J021tActaAiePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ021tActaAiesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J021tActaAiesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ021tActaAiesRelatedByCoUsuarioUpdateJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ021tActaAiesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J021tActaAiePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = J021tActaAiePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J021tActaAiePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = J021tActaAiePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ021tActaAiesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J021tActaAiesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ021tActaAiesRelatedByCoUsuarioUpdateJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ021tActaAiesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J021tActaAiePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = J021tActaAiePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J021tActaAiePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = J021tActaAiePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ021tActaAiesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J021tActaAiesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ021tActaAiesRelatedByCoUsuarioUpdateJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ021tActaAiesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J021tActaAiePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = J021tActaAiePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J021tActaAiePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = J021tActaAiePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ021tActaAieRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ021tActaAiesRelatedByCoUsuarioUpdate;
	}

	/**
	 * Clears out the collJ022tActaAniesRelatedByCoElabora collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ022tActaAniesRelatedByCoElabora()
	 */
	public function clearJ022tActaAniesRelatedByCoElabora()
	{
		$this->collJ022tActaAniesRelatedByCoElabora = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ022tActaAniesRelatedByCoElabora collection (array).
	 *
	 * By default this just sets the collJ022tActaAniesRelatedByCoElabora collection to an empty array (like clearcollJ022tActaAniesRelatedByCoElabora());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ022tActaAniesRelatedByCoElabora()
	{
		$this->collJ022tActaAniesRelatedByCoElabora = array();
	}

	/**
	 * Gets an array of J022tActaAnie objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J022tActaAniesRelatedByCoElabora from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J022tActaAnie[]
	 * @throws     PropelException
	 */
	public function getJ022tActaAniesRelatedByCoElabora($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoElabora === null) {
			if ($this->isNew()) {
			   $this->collJ022tActaAniesRelatedByCoElabora = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_ELABORA, $this->co_usuario);

				J022tActaAniePeer::addSelectColumns($criteria);
				$this->collJ022tActaAniesRelatedByCoElabora = J022tActaAniePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J022tActaAniePeer::CO_ELABORA, $this->co_usuario);

				J022tActaAniePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ022tActaAnieRelatedByCoElaboraCriteria) || !$this->lastJ022tActaAnieRelatedByCoElaboraCriteria->equals($criteria)) {
					$this->collJ022tActaAniesRelatedByCoElabora = J022tActaAniePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ022tActaAnieRelatedByCoElaboraCriteria = $criteria;
		return $this->collJ022tActaAniesRelatedByCoElabora;
	}

	/**
	 * Returns the number of related J022tActaAnie objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J022tActaAnie objects.
	 * @throws     PropelException
	 */
	public function countJ022tActaAniesRelatedByCoElabora(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ022tActaAniesRelatedByCoElabora === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J022tActaAniePeer::CO_ELABORA, $this->co_usuario);

				$count = J022tActaAniePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J022tActaAniePeer::CO_ELABORA, $this->co_usuario);

				if (!isset($this->lastJ022tActaAnieRelatedByCoElaboraCriteria) || !$this->lastJ022tActaAnieRelatedByCoElaboraCriteria->equals($criteria)) {
					$count = J022tActaAniePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ022tActaAniesRelatedByCoElabora);
				}
			} else {
				$count = count($this->collJ022tActaAniesRelatedByCoElabora);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J022tActaAnie object to this object
	 * through the J022tActaAnie foreign key attribute.
	 *
	 * @param      J022tActaAnie $l J022tActaAnie
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ022tActaAnieRelatedByCoElabora(J022tActaAnie $l)
	{
		if ($this->collJ022tActaAniesRelatedByCoElabora === null) {
			$this->initJ022tActaAniesRelatedByCoElabora();
		}
		if (!in_array($l, $this->collJ022tActaAniesRelatedByCoElabora, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ022tActaAniesRelatedByCoElabora, $l);
			$l->setJ002tUsuarioRelatedByCoElabora($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J022tActaAniesRelatedByCoElabora from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ022tActaAniesRelatedByCoElaboraJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoElabora === null) {
			if ($this->isNew()) {
				$this->collJ022tActaAniesRelatedByCoElabora = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_ELABORA, $this->co_usuario);

				$this->collJ022tActaAniesRelatedByCoElabora = J022tActaAniePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J022tActaAniePeer::CO_ELABORA, $this->co_usuario);

			if (!isset($this->lastJ022tActaAnieRelatedByCoElaboraCriteria) || !$this->lastJ022tActaAnieRelatedByCoElaboraCriteria->equals($criteria)) {
				$this->collJ022tActaAniesRelatedByCoElabora = J022tActaAniePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ022tActaAnieRelatedByCoElaboraCriteria = $criteria;

		return $this->collJ022tActaAniesRelatedByCoElabora;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J022tActaAniesRelatedByCoElabora from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ022tActaAniesRelatedByCoElaboraJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoElabora === null) {
			if ($this->isNew()) {
				$this->collJ022tActaAniesRelatedByCoElabora = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_ELABORA, $this->co_usuario);

				$this->collJ022tActaAniesRelatedByCoElabora = J022tActaAniePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J022tActaAniePeer::CO_ELABORA, $this->co_usuario);

			if (!isset($this->lastJ022tActaAnieRelatedByCoElaboraCriteria) || !$this->lastJ022tActaAnieRelatedByCoElaboraCriteria->equals($criteria)) {
				$this->collJ022tActaAniesRelatedByCoElabora = J022tActaAniePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ022tActaAnieRelatedByCoElaboraCriteria = $criteria;

		return $this->collJ022tActaAniesRelatedByCoElabora;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J022tActaAniesRelatedByCoElabora from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ022tActaAniesRelatedByCoElaboraJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoElabora === null) {
			if ($this->isNew()) {
				$this->collJ022tActaAniesRelatedByCoElabora = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_ELABORA, $this->co_usuario);

				$this->collJ022tActaAniesRelatedByCoElabora = J022tActaAniePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J022tActaAniePeer::CO_ELABORA, $this->co_usuario);

			if (!isset($this->lastJ022tActaAnieRelatedByCoElaboraCriteria) || !$this->lastJ022tActaAnieRelatedByCoElaboraCriteria->equals($criteria)) {
				$this->collJ022tActaAniesRelatedByCoElabora = J022tActaAniePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ022tActaAnieRelatedByCoElaboraCriteria = $criteria;

		return $this->collJ022tActaAniesRelatedByCoElabora;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J022tActaAniesRelatedByCoElabora from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ022tActaAniesRelatedByCoElaboraJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoElabora === null) {
			if ($this->isNew()) {
				$this->collJ022tActaAniesRelatedByCoElabora = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_ELABORA, $this->co_usuario);

				$this->collJ022tActaAniesRelatedByCoElabora = J022tActaAniePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J022tActaAniePeer::CO_ELABORA, $this->co_usuario);

			if (!isset($this->lastJ022tActaAnieRelatedByCoElaboraCriteria) || !$this->lastJ022tActaAnieRelatedByCoElaboraCriteria->equals($criteria)) {
				$this->collJ022tActaAniesRelatedByCoElabora = J022tActaAniePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ022tActaAnieRelatedByCoElaboraCriteria = $criteria;

		return $this->collJ022tActaAniesRelatedByCoElabora;
	}

	/**
	 * Clears out the collJ022tActaAniesRelatedByCoCustodioNiega collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ022tActaAniesRelatedByCoCustodioNiega()
	 */
	public function clearJ022tActaAniesRelatedByCoCustodioNiega()
	{
		$this->collJ022tActaAniesRelatedByCoCustodioNiega = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ022tActaAniesRelatedByCoCustodioNiega collection (array).
	 *
	 * By default this just sets the collJ022tActaAniesRelatedByCoCustodioNiega collection to an empty array (like clearcollJ022tActaAniesRelatedByCoCustodioNiega());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ022tActaAniesRelatedByCoCustodioNiega()
	{
		$this->collJ022tActaAniesRelatedByCoCustodioNiega = array();
	}

	/**
	 * Gets an array of J022tActaAnie objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J022tActaAniesRelatedByCoCustodioNiega from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J022tActaAnie[]
	 * @throws     PropelException
	 */
	public function getJ022tActaAniesRelatedByCoCustodioNiega($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoCustodioNiega === null) {
			if ($this->isNew()) {
			   $this->collJ022tActaAniesRelatedByCoCustodioNiega = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_CUSTODIO_NIEGA, $this->co_usuario);

				J022tActaAniePeer::addSelectColumns($criteria);
				$this->collJ022tActaAniesRelatedByCoCustodioNiega = J022tActaAniePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J022tActaAniePeer::CO_CUSTODIO_NIEGA, $this->co_usuario);

				J022tActaAniePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria) || !$this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria->equals($criteria)) {
					$this->collJ022tActaAniesRelatedByCoCustodioNiega = J022tActaAniePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria = $criteria;
		return $this->collJ022tActaAniesRelatedByCoCustodioNiega;
	}

	/**
	 * Returns the number of related J022tActaAnie objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J022tActaAnie objects.
	 * @throws     PropelException
	 */
	public function countJ022tActaAniesRelatedByCoCustodioNiega(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ022tActaAniesRelatedByCoCustodioNiega === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J022tActaAniePeer::CO_CUSTODIO_NIEGA, $this->co_usuario);

				$count = J022tActaAniePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J022tActaAniePeer::CO_CUSTODIO_NIEGA, $this->co_usuario);

				if (!isset($this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria) || !$this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria->equals($criteria)) {
					$count = J022tActaAniePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ022tActaAniesRelatedByCoCustodioNiega);
				}
			} else {
				$count = count($this->collJ022tActaAniesRelatedByCoCustodioNiega);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J022tActaAnie object to this object
	 * through the J022tActaAnie foreign key attribute.
	 *
	 * @param      J022tActaAnie $l J022tActaAnie
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ022tActaAnieRelatedByCoCustodioNiega(J022tActaAnie $l)
	{
		if ($this->collJ022tActaAniesRelatedByCoCustodioNiega === null) {
			$this->initJ022tActaAniesRelatedByCoCustodioNiega();
		}
		if (!in_array($l, $this->collJ022tActaAniesRelatedByCoCustodioNiega, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ022tActaAniesRelatedByCoCustodioNiega, $l);
			$l->setJ002tUsuarioRelatedByCoCustodioNiega($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J022tActaAniesRelatedByCoCustodioNiega from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ022tActaAniesRelatedByCoCustodioNiegaJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoCustodioNiega === null) {
			if ($this->isNew()) {
				$this->collJ022tActaAniesRelatedByCoCustodioNiega = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_CUSTODIO_NIEGA, $this->co_usuario);

				$this->collJ022tActaAniesRelatedByCoCustodioNiega = J022tActaAniePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J022tActaAniePeer::CO_CUSTODIO_NIEGA, $this->co_usuario);

			if (!isset($this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria) || !$this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria->equals($criteria)) {
				$this->collJ022tActaAniesRelatedByCoCustodioNiega = J022tActaAniePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria = $criteria;

		return $this->collJ022tActaAniesRelatedByCoCustodioNiega;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J022tActaAniesRelatedByCoCustodioNiega from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ022tActaAniesRelatedByCoCustodioNiegaJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoCustodioNiega === null) {
			if ($this->isNew()) {
				$this->collJ022tActaAniesRelatedByCoCustodioNiega = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_CUSTODIO_NIEGA, $this->co_usuario);

				$this->collJ022tActaAniesRelatedByCoCustodioNiega = J022tActaAniePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J022tActaAniePeer::CO_CUSTODIO_NIEGA, $this->co_usuario);

			if (!isset($this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria) || !$this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria->equals($criteria)) {
				$this->collJ022tActaAniesRelatedByCoCustodioNiega = J022tActaAniePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria = $criteria;

		return $this->collJ022tActaAniesRelatedByCoCustodioNiega;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J022tActaAniesRelatedByCoCustodioNiega from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ022tActaAniesRelatedByCoCustodioNiegaJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoCustodioNiega === null) {
			if ($this->isNew()) {
				$this->collJ022tActaAniesRelatedByCoCustodioNiega = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_CUSTODIO_NIEGA, $this->co_usuario);

				$this->collJ022tActaAniesRelatedByCoCustodioNiega = J022tActaAniePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J022tActaAniePeer::CO_CUSTODIO_NIEGA, $this->co_usuario);

			if (!isset($this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria) || !$this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria->equals($criteria)) {
				$this->collJ022tActaAniesRelatedByCoCustodioNiega = J022tActaAniePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria = $criteria;

		return $this->collJ022tActaAniesRelatedByCoCustodioNiega;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J022tActaAniesRelatedByCoCustodioNiega from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ022tActaAniesRelatedByCoCustodioNiegaJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoCustodioNiega === null) {
			if ($this->isNew()) {
				$this->collJ022tActaAniesRelatedByCoCustodioNiega = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_CUSTODIO_NIEGA, $this->co_usuario);

				$this->collJ022tActaAniesRelatedByCoCustodioNiega = J022tActaAniePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J022tActaAniePeer::CO_CUSTODIO_NIEGA, $this->co_usuario);

			if (!isset($this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria) || !$this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria->equals($criteria)) {
				$this->collJ022tActaAniesRelatedByCoCustodioNiega = J022tActaAniePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ022tActaAnieRelatedByCoCustodioNiegaCriteria = $criteria;

		return $this->collJ022tActaAniesRelatedByCoCustodioNiega;
	}

	/**
	 * Clears out the collJ022tActaAniesRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ022tActaAniesRelatedByCoUsuarioCreated()
	 */
	public function clearJ022tActaAniesRelatedByCoUsuarioCreated()
	{
		$this->collJ022tActaAniesRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ022tActaAniesRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ022tActaAniesRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ022tActaAniesRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ022tActaAniesRelatedByCoUsuarioCreated()
	{
		$this->collJ022tActaAniesRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J022tActaAnie objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J022tActaAniesRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J022tActaAnie[]
	 * @throws     PropelException
	 */
	public function getJ022tActaAniesRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ022tActaAniesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_USUARIO_CREATED, $this->co_usuario);

				J022tActaAniePeer::addSelectColumns($criteria);
				$this->collJ022tActaAniesRelatedByCoUsuarioCreated = J022tActaAniePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J022tActaAniePeer::CO_USUARIO_CREATED, $this->co_usuario);

				J022tActaAniePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ022tActaAniesRelatedByCoUsuarioCreated = J022tActaAniePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ022tActaAniesRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J022tActaAnie objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J022tActaAnie objects.
	 * @throws     PropelException
	 */
	public function countJ022tActaAniesRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ022tActaAniesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J022tActaAniePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J022tActaAniePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J022tActaAniePeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J022tActaAniePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ022tActaAniesRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ022tActaAniesRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J022tActaAnie object to this object
	 * through the J022tActaAnie foreign key attribute.
	 *
	 * @param      J022tActaAnie $l J022tActaAnie
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ022tActaAnieRelatedByCoUsuarioCreated(J022tActaAnie $l)
	{
		if ($this->collJ022tActaAniesRelatedByCoUsuarioCreated === null) {
			$this->initJ022tActaAniesRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ022tActaAniesRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ022tActaAniesRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J022tActaAniesRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ022tActaAniesRelatedByCoUsuarioCreatedJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ022tActaAniesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ022tActaAniesRelatedByCoUsuarioCreated = J022tActaAniePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J022tActaAniePeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ022tActaAniesRelatedByCoUsuarioCreated = J022tActaAniePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ022tActaAniesRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J022tActaAniesRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ022tActaAniesRelatedByCoUsuarioCreatedJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ022tActaAniesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ022tActaAniesRelatedByCoUsuarioCreated = J022tActaAniePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J022tActaAniePeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ022tActaAniesRelatedByCoUsuarioCreated = J022tActaAniePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ022tActaAniesRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J022tActaAniesRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ022tActaAniesRelatedByCoUsuarioCreatedJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ022tActaAniesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ022tActaAniesRelatedByCoUsuarioCreated = J022tActaAniePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J022tActaAniePeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ022tActaAniesRelatedByCoUsuarioCreated = J022tActaAniePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ022tActaAniesRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J022tActaAniesRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ022tActaAniesRelatedByCoUsuarioCreatedJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ022tActaAniesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ022tActaAniesRelatedByCoUsuarioCreated = J022tActaAniePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J022tActaAniePeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ022tActaAniesRelatedByCoUsuarioCreated = J022tActaAniePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ022tActaAnieRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ022tActaAniesRelatedByCoUsuarioCreated;
	}

	/**
	 * Clears out the collJ022tActaAniesRelatedByCoUsuarioUpdate collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ022tActaAniesRelatedByCoUsuarioUpdate()
	 */
	public function clearJ022tActaAniesRelatedByCoUsuarioUpdate()
	{
		$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ022tActaAniesRelatedByCoUsuarioUpdate collection (array).
	 *
	 * By default this just sets the collJ022tActaAniesRelatedByCoUsuarioUpdate collection to an empty array (like clearcollJ022tActaAniesRelatedByCoUsuarioUpdate());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ022tActaAniesRelatedByCoUsuarioUpdate()
	{
		$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = array();
	}

	/**
	 * Gets an array of J022tActaAnie objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J022tActaAniesRelatedByCoUsuarioUpdate from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J022tActaAnie[]
	 * @throws     PropelException
	 */
	public function getJ022tActaAniesRelatedByCoUsuarioUpdate($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
			   $this->collJ022tActaAniesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				J022tActaAniePeer::addSelectColumns($criteria);
				$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = J022tActaAniePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J022tActaAniePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				J022tActaAniePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
					$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = J022tActaAniePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria = $criteria;
		return $this->collJ022tActaAniesRelatedByCoUsuarioUpdate;
	}

	/**
	 * Returns the number of related J022tActaAnie objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J022tActaAnie objects.
	 * @throws     PropelException
	 */
	public function countJ022tActaAniesRelatedByCoUsuarioUpdate(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ022tActaAniesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J022tActaAniePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$count = J022tActaAniePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J022tActaAniePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				if (!isset($this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
					$count = J022tActaAniePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ022tActaAniesRelatedByCoUsuarioUpdate);
				}
			} else {
				$count = count($this->collJ022tActaAniesRelatedByCoUsuarioUpdate);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J022tActaAnie object to this object
	 * through the J022tActaAnie foreign key attribute.
	 *
	 * @param      J022tActaAnie $l J022tActaAnie
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ022tActaAnieRelatedByCoUsuarioUpdate(J022tActaAnie $l)
	{
		if ($this->collJ022tActaAniesRelatedByCoUsuarioUpdate === null) {
			$this->initJ022tActaAniesRelatedByCoUsuarioUpdate();
		}
		if (!in_array($l, $this->collJ022tActaAniesRelatedByCoUsuarioUpdate, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ022tActaAniesRelatedByCoUsuarioUpdate, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdate($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J022tActaAniesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ022tActaAniesRelatedByCoUsuarioUpdateJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = J022tActaAniePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J022tActaAniePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = J022tActaAniePeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ022tActaAniesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J022tActaAniesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ022tActaAniesRelatedByCoUsuarioUpdateJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = J022tActaAniePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J022tActaAniePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = J022tActaAniePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ022tActaAniesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J022tActaAniesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ022tActaAniesRelatedByCoUsuarioUpdateJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = J022tActaAniePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J022tActaAniePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = J022tActaAniePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ022tActaAniesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J022tActaAniesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ022tActaAniesRelatedByCoUsuarioUpdateJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ022tActaAniesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J022tActaAniePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = J022tActaAniePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J022tActaAniePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = J022tActaAniePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ022tActaAnieRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ022tActaAniesRelatedByCoUsuarioUpdate;
	}

	/**
	 * Clears out the collJ023tEvidenciasRelatedByCoRegistro collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ023tEvidenciasRelatedByCoRegistro()
	 */
	public function clearJ023tEvidenciasRelatedByCoRegistro()
	{
		$this->collJ023tEvidenciasRelatedByCoRegistro = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ023tEvidenciasRelatedByCoRegistro collection (array).
	 *
	 * By default this just sets the collJ023tEvidenciasRelatedByCoRegistro collection to an empty array (like clearcollJ023tEvidenciasRelatedByCoRegistro());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ023tEvidenciasRelatedByCoRegistro()
	{
		$this->collJ023tEvidenciasRelatedByCoRegistro = array();
	}

	/**
	 * Gets an array of J023tEvidencia objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J023tEvidenciasRelatedByCoRegistro from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J023tEvidencia[]
	 * @throws     PropelException
	 */
	public function getJ023tEvidenciasRelatedByCoRegistro($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoRegistro === null) {
			if ($this->isNew()) {
			   $this->collJ023tEvidenciasRelatedByCoRegistro = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_REGISTRO, $this->co_usuario);

				J023tEvidenciaPeer::addSelectColumns($criteria);
				$this->collJ023tEvidenciasRelatedByCoRegistro = J023tEvidenciaPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J023tEvidenciaPeer::CO_REGISTRO, $this->co_usuario);

				J023tEvidenciaPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ023tEvidenciaRelatedByCoRegistroCriteria) || !$this->lastJ023tEvidenciaRelatedByCoRegistroCriteria->equals($criteria)) {
					$this->collJ023tEvidenciasRelatedByCoRegistro = J023tEvidenciaPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoRegistroCriteria = $criteria;
		return $this->collJ023tEvidenciasRelatedByCoRegistro;
	}

	/**
	 * Returns the number of related J023tEvidencia objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J023tEvidencia objects.
	 * @throws     PropelException
	 */
	public function countJ023tEvidenciasRelatedByCoRegistro(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ023tEvidenciasRelatedByCoRegistro === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_REGISTRO, $this->co_usuario);

				$count = J023tEvidenciaPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J023tEvidenciaPeer::CO_REGISTRO, $this->co_usuario);

				if (!isset($this->lastJ023tEvidenciaRelatedByCoRegistroCriteria) || !$this->lastJ023tEvidenciaRelatedByCoRegistroCriteria->equals($criteria)) {
					$count = J023tEvidenciaPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ023tEvidenciasRelatedByCoRegistro);
				}
			} else {
				$count = count($this->collJ023tEvidenciasRelatedByCoRegistro);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J023tEvidencia object to this object
	 * through the J023tEvidencia foreign key attribute.
	 *
	 * @param      J023tEvidencia $l J023tEvidencia
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ023tEvidenciaRelatedByCoRegistro(J023tEvidencia $l)
	{
		if ($this->collJ023tEvidenciasRelatedByCoRegistro === null) {
			$this->initJ023tEvidenciasRelatedByCoRegistro();
		}
		if (!in_array($l, $this->collJ023tEvidenciasRelatedByCoRegistro, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ023tEvidenciasRelatedByCoRegistro, $l);
			$l->setJ002tUsuarioRelatedByCoRegistro($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoRegistro from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoRegistroJoinJ020tActaAcc($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoRegistro === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoRegistro = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_REGISTRO, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoRegistro = J023tEvidenciaPeer::doSelectJoinJ020tActaAcc($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_REGISTRO, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoRegistroCriteria) || !$this->lastJ023tEvidenciaRelatedByCoRegistroCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoRegistro = J023tEvidenciaPeer::doSelectJoinJ020tActaAcc($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoRegistroCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoRegistro;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoRegistro from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoRegistroJoinJ021tActaAie($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoRegistro === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoRegistro = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_REGISTRO, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoRegistro = J023tEvidenciaPeer::doSelectJoinJ021tActaAie($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_REGISTRO, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoRegistroCriteria) || !$this->lastJ023tEvidenciaRelatedByCoRegistroCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoRegistro = J023tEvidenciaPeer::doSelectJoinJ021tActaAie($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoRegistroCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoRegistro;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoRegistro from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoRegistroJoinJ025tTipoEvidencia($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoRegistro === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoRegistro = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_REGISTRO, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoRegistro = J023tEvidenciaPeer::doSelectJoinJ025tTipoEvidencia($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_REGISTRO, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoRegistroCriteria) || !$this->lastJ023tEvidenciaRelatedByCoRegistroCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoRegistro = J023tEvidenciaPeer::doSelectJoinJ025tTipoEvidencia($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoRegistroCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoRegistro;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoRegistro from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoRegistroJoinJ026tEstadoEvidencia($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoRegistro === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoRegistro = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_REGISTRO, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoRegistro = J023tEvidenciaPeer::doSelectJoinJ026tEstadoEvidencia($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_REGISTRO, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoRegistroCriteria) || !$this->lastJ023tEvidenciaRelatedByCoRegistroCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoRegistro = J023tEvidenciaPeer::doSelectJoinJ026tEstadoEvidencia($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoRegistroCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoRegistro;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoRegistro from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoRegistroJoinJ027tLugarSeguro($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoRegistro === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoRegistro = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_REGISTRO, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoRegistro = J023tEvidenciaPeer::doSelectJoinJ027tLugarSeguro($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_REGISTRO, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoRegistroCriteria) || !$this->lastJ023tEvidenciaRelatedByCoRegistroCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoRegistro = J023tEvidenciaPeer::doSelectJoinJ027tLugarSeguro($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoRegistroCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoRegistro;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoRegistro from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoRegistroJoinJ028tRepositorio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoRegistro === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoRegistro = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_REGISTRO, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoRegistro = J023tEvidenciaPeer::doSelectJoinJ028tRepositorio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_REGISTRO, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoRegistroCriteria) || !$this->lastJ023tEvidenciaRelatedByCoRegistroCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoRegistro = J023tEvidenciaPeer::doSelectJoinJ028tRepositorio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoRegistroCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoRegistro;
	}

	/**
	 * Clears out the collJ023tEvidenciasRelatedByCoColecta collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ023tEvidenciasRelatedByCoColecta()
	 */
	public function clearJ023tEvidenciasRelatedByCoColecta()
	{
		$this->collJ023tEvidenciasRelatedByCoColecta = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ023tEvidenciasRelatedByCoColecta collection (array).
	 *
	 * By default this just sets the collJ023tEvidenciasRelatedByCoColecta collection to an empty array (like clearcollJ023tEvidenciasRelatedByCoColecta());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ023tEvidenciasRelatedByCoColecta()
	{
		$this->collJ023tEvidenciasRelatedByCoColecta = array();
	}

	/**
	 * Gets an array of J023tEvidencia objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J023tEvidenciasRelatedByCoColecta from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J023tEvidencia[]
	 * @throws     PropelException
	 */
	public function getJ023tEvidenciasRelatedByCoColecta($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoColecta === null) {
			if ($this->isNew()) {
			   $this->collJ023tEvidenciasRelatedByCoColecta = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_COLECTA, $this->co_usuario);

				J023tEvidenciaPeer::addSelectColumns($criteria);
				$this->collJ023tEvidenciasRelatedByCoColecta = J023tEvidenciaPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J023tEvidenciaPeer::CO_COLECTA, $this->co_usuario);

				J023tEvidenciaPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ023tEvidenciaRelatedByCoColectaCriteria) || !$this->lastJ023tEvidenciaRelatedByCoColectaCriteria->equals($criteria)) {
					$this->collJ023tEvidenciasRelatedByCoColecta = J023tEvidenciaPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoColectaCriteria = $criteria;
		return $this->collJ023tEvidenciasRelatedByCoColecta;
	}

	/**
	 * Returns the number of related J023tEvidencia objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J023tEvidencia objects.
	 * @throws     PropelException
	 */
	public function countJ023tEvidenciasRelatedByCoColecta(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ023tEvidenciasRelatedByCoColecta === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_COLECTA, $this->co_usuario);

				$count = J023tEvidenciaPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J023tEvidenciaPeer::CO_COLECTA, $this->co_usuario);

				if (!isset($this->lastJ023tEvidenciaRelatedByCoColectaCriteria) || !$this->lastJ023tEvidenciaRelatedByCoColectaCriteria->equals($criteria)) {
					$count = J023tEvidenciaPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ023tEvidenciasRelatedByCoColecta);
				}
			} else {
				$count = count($this->collJ023tEvidenciasRelatedByCoColecta);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J023tEvidencia object to this object
	 * through the J023tEvidencia foreign key attribute.
	 *
	 * @param      J023tEvidencia $l J023tEvidencia
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ023tEvidenciaRelatedByCoColecta(J023tEvidencia $l)
	{
		if ($this->collJ023tEvidenciasRelatedByCoColecta === null) {
			$this->initJ023tEvidenciasRelatedByCoColecta();
		}
		if (!in_array($l, $this->collJ023tEvidenciasRelatedByCoColecta, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ023tEvidenciasRelatedByCoColecta, $l);
			$l->setJ002tUsuarioRelatedByCoColecta($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoColecta from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoColectaJoinJ020tActaAcc($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoColecta === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoColecta = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_COLECTA, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoColecta = J023tEvidenciaPeer::doSelectJoinJ020tActaAcc($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_COLECTA, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoColectaCriteria) || !$this->lastJ023tEvidenciaRelatedByCoColectaCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoColecta = J023tEvidenciaPeer::doSelectJoinJ020tActaAcc($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoColectaCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoColecta;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoColecta from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoColectaJoinJ021tActaAie($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoColecta === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoColecta = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_COLECTA, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoColecta = J023tEvidenciaPeer::doSelectJoinJ021tActaAie($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_COLECTA, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoColectaCriteria) || !$this->lastJ023tEvidenciaRelatedByCoColectaCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoColecta = J023tEvidenciaPeer::doSelectJoinJ021tActaAie($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoColectaCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoColecta;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoColecta from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoColectaJoinJ025tTipoEvidencia($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoColecta === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoColecta = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_COLECTA, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoColecta = J023tEvidenciaPeer::doSelectJoinJ025tTipoEvidencia($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_COLECTA, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoColectaCriteria) || !$this->lastJ023tEvidenciaRelatedByCoColectaCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoColecta = J023tEvidenciaPeer::doSelectJoinJ025tTipoEvidencia($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoColectaCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoColecta;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoColecta from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoColectaJoinJ026tEstadoEvidencia($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoColecta === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoColecta = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_COLECTA, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoColecta = J023tEvidenciaPeer::doSelectJoinJ026tEstadoEvidencia($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_COLECTA, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoColectaCriteria) || !$this->lastJ023tEvidenciaRelatedByCoColectaCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoColecta = J023tEvidenciaPeer::doSelectJoinJ026tEstadoEvidencia($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoColectaCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoColecta;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoColecta from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoColectaJoinJ027tLugarSeguro($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoColecta === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoColecta = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_COLECTA, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoColecta = J023tEvidenciaPeer::doSelectJoinJ027tLugarSeguro($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_COLECTA, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoColectaCriteria) || !$this->lastJ023tEvidenciaRelatedByCoColectaCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoColecta = J023tEvidenciaPeer::doSelectJoinJ027tLugarSeguro($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoColectaCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoColecta;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoColecta from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoColectaJoinJ028tRepositorio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoColecta === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoColecta = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_COLECTA, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoColecta = J023tEvidenciaPeer::doSelectJoinJ028tRepositorio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_COLECTA, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoColectaCriteria) || !$this->lastJ023tEvidenciaRelatedByCoColectaCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoColecta = J023tEvidenciaPeer::doSelectJoinJ028tRepositorio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoColectaCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoColecta;
	}

	/**
	 * Clears out the collJ023tEvidenciasRelatedByCoCustodioSti collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ023tEvidenciasRelatedByCoCustodioSti()
	 */
	public function clearJ023tEvidenciasRelatedByCoCustodioSti()
	{
		$this->collJ023tEvidenciasRelatedByCoCustodioSti = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ023tEvidenciasRelatedByCoCustodioSti collection (array).
	 *
	 * By default this just sets the collJ023tEvidenciasRelatedByCoCustodioSti collection to an empty array (like clearcollJ023tEvidenciasRelatedByCoCustodioSti());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ023tEvidenciasRelatedByCoCustodioSti()
	{
		$this->collJ023tEvidenciasRelatedByCoCustodioSti = array();
	}

	/**
	 * Gets an array of J023tEvidencia objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J023tEvidenciasRelatedByCoCustodioSti from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J023tEvidencia[]
	 * @throws     PropelException
	 */
	public function getJ023tEvidenciasRelatedByCoCustodioSti($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoCustodioSti === null) {
			if ($this->isNew()) {
			   $this->collJ023tEvidenciasRelatedByCoCustodioSti = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_CUSTODIO_STI, $this->co_usuario);

				J023tEvidenciaPeer::addSelectColumns($criteria);
				$this->collJ023tEvidenciasRelatedByCoCustodioSti = J023tEvidenciaPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J023tEvidenciaPeer::CO_CUSTODIO_STI, $this->co_usuario);

				J023tEvidenciaPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria) || !$this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria->equals($criteria)) {
					$this->collJ023tEvidenciasRelatedByCoCustodioSti = J023tEvidenciaPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria = $criteria;
		return $this->collJ023tEvidenciasRelatedByCoCustodioSti;
	}

	/**
	 * Returns the number of related J023tEvidencia objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J023tEvidencia objects.
	 * @throws     PropelException
	 */
	public function countJ023tEvidenciasRelatedByCoCustodioSti(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ023tEvidenciasRelatedByCoCustodioSti === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_CUSTODIO_STI, $this->co_usuario);

				$count = J023tEvidenciaPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J023tEvidenciaPeer::CO_CUSTODIO_STI, $this->co_usuario);

				if (!isset($this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria) || !$this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria->equals($criteria)) {
					$count = J023tEvidenciaPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ023tEvidenciasRelatedByCoCustodioSti);
				}
			} else {
				$count = count($this->collJ023tEvidenciasRelatedByCoCustodioSti);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J023tEvidencia object to this object
	 * through the J023tEvidencia foreign key attribute.
	 *
	 * @param      J023tEvidencia $l J023tEvidencia
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ023tEvidenciaRelatedByCoCustodioSti(J023tEvidencia $l)
	{
		if ($this->collJ023tEvidenciasRelatedByCoCustodioSti === null) {
			$this->initJ023tEvidenciasRelatedByCoCustodioSti();
		}
		if (!in_array($l, $this->collJ023tEvidenciasRelatedByCoCustodioSti, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ023tEvidenciasRelatedByCoCustodioSti, $l);
			$l->setJ002tUsuarioRelatedByCoCustodioSti($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoCustodioSti from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoCustodioStiJoinJ020tActaAcc($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoCustodioSti === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoCustodioSti = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_CUSTODIO_STI, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoCustodioSti = J023tEvidenciaPeer::doSelectJoinJ020tActaAcc($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_CUSTODIO_STI, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria) || !$this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoCustodioSti = J023tEvidenciaPeer::doSelectJoinJ020tActaAcc($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoCustodioSti;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoCustodioSti from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoCustodioStiJoinJ021tActaAie($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoCustodioSti === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoCustodioSti = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_CUSTODIO_STI, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoCustodioSti = J023tEvidenciaPeer::doSelectJoinJ021tActaAie($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_CUSTODIO_STI, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria) || !$this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoCustodioSti = J023tEvidenciaPeer::doSelectJoinJ021tActaAie($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoCustodioSti;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoCustodioSti from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoCustodioStiJoinJ025tTipoEvidencia($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoCustodioSti === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoCustodioSti = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_CUSTODIO_STI, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoCustodioSti = J023tEvidenciaPeer::doSelectJoinJ025tTipoEvidencia($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_CUSTODIO_STI, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria) || !$this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoCustodioSti = J023tEvidenciaPeer::doSelectJoinJ025tTipoEvidencia($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoCustodioSti;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoCustodioSti from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoCustodioStiJoinJ026tEstadoEvidencia($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoCustodioSti === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoCustodioSti = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_CUSTODIO_STI, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoCustodioSti = J023tEvidenciaPeer::doSelectJoinJ026tEstadoEvidencia($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_CUSTODIO_STI, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria) || !$this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoCustodioSti = J023tEvidenciaPeer::doSelectJoinJ026tEstadoEvidencia($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoCustodioSti;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoCustodioSti from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoCustodioStiJoinJ027tLugarSeguro($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoCustodioSti === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoCustodioSti = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_CUSTODIO_STI, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoCustodioSti = J023tEvidenciaPeer::doSelectJoinJ027tLugarSeguro($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_CUSTODIO_STI, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria) || !$this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoCustodioSti = J023tEvidenciaPeer::doSelectJoinJ027tLugarSeguro($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoCustodioSti;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoCustodioSti from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoCustodioStiJoinJ028tRepositorio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoCustodioSti === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoCustodioSti = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_CUSTODIO_STI, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoCustodioSti = J023tEvidenciaPeer::doSelectJoinJ028tRepositorio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_CUSTODIO_STI, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria) || !$this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoCustodioSti = J023tEvidenciaPeer::doSelectJoinJ028tRepositorio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoCustodioStiCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoCustodioSti;
	}

	/**
	 * Clears out the collJ023tEvidenciasRelatedByCoUpdateAt collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ023tEvidenciasRelatedByCoUpdateAt()
	 */
	public function clearJ023tEvidenciasRelatedByCoUpdateAt()
	{
		$this->collJ023tEvidenciasRelatedByCoUpdateAt = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ023tEvidenciasRelatedByCoUpdateAt collection (array).
	 *
	 * By default this just sets the collJ023tEvidenciasRelatedByCoUpdateAt collection to an empty array (like clearcollJ023tEvidenciasRelatedByCoUpdateAt());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ023tEvidenciasRelatedByCoUpdateAt()
	{
		$this->collJ023tEvidenciasRelatedByCoUpdateAt = array();
	}

	/**
	 * Gets an array of J023tEvidencia objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J023tEvidenciasRelatedByCoUpdateAt from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J023tEvidencia[]
	 * @throws     PropelException
	 */
	public function getJ023tEvidenciasRelatedByCoUpdateAt($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoUpdateAt === null) {
			if ($this->isNew()) {
			   $this->collJ023tEvidenciasRelatedByCoUpdateAt = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_UPDATE_AT, $this->co_usuario);

				J023tEvidenciaPeer::addSelectColumns($criteria);
				$this->collJ023tEvidenciasRelatedByCoUpdateAt = J023tEvidenciaPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J023tEvidenciaPeer::CO_UPDATE_AT, $this->co_usuario);

				J023tEvidenciaPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria) || !$this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria->equals($criteria)) {
					$this->collJ023tEvidenciasRelatedByCoUpdateAt = J023tEvidenciaPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria = $criteria;
		return $this->collJ023tEvidenciasRelatedByCoUpdateAt;
	}

	/**
	 * Returns the number of related J023tEvidencia objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J023tEvidencia objects.
	 * @throws     PropelException
	 */
	public function countJ023tEvidenciasRelatedByCoUpdateAt(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ023tEvidenciasRelatedByCoUpdateAt === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_UPDATE_AT, $this->co_usuario);

				$count = J023tEvidenciaPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J023tEvidenciaPeer::CO_UPDATE_AT, $this->co_usuario);

				if (!isset($this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria) || !$this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria->equals($criteria)) {
					$count = J023tEvidenciaPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ023tEvidenciasRelatedByCoUpdateAt);
				}
			} else {
				$count = count($this->collJ023tEvidenciasRelatedByCoUpdateAt);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J023tEvidencia object to this object
	 * through the J023tEvidencia foreign key attribute.
	 *
	 * @param      J023tEvidencia $l J023tEvidencia
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ023tEvidenciaRelatedByCoUpdateAt(J023tEvidencia $l)
	{
		if ($this->collJ023tEvidenciasRelatedByCoUpdateAt === null) {
			$this->initJ023tEvidenciasRelatedByCoUpdateAt();
		}
		if (!in_array($l, $this->collJ023tEvidenciasRelatedByCoUpdateAt, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ023tEvidenciasRelatedByCoUpdateAt, $l);
			$l->setJ002tUsuarioRelatedByCoUpdateAt($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoUpdateAt from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoUpdateAtJoinJ020tActaAcc($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoUpdateAt === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoUpdateAt = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_UPDATE_AT, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoUpdateAt = J023tEvidenciaPeer::doSelectJoinJ020tActaAcc($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_UPDATE_AT, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria) || !$this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoUpdateAt = J023tEvidenciaPeer::doSelectJoinJ020tActaAcc($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoUpdateAt;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoUpdateAt from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoUpdateAtJoinJ021tActaAie($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoUpdateAt === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoUpdateAt = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_UPDATE_AT, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoUpdateAt = J023tEvidenciaPeer::doSelectJoinJ021tActaAie($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_UPDATE_AT, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria) || !$this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoUpdateAt = J023tEvidenciaPeer::doSelectJoinJ021tActaAie($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoUpdateAt;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoUpdateAt from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoUpdateAtJoinJ025tTipoEvidencia($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoUpdateAt === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoUpdateAt = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_UPDATE_AT, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoUpdateAt = J023tEvidenciaPeer::doSelectJoinJ025tTipoEvidencia($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_UPDATE_AT, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria) || !$this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoUpdateAt = J023tEvidenciaPeer::doSelectJoinJ025tTipoEvidencia($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoUpdateAt;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoUpdateAt from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoUpdateAtJoinJ026tEstadoEvidencia($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoUpdateAt === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoUpdateAt = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_UPDATE_AT, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoUpdateAt = J023tEvidenciaPeer::doSelectJoinJ026tEstadoEvidencia($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_UPDATE_AT, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria) || !$this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoUpdateAt = J023tEvidenciaPeer::doSelectJoinJ026tEstadoEvidencia($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoUpdateAt;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoUpdateAt from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoUpdateAtJoinJ027tLugarSeguro($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoUpdateAt === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoUpdateAt = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_UPDATE_AT, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoUpdateAt = J023tEvidenciaPeer::doSelectJoinJ027tLugarSeguro($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_UPDATE_AT, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria) || !$this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoUpdateAt = J023tEvidenciaPeer::doSelectJoinJ027tLugarSeguro($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoUpdateAt;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J023tEvidenciasRelatedByCoUpdateAt from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ023tEvidenciasRelatedByCoUpdateAtJoinJ028tRepositorio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ023tEvidenciasRelatedByCoUpdateAt === null) {
			if ($this->isNew()) {
				$this->collJ023tEvidenciasRelatedByCoUpdateAt = array();
			} else {

				$criteria->add(J023tEvidenciaPeer::CO_UPDATE_AT, $this->co_usuario);

				$this->collJ023tEvidenciasRelatedByCoUpdateAt = J023tEvidenciaPeer::doSelectJoinJ028tRepositorio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J023tEvidenciaPeer::CO_UPDATE_AT, $this->co_usuario);

			if (!isset($this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria) || !$this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria->equals($criteria)) {
				$this->collJ023tEvidenciasRelatedByCoUpdateAt = J023tEvidenciaPeer::doSelectJoinJ028tRepositorio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ023tEvidenciaRelatedByCoUpdateAtCriteria = $criteria;

		return $this->collJ023tEvidenciasRelatedByCoUpdateAt;
	}

	/**
	 * Clears out the collJ025tTipoEvidenciasRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ025tTipoEvidenciasRelatedByCoUsuarioCreated()
	 */
	public function clearJ025tTipoEvidenciasRelatedByCoUsuarioCreated()
	{
		$this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ025tTipoEvidenciasRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ025tTipoEvidenciasRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ025tTipoEvidenciasRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ025tTipoEvidenciasRelatedByCoUsuarioCreated()
	{
		$this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J025tTipoEvidencia objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J025tTipoEvidenciasRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J025tTipoEvidencia[]
	 * @throws     PropelException
	 */
	public function getJ025tTipoEvidenciasRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J025tTipoEvidenciaPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J025tTipoEvidenciaPeer::addSelectColumns($criteria);
				$this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated = J025tTipoEvidenciaPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J025tTipoEvidenciaPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J025tTipoEvidenciaPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ025tTipoEvidenciaRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ025tTipoEvidenciaRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated = J025tTipoEvidenciaPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ025tTipoEvidenciaRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J025tTipoEvidencia objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J025tTipoEvidencia objects.
	 * @throws     PropelException
	 */
	public function countJ025tTipoEvidenciasRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J025tTipoEvidenciaPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J025tTipoEvidenciaPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J025tTipoEvidenciaPeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ025tTipoEvidenciaRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ025tTipoEvidenciaRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J025tTipoEvidenciaPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J025tTipoEvidencia object to this object
	 * through the J025tTipoEvidencia foreign key attribute.
	 *
	 * @param      J025tTipoEvidencia $l J025tTipoEvidencia
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ025tTipoEvidenciaRelatedByCoUsuarioCreated(J025tTipoEvidencia $l)
	{
		if ($this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated === null) {
			$this->initJ025tTipoEvidenciasRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}

	/**
	 * Clears out the collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ025tTipoEvidenciasRelatedByCoUsuarioUpdated()
	 */
	public function clearJ025tTipoEvidenciasRelatedByCoUsuarioUpdated()
	{
		$this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated collection (array).
	 *
	 * By default this just sets the collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated collection to an empty array (like clearcollJ025tTipoEvidenciasRelatedByCoUsuarioUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ025tTipoEvidenciasRelatedByCoUsuarioUpdated()
	{
		$this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated = array();
	}

	/**
	 * Gets an array of J025tTipoEvidencia objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J025tTipoEvidenciasRelatedByCoUsuarioUpdated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J025tTipoEvidencia[]
	 * @throws     PropelException
	 */
	public function getJ025tTipoEvidenciasRelatedByCoUsuarioUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
			   $this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated = array();
			} else {

				$criteria->add(J025tTipoEvidenciaPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J025tTipoEvidenciaPeer::addSelectColumns($criteria);
				$this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated = J025tTipoEvidenciaPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J025tTipoEvidenciaPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J025tTipoEvidenciaPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ025tTipoEvidenciaRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ025tTipoEvidenciaRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated = J025tTipoEvidenciaPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ025tTipoEvidenciaRelatedByCoUsuarioUpdatedCriteria = $criteria;
		return $this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated;
	}

	/**
	 * Returns the number of related J025tTipoEvidencia objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J025tTipoEvidencia objects.
	 * @throws     PropelException
	 */
	public function countJ025tTipoEvidenciasRelatedByCoUsuarioUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J025tTipoEvidenciaPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				$count = J025tTipoEvidenciaPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J025tTipoEvidenciaPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				if (!isset($this->lastJ025tTipoEvidenciaRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ025tTipoEvidenciaRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$count = J025tTipoEvidenciaPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated);
				}
			} else {
				$count = count($this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J025tTipoEvidencia object to this object
	 * through the J025tTipoEvidencia foreign key attribute.
	 *
	 * @param      J025tTipoEvidencia $l J025tTipoEvidencia
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ025tTipoEvidenciaRelatedByCoUsuarioUpdated(J025tTipoEvidencia $l)
	{
		if ($this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated === null) {
			$this->initJ025tTipoEvidenciasRelatedByCoUsuarioUpdated();
		}
		if (!in_array($l, $this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdated($this);
		}
	}

	/**
	 * Clears out the collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ026tEstadoEvidenciasRelatedByCoUsuarioCreated()
	 */
	public function clearJ026tEstadoEvidenciasRelatedByCoUsuarioCreated()
	{
		$this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ026tEstadoEvidenciasRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ026tEstadoEvidenciasRelatedByCoUsuarioCreated()
	{
		$this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J026tEstadoEvidencia objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J026tEstadoEvidenciasRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J026tEstadoEvidencia[]
	 * @throws     PropelException
	 */
	public function getJ026tEstadoEvidenciasRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J026tEstadoEvidenciaPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J026tEstadoEvidenciaPeer::addSelectColumns($criteria);
				$this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated = J026tEstadoEvidenciaPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J026tEstadoEvidenciaPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J026tEstadoEvidenciaPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ026tEstadoEvidenciaRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ026tEstadoEvidenciaRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated = J026tEstadoEvidenciaPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ026tEstadoEvidenciaRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J026tEstadoEvidencia objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J026tEstadoEvidencia objects.
	 * @throws     PropelException
	 */
	public function countJ026tEstadoEvidenciasRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J026tEstadoEvidenciaPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J026tEstadoEvidenciaPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J026tEstadoEvidenciaPeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ026tEstadoEvidenciaRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ026tEstadoEvidenciaRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J026tEstadoEvidenciaPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J026tEstadoEvidencia object to this object
	 * through the J026tEstadoEvidencia foreign key attribute.
	 *
	 * @param      J026tEstadoEvidencia $l J026tEstadoEvidencia
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ026tEstadoEvidenciaRelatedByCoUsuarioCreated(J026tEstadoEvidencia $l)
	{
		if ($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated === null) {
			$this->initJ026tEstadoEvidenciasRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}

	/**
	 * Clears out the collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated()
	 */
	public function clearJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated()
	{
		$this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated collection (array).
	 *
	 * By default this just sets the collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated collection to an empty array (like clearcollJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated()
	{
		$this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated = array();
	}

	/**
	 * Gets an array of J026tEstadoEvidencia objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J026tEstadoEvidenciasRelatedByCoUsuarioUpdated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J026tEstadoEvidencia[]
	 * @throws     PropelException
	 */
	public function getJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
			   $this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated = array();
			} else {

				$criteria->add(J026tEstadoEvidenciaPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J026tEstadoEvidenciaPeer::addSelectColumns($criteria);
				$this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated = J026tEstadoEvidenciaPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J026tEstadoEvidenciaPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J026tEstadoEvidenciaPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ026tEstadoEvidenciaRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ026tEstadoEvidenciaRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated = J026tEstadoEvidenciaPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ026tEstadoEvidenciaRelatedByCoUsuarioUpdatedCriteria = $criteria;
		return $this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated;
	}

	/**
	 * Returns the number of related J026tEstadoEvidencia objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J026tEstadoEvidencia objects.
	 * @throws     PropelException
	 */
	public function countJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J026tEstadoEvidenciaPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				$count = J026tEstadoEvidenciaPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J026tEstadoEvidenciaPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				if (!isset($this->lastJ026tEstadoEvidenciaRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ026tEstadoEvidenciaRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$count = J026tEstadoEvidenciaPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated);
				}
			} else {
				$count = count($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J026tEstadoEvidencia object to this object
	 * through the J026tEstadoEvidencia foreign key attribute.
	 *
	 * @param      J026tEstadoEvidencia $l J026tEstadoEvidencia
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ026tEstadoEvidenciaRelatedByCoUsuarioUpdated(J026tEstadoEvidencia $l)
	{
		if ($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated === null) {
			$this->initJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated();
		}
		if (!in_array($l, $this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdated($this);
		}
	}

	/**
	 * Clears out the collJ027tLugarSegurosRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ027tLugarSegurosRelatedByCoUsuarioCreated()
	 */
	public function clearJ027tLugarSegurosRelatedByCoUsuarioCreated()
	{
		$this->collJ027tLugarSegurosRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ027tLugarSegurosRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ027tLugarSegurosRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ027tLugarSegurosRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ027tLugarSegurosRelatedByCoUsuarioCreated()
	{
		$this->collJ027tLugarSegurosRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J027tLugarSeguro objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J027tLugarSegurosRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J027tLugarSeguro[]
	 * @throws     PropelException
	 */
	public function getJ027tLugarSegurosRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ027tLugarSegurosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ027tLugarSegurosRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J027tLugarSeguroPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J027tLugarSeguroPeer::addSelectColumns($criteria);
				$this->collJ027tLugarSegurosRelatedByCoUsuarioCreated = J027tLugarSeguroPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J027tLugarSeguroPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J027tLugarSeguroPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ027tLugarSeguroRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ027tLugarSeguroRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ027tLugarSegurosRelatedByCoUsuarioCreated = J027tLugarSeguroPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ027tLugarSeguroRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ027tLugarSegurosRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J027tLugarSeguro objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J027tLugarSeguro objects.
	 * @throws     PropelException
	 */
	public function countJ027tLugarSegurosRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ027tLugarSegurosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J027tLugarSeguroPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J027tLugarSeguroPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J027tLugarSeguroPeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ027tLugarSeguroRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ027tLugarSeguroRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J027tLugarSeguroPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ027tLugarSegurosRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ027tLugarSegurosRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J027tLugarSeguro object to this object
	 * through the J027tLugarSeguro foreign key attribute.
	 *
	 * @param      J027tLugarSeguro $l J027tLugarSeguro
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ027tLugarSeguroRelatedByCoUsuarioCreated(J027tLugarSeguro $l)
	{
		if ($this->collJ027tLugarSegurosRelatedByCoUsuarioCreated === null) {
			$this->initJ027tLugarSegurosRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ027tLugarSegurosRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ027tLugarSegurosRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}

	/**
	 * Clears out the collJ027tLugarSegurosRelatedByCoUsuarioUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ027tLugarSegurosRelatedByCoUsuarioUpdated()
	 */
	public function clearJ027tLugarSegurosRelatedByCoUsuarioUpdated()
	{
		$this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ027tLugarSegurosRelatedByCoUsuarioUpdated collection (array).
	 *
	 * By default this just sets the collJ027tLugarSegurosRelatedByCoUsuarioUpdated collection to an empty array (like clearcollJ027tLugarSegurosRelatedByCoUsuarioUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ027tLugarSegurosRelatedByCoUsuarioUpdated()
	{
		$this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated = array();
	}

	/**
	 * Gets an array of J027tLugarSeguro objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J027tLugarSegurosRelatedByCoUsuarioUpdated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J027tLugarSeguro[]
	 * @throws     PropelException
	 */
	public function getJ027tLugarSegurosRelatedByCoUsuarioUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
			   $this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated = array();
			} else {

				$criteria->add(J027tLugarSeguroPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J027tLugarSeguroPeer::addSelectColumns($criteria);
				$this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated = J027tLugarSeguroPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J027tLugarSeguroPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J027tLugarSeguroPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ027tLugarSeguroRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ027tLugarSeguroRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated = J027tLugarSeguroPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ027tLugarSeguroRelatedByCoUsuarioUpdatedCriteria = $criteria;
		return $this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated;
	}

	/**
	 * Returns the number of related J027tLugarSeguro objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J027tLugarSeguro objects.
	 * @throws     PropelException
	 */
	public function countJ027tLugarSegurosRelatedByCoUsuarioUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J027tLugarSeguroPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				$count = J027tLugarSeguroPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J027tLugarSeguroPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				if (!isset($this->lastJ027tLugarSeguroRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ027tLugarSeguroRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$count = J027tLugarSeguroPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated);
				}
			} else {
				$count = count($this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J027tLugarSeguro object to this object
	 * through the J027tLugarSeguro foreign key attribute.
	 *
	 * @param      J027tLugarSeguro $l J027tLugarSeguro
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ027tLugarSeguroRelatedByCoUsuarioUpdated(J027tLugarSeguro $l)
	{
		if ($this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated === null) {
			$this->initJ027tLugarSegurosRelatedByCoUsuarioUpdated();
		}
		if (!in_array($l, $this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdated($this);
		}
	}

	/**
	 * Clears out the collJ028tRepositoriosRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ028tRepositoriosRelatedByCoUsuarioCreated()
	 */
	public function clearJ028tRepositoriosRelatedByCoUsuarioCreated()
	{
		$this->collJ028tRepositoriosRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ028tRepositoriosRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ028tRepositoriosRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ028tRepositoriosRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ028tRepositoriosRelatedByCoUsuarioCreated()
	{
		$this->collJ028tRepositoriosRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J028tRepositorio objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J028tRepositoriosRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J028tRepositorio[]
	 * @throws     PropelException
	 */
	public function getJ028tRepositoriosRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ028tRepositoriosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ028tRepositoriosRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J028tRepositorioPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J028tRepositorioPeer::addSelectColumns($criteria);
				$this->collJ028tRepositoriosRelatedByCoUsuarioCreated = J028tRepositorioPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J028tRepositorioPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J028tRepositorioPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ028tRepositorioRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ028tRepositorioRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ028tRepositoriosRelatedByCoUsuarioCreated = J028tRepositorioPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ028tRepositorioRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ028tRepositoriosRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J028tRepositorio objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J028tRepositorio objects.
	 * @throws     PropelException
	 */
	public function countJ028tRepositoriosRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ028tRepositoriosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J028tRepositorioPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J028tRepositorioPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J028tRepositorioPeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ028tRepositorioRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ028tRepositorioRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J028tRepositorioPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ028tRepositoriosRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ028tRepositoriosRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J028tRepositorio object to this object
	 * through the J028tRepositorio foreign key attribute.
	 *
	 * @param      J028tRepositorio $l J028tRepositorio
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ028tRepositorioRelatedByCoUsuarioCreated(J028tRepositorio $l)
	{
		if ($this->collJ028tRepositoriosRelatedByCoUsuarioCreated === null) {
			$this->initJ028tRepositoriosRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ028tRepositoriosRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ028tRepositoriosRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}

	/**
	 * Clears out the collJ028tRepositoriosRelatedByCoUsuarioUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ028tRepositoriosRelatedByCoUsuarioUpdated()
	 */
	public function clearJ028tRepositoriosRelatedByCoUsuarioUpdated()
	{
		$this->collJ028tRepositoriosRelatedByCoUsuarioUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ028tRepositoriosRelatedByCoUsuarioUpdated collection (array).
	 *
	 * By default this just sets the collJ028tRepositoriosRelatedByCoUsuarioUpdated collection to an empty array (like clearcollJ028tRepositoriosRelatedByCoUsuarioUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ028tRepositoriosRelatedByCoUsuarioUpdated()
	{
		$this->collJ028tRepositoriosRelatedByCoUsuarioUpdated = array();
	}

	/**
	 * Gets an array of J028tRepositorio objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J028tRepositoriosRelatedByCoUsuarioUpdated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J028tRepositorio[]
	 * @throws     PropelException
	 */
	public function getJ028tRepositoriosRelatedByCoUsuarioUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ028tRepositoriosRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
			   $this->collJ028tRepositoriosRelatedByCoUsuarioUpdated = array();
			} else {

				$criteria->add(J028tRepositorioPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J028tRepositorioPeer::addSelectColumns($criteria);
				$this->collJ028tRepositoriosRelatedByCoUsuarioUpdated = J028tRepositorioPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J028tRepositorioPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J028tRepositorioPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ028tRepositorioRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ028tRepositorioRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$this->collJ028tRepositoriosRelatedByCoUsuarioUpdated = J028tRepositorioPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ028tRepositorioRelatedByCoUsuarioUpdatedCriteria = $criteria;
		return $this->collJ028tRepositoriosRelatedByCoUsuarioUpdated;
	}

	/**
	 * Returns the number of related J028tRepositorio objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J028tRepositorio objects.
	 * @throws     PropelException
	 */
	public function countJ028tRepositoriosRelatedByCoUsuarioUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ028tRepositoriosRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J028tRepositorioPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				$count = J028tRepositorioPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J028tRepositorioPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				if (!isset($this->lastJ028tRepositorioRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ028tRepositorioRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$count = J028tRepositorioPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ028tRepositoriosRelatedByCoUsuarioUpdated);
				}
			} else {
				$count = count($this->collJ028tRepositoriosRelatedByCoUsuarioUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J028tRepositorio object to this object
	 * through the J028tRepositorio foreign key attribute.
	 *
	 * @param      J028tRepositorio $l J028tRepositorio
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ028tRepositorioRelatedByCoUsuarioUpdated(J028tRepositorio $l)
	{
		if ($this->collJ028tRepositoriosRelatedByCoUsuarioUpdated === null) {
			$this->initJ028tRepositoriosRelatedByCoUsuarioUpdated();
		}
		if (!in_array($l, $this->collJ028tRepositoriosRelatedByCoUsuarioUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ028tRepositoriosRelatedByCoUsuarioUpdated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdated($this);
		}
	}

	/**
	 * Clears out the collJ030tInformeRecomendacionessRelatedByCoRevisa collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ030tInformeRecomendacionessRelatedByCoRevisa()
	 */
	public function clearJ030tInformeRecomendacionessRelatedByCoRevisa()
	{
		$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ030tInformeRecomendacionessRelatedByCoRevisa collection (array).
	 *
	 * By default this just sets the collJ030tInformeRecomendacionessRelatedByCoRevisa collection to an empty array (like clearcollJ030tInformeRecomendacionessRelatedByCoRevisa());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ030tInformeRecomendacionessRelatedByCoRevisa()
	{
		$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = array();
	}

	/**
	 * Gets an array of J030tInformeRecomendaciones objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J030tInformeRecomendacionessRelatedByCoRevisa from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J030tInformeRecomendaciones[]
	 * @throws     PropelException
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoRevisa($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoRevisa === null) {
			if ($this->isNew()) {
			   $this->collJ030tInformeRecomendacionessRelatedByCoRevisa = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_REVISA, $this->co_usuario);

				J030tInformeRecomendacionesPeer::addSelectColumns($criteria);
				$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = J030tInformeRecomendacionesPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J030tInformeRecomendacionesPeer::CO_REVISA, $this->co_usuario);

				J030tInformeRecomendacionesPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria->equals($criteria)) {
					$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = J030tInformeRecomendacionesPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria = $criteria;
		return $this->collJ030tInformeRecomendacionessRelatedByCoRevisa;
	}

	/**
	 * Returns the number of related J030tInformeRecomendaciones objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J030tInformeRecomendaciones objects.
	 * @throws     PropelException
	 */
	public function countJ030tInformeRecomendacionessRelatedByCoRevisa(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ030tInformeRecomendacionessRelatedByCoRevisa === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_REVISA, $this->co_usuario);

				$count = J030tInformeRecomendacionesPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J030tInformeRecomendacionesPeer::CO_REVISA, $this->co_usuario);

				if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria->equals($criteria)) {
					$count = J030tInformeRecomendacionesPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ030tInformeRecomendacionessRelatedByCoRevisa);
				}
			} else {
				$count = count($this->collJ030tInformeRecomendacionessRelatedByCoRevisa);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J030tInformeRecomendaciones object to this object
	 * through the J030tInformeRecomendaciones foreign key attribute.
	 *
	 * @param      J030tInformeRecomendaciones $l J030tInformeRecomendaciones
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ030tInformeRecomendacionesRelatedByCoRevisa(J030tInformeRecomendaciones $l)
	{
		if ($this->collJ030tInformeRecomendacionessRelatedByCoRevisa === null) {
			$this->initJ030tInformeRecomendacionessRelatedByCoRevisa();
		}
		if (!in_array($l, $this->collJ030tInformeRecomendacionessRelatedByCoRevisa, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ030tInformeRecomendacionessRelatedByCoRevisa, $l);
			$l->setJ002tUsuarioRelatedByCoRevisa($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J030tInformeRecomendacionessRelatedByCoRevisa from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoRevisaJoinJ031tAccionRecomendada($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoRevisa === null) {
			if ($this->isNew()) {
				$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_REVISA, $this->co_usuario);

				$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = J030tInformeRecomendacionesPeer::doSelectJoinJ031tAccionRecomendada($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J030tInformeRecomendacionesPeer::CO_REVISA, $this->co_usuario);

			if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria->equals($criteria)) {
				$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = J030tInformeRecomendacionesPeer::doSelectJoinJ031tAccionRecomendada($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria = $criteria;

		return $this->collJ030tInformeRecomendacionessRelatedByCoRevisa;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J030tInformeRecomendacionessRelatedByCoRevisa from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoRevisaJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoRevisa === null) {
			if ($this->isNew()) {
				$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_REVISA, $this->co_usuario);

				$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = J030tInformeRecomendacionesPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J030tInformeRecomendacionesPeer::CO_REVISA, $this->co_usuario);

			if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria->equals($criteria)) {
				$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = J030tInformeRecomendacionesPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria = $criteria;

		return $this->collJ030tInformeRecomendacionessRelatedByCoRevisa;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J030tInformeRecomendacionessRelatedByCoRevisa from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoRevisaJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoRevisa === null) {
			if ($this->isNew()) {
				$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_REVISA, $this->co_usuario);

				$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = J030tInformeRecomendacionesPeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J030tInformeRecomendacionesPeer::CO_REVISA, $this->co_usuario);

			if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria->equals($criteria)) {
				$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = J030tInformeRecomendacionesPeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria = $criteria;

		return $this->collJ030tInformeRecomendacionessRelatedByCoRevisa;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J030tInformeRecomendacionessRelatedByCoRevisa from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoRevisaJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoRevisa === null) {
			if ($this->isNew()) {
				$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_REVISA, $this->co_usuario);

				$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = J030tInformeRecomendacionesPeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J030tInformeRecomendacionesPeer::CO_REVISA, $this->co_usuario);

			if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria->equals($criteria)) {
				$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = J030tInformeRecomendacionesPeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoRevisaCriteria = $criteria;

		return $this->collJ030tInformeRecomendacionessRelatedByCoRevisa;
	}

	/**
	 * Clears out the collJ030tInformeRecomendacionessRelatedByCoAprueba collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ030tInformeRecomendacionessRelatedByCoAprueba()
	 */
	public function clearJ030tInformeRecomendacionessRelatedByCoAprueba()
	{
		$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ030tInformeRecomendacionessRelatedByCoAprueba collection (array).
	 *
	 * By default this just sets the collJ030tInformeRecomendacionessRelatedByCoAprueba collection to an empty array (like clearcollJ030tInformeRecomendacionessRelatedByCoAprueba());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ030tInformeRecomendacionessRelatedByCoAprueba()
	{
		$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = array();
	}

	/**
	 * Gets an array of J030tInformeRecomendaciones objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J030tInformeRecomendacionessRelatedByCoAprueba from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J030tInformeRecomendaciones[]
	 * @throws     PropelException
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoAprueba($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoAprueba === null) {
			if ($this->isNew()) {
			   $this->collJ030tInformeRecomendacionessRelatedByCoAprueba = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_APRUEBA, $this->co_usuario);

				J030tInformeRecomendacionesPeer::addSelectColumns($criteria);
				$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = J030tInformeRecomendacionesPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J030tInformeRecomendacionesPeer::CO_APRUEBA, $this->co_usuario);

				J030tInformeRecomendacionesPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria->equals($criteria)) {
					$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = J030tInformeRecomendacionesPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria = $criteria;
		return $this->collJ030tInformeRecomendacionessRelatedByCoAprueba;
	}

	/**
	 * Returns the number of related J030tInformeRecomendaciones objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J030tInformeRecomendaciones objects.
	 * @throws     PropelException
	 */
	public function countJ030tInformeRecomendacionessRelatedByCoAprueba(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ030tInformeRecomendacionessRelatedByCoAprueba === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_APRUEBA, $this->co_usuario);

				$count = J030tInformeRecomendacionesPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J030tInformeRecomendacionesPeer::CO_APRUEBA, $this->co_usuario);

				if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria->equals($criteria)) {
					$count = J030tInformeRecomendacionesPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ030tInformeRecomendacionessRelatedByCoAprueba);
				}
			} else {
				$count = count($this->collJ030tInformeRecomendacionessRelatedByCoAprueba);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J030tInformeRecomendaciones object to this object
	 * through the J030tInformeRecomendaciones foreign key attribute.
	 *
	 * @param      J030tInformeRecomendaciones $l J030tInformeRecomendaciones
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ030tInformeRecomendacionesRelatedByCoAprueba(J030tInformeRecomendaciones $l)
	{
		if ($this->collJ030tInformeRecomendacionessRelatedByCoAprueba === null) {
			$this->initJ030tInformeRecomendacionessRelatedByCoAprueba();
		}
		if (!in_array($l, $this->collJ030tInformeRecomendacionessRelatedByCoAprueba, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ030tInformeRecomendacionessRelatedByCoAprueba, $l);
			$l->setJ002tUsuarioRelatedByCoAprueba($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J030tInformeRecomendacionessRelatedByCoAprueba from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoApruebaJoinJ031tAccionRecomendada($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoAprueba === null) {
			if ($this->isNew()) {
				$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_APRUEBA, $this->co_usuario);

				$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = J030tInformeRecomendacionesPeer::doSelectJoinJ031tAccionRecomendada($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J030tInformeRecomendacionesPeer::CO_APRUEBA, $this->co_usuario);

			if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria->equals($criteria)) {
				$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = J030tInformeRecomendacionesPeer::doSelectJoinJ031tAccionRecomendada($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria = $criteria;

		return $this->collJ030tInformeRecomendacionessRelatedByCoAprueba;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J030tInformeRecomendacionessRelatedByCoAprueba from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoApruebaJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoAprueba === null) {
			if ($this->isNew()) {
				$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_APRUEBA, $this->co_usuario);

				$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = J030tInformeRecomendacionesPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J030tInformeRecomendacionesPeer::CO_APRUEBA, $this->co_usuario);

			if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria->equals($criteria)) {
				$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = J030tInformeRecomendacionesPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria = $criteria;

		return $this->collJ030tInformeRecomendacionessRelatedByCoAprueba;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J030tInformeRecomendacionessRelatedByCoAprueba from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoApruebaJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoAprueba === null) {
			if ($this->isNew()) {
				$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_APRUEBA, $this->co_usuario);

				$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = J030tInformeRecomendacionesPeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J030tInformeRecomendacionesPeer::CO_APRUEBA, $this->co_usuario);

			if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria->equals($criteria)) {
				$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = J030tInformeRecomendacionesPeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria = $criteria;

		return $this->collJ030tInformeRecomendacionessRelatedByCoAprueba;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J030tInformeRecomendacionessRelatedByCoAprueba from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoApruebaJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoAprueba === null) {
			if ($this->isNew()) {
				$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_APRUEBA, $this->co_usuario);

				$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = J030tInformeRecomendacionesPeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J030tInformeRecomendacionesPeer::CO_APRUEBA, $this->co_usuario);

			if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria->equals($criteria)) {
				$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = J030tInformeRecomendacionesPeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoApruebaCriteria = $criteria;

		return $this->collJ030tInformeRecomendacionessRelatedByCoAprueba;
	}

	/**
	 * Clears out the collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ030tInformeRecomendacionessRelatedByCoUsuarioCreated()
	 */
	public function clearJ030tInformeRecomendacionessRelatedByCoUsuarioCreated()
	{
		$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ030tInformeRecomendacionessRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ030tInformeRecomendacionessRelatedByCoUsuarioCreated()
	{
		$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J030tInformeRecomendaciones objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J030tInformeRecomendacionessRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J030tInformeRecomendaciones[]
	 * @throws     PropelException
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J030tInformeRecomendacionesPeer::addSelectColumns($criteria);
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = J030tInformeRecomendacionesPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J030tInformeRecomendacionesPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = J030tInformeRecomendacionesPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J030tInformeRecomendaciones objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J030tInformeRecomendaciones objects.
	 * @throws     PropelException
	 */
	public function countJ030tInformeRecomendacionessRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J030tInformeRecomendacionesPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J030tInformeRecomendacionesPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J030tInformeRecomendaciones object to this object
	 * through the J030tInformeRecomendaciones foreign key attribute.
	 *
	 * @param      J030tInformeRecomendaciones $l J030tInformeRecomendaciones
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ030tInformeRecomendacionesRelatedByCoUsuarioCreated(J030tInformeRecomendaciones $l)
	{
		if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated === null) {
			$this->initJ030tInformeRecomendacionessRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J030tInformeRecomendacionessRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoUsuarioCreatedJoinJ031tAccionRecomendada($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = J030tInformeRecomendacionesPeer::doSelectJoinJ031tAccionRecomendada($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = J030tInformeRecomendacionesPeer::doSelectJoinJ031tAccionRecomendada($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J030tInformeRecomendacionessRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoUsuarioCreatedJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = J030tInformeRecomendacionesPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = J030tInformeRecomendacionesPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J030tInformeRecomendacionessRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoUsuarioCreatedJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = J030tInformeRecomendacionesPeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = J030tInformeRecomendacionesPeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J030tInformeRecomendacionessRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoUsuarioCreatedJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = J030tInformeRecomendacionesPeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = J030tInformeRecomendacionesPeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated;
	}

	/**
	 * Clears out the collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate()
	 */
	public function clearJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate()
	{
		$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate collection (array).
	 *
	 * By default this just sets the collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate collection to an empty array (like clearcollJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate()
	{
		$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = array();
	}

	/**
	 * Gets an array of J030tInformeRecomendaciones objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J030tInformeRecomendacionessRelatedByCoUsuarioUpdate from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J030tInformeRecomendaciones[]
	 * @throws     PropelException
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
			   $this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				J030tInformeRecomendacionesPeer::addSelectColumns($criteria);
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = J030tInformeRecomendacionesPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				J030tInformeRecomendacionesPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
					$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = J030tInformeRecomendacionesPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria = $criteria;
		return $this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate;
	}

	/**
	 * Returns the number of related J030tInformeRecomendaciones objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J030tInformeRecomendaciones objects.
	 * @throws     PropelException
	 */
	public function countJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$count = J030tInformeRecomendacionesPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
					$count = J030tInformeRecomendacionesPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate);
				}
			} else {
				$count = count($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J030tInformeRecomendaciones object to this object
	 * through the J030tInformeRecomendaciones foreign key attribute.
	 *
	 * @param      J030tInformeRecomendaciones $l J030tInformeRecomendaciones
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ030tInformeRecomendacionesRelatedByCoUsuarioUpdate(J030tInformeRecomendaciones $l)
	{
		if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate === null) {
			$this->initJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate();
		}
		if (!in_array($l, $this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdate($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J030tInformeRecomendacionessRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoUsuarioUpdateJoinJ031tAccionRecomendada($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = J030tInformeRecomendacionesPeer::doSelectJoinJ031tAccionRecomendada($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = J030tInformeRecomendacionesPeer::doSelectJoinJ031tAccionRecomendada($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J030tInformeRecomendacionessRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoUsuarioUpdateJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = J030tInformeRecomendacionesPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = J030tInformeRecomendacionesPeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J030tInformeRecomendacionessRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoUsuarioUpdateJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = J030tInformeRecomendacionesPeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = J030tInformeRecomendacionesPeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J030tInformeRecomendacionessRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ030tInformeRecomendacionessRelatedByCoUsuarioUpdateJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = J030tInformeRecomendacionesPeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J030tInformeRecomendacionesPeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = J030tInformeRecomendacionesPeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ030tInformeRecomendacionesRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate;
	}

	/**
	 * Clears out the collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar()
	 */
	public function clearJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar()
	{
		$this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar collection (array).
	 *
	 * By default this just sets the collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar collection to an empty array (like clearcollJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar()
	{
		$this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar = array();
	}

	/**
	 * Gets an array of J031tAccionRecomendada objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J031tAccionRecomendadasRelatedByCoResponsableStiEjecutar from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J031tAccionRecomendada[]
	 * @throws     PropelException
	 */
	public function getJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar === null) {
			if ($this->isNew()) {
			   $this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar = array();
			} else {

				$criteria->add(J031tAccionRecomendadaPeer::CO_RESPONSABLE_STI_EJECUTAR, $this->co_usuario);

				J031tAccionRecomendadaPeer::addSelectColumns($criteria);
				$this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar = J031tAccionRecomendadaPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J031tAccionRecomendadaPeer::CO_RESPONSABLE_STI_EJECUTAR, $this->co_usuario);

				J031tAccionRecomendadaPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ031tAccionRecomendadaRelatedByCoResponsableStiEjecutarCriteria) || !$this->lastJ031tAccionRecomendadaRelatedByCoResponsableStiEjecutarCriteria->equals($criteria)) {
					$this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar = J031tAccionRecomendadaPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ031tAccionRecomendadaRelatedByCoResponsableStiEjecutarCriteria = $criteria;
		return $this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar;
	}

	/**
	 * Returns the number of related J031tAccionRecomendada objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J031tAccionRecomendada objects.
	 * @throws     PropelException
	 */
	public function countJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J031tAccionRecomendadaPeer::CO_RESPONSABLE_STI_EJECUTAR, $this->co_usuario);

				$count = J031tAccionRecomendadaPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J031tAccionRecomendadaPeer::CO_RESPONSABLE_STI_EJECUTAR, $this->co_usuario);

				if (!isset($this->lastJ031tAccionRecomendadaRelatedByCoResponsableStiEjecutarCriteria) || !$this->lastJ031tAccionRecomendadaRelatedByCoResponsableStiEjecutarCriteria->equals($criteria)) {
					$count = J031tAccionRecomendadaPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar);
				}
			} else {
				$count = count($this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J031tAccionRecomendada object to this object
	 * through the J031tAccionRecomendada foreign key attribute.
	 *
	 * @param      J031tAccionRecomendada $l J031tAccionRecomendada
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ031tAccionRecomendadaRelatedByCoResponsableStiEjecutar(J031tAccionRecomendada $l)
	{
		if ($this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar === null) {
			$this->initJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar();
		}
		if (!in_array($l, $this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar, $l);
			$l->setJ002tUsuarioRelatedByCoResponsableStiEjecutar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J031tAccionRecomendadasRelatedByCoResponsableStiEjecutar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutarJoinJ034tIncidente($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar === null) {
			if ($this->isNew()) {
				$this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar = array();
			} else {

				$criteria->add(J031tAccionRecomendadaPeer::CO_RESPONSABLE_STI_EJECUTAR, $this->co_usuario);

				$this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar = J031tAccionRecomendadaPeer::doSelectJoinJ034tIncidente($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J031tAccionRecomendadaPeer::CO_RESPONSABLE_STI_EJECUTAR, $this->co_usuario);

			if (!isset($this->lastJ031tAccionRecomendadaRelatedByCoResponsableStiEjecutarCriteria) || !$this->lastJ031tAccionRecomendadaRelatedByCoResponsableStiEjecutarCriteria->equals($criteria)) {
				$this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar = J031tAccionRecomendadaPeer::doSelectJoinJ034tIncidente($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ031tAccionRecomendadaRelatedByCoResponsableStiEjecutarCriteria = $criteria;

		return $this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J031tAccionRecomendadasRelatedByCoResponsableStiEjecutar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutarJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar === null) {
			if ($this->isNew()) {
				$this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar = array();
			} else {

				$criteria->add(J031tAccionRecomendadaPeer::CO_RESPONSABLE_STI_EJECUTAR, $this->co_usuario);

				$this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar = J031tAccionRecomendadaPeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J031tAccionRecomendadaPeer::CO_RESPONSABLE_STI_EJECUTAR, $this->co_usuario);

			if (!isset($this->lastJ031tAccionRecomendadaRelatedByCoResponsableStiEjecutarCriteria) || !$this->lastJ031tAccionRecomendadaRelatedByCoResponsableStiEjecutarCriteria->equals($criteria)) {
				$this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar = J031tAccionRecomendadaPeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ031tAccionRecomendadaRelatedByCoResponsableStiEjecutarCriteria = $criteria;

		return $this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar;
	}

	/**
	 * Clears out the collJ031tAccionRecomendadasRelatedByCoCreatedAt collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ031tAccionRecomendadasRelatedByCoCreatedAt()
	 */
	public function clearJ031tAccionRecomendadasRelatedByCoCreatedAt()
	{
		$this->collJ031tAccionRecomendadasRelatedByCoCreatedAt = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ031tAccionRecomendadasRelatedByCoCreatedAt collection (array).
	 *
	 * By default this just sets the collJ031tAccionRecomendadasRelatedByCoCreatedAt collection to an empty array (like clearcollJ031tAccionRecomendadasRelatedByCoCreatedAt());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ031tAccionRecomendadasRelatedByCoCreatedAt()
	{
		$this->collJ031tAccionRecomendadasRelatedByCoCreatedAt = array();
	}

	/**
	 * Gets an array of J031tAccionRecomendada objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J031tAccionRecomendadasRelatedByCoCreatedAt from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J031tAccionRecomendada[]
	 * @throws     PropelException
	 */
	public function getJ031tAccionRecomendadasRelatedByCoCreatedAt($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ031tAccionRecomendadasRelatedByCoCreatedAt === null) {
			if ($this->isNew()) {
			   $this->collJ031tAccionRecomendadasRelatedByCoCreatedAt = array();
			} else {

				$criteria->add(J031tAccionRecomendadaPeer::CO_CREATED_AT, $this->co_usuario);

				J031tAccionRecomendadaPeer::addSelectColumns($criteria);
				$this->collJ031tAccionRecomendadasRelatedByCoCreatedAt = J031tAccionRecomendadaPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J031tAccionRecomendadaPeer::CO_CREATED_AT, $this->co_usuario);

				J031tAccionRecomendadaPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ031tAccionRecomendadaRelatedByCoCreatedAtCriteria) || !$this->lastJ031tAccionRecomendadaRelatedByCoCreatedAtCriteria->equals($criteria)) {
					$this->collJ031tAccionRecomendadasRelatedByCoCreatedAt = J031tAccionRecomendadaPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ031tAccionRecomendadaRelatedByCoCreatedAtCriteria = $criteria;
		return $this->collJ031tAccionRecomendadasRelatedByCoCreatedAt;
	}

	/**
	 * Returns the number of related J031tAccionRecomendada objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J031tAccionRecomendada objects.
	 * @throws     PropelException
	 */
	public function countJ031tAccionRecomendadasRelatedByCoCreatedAt(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ031tAccionRecomendadasRelatedByCoCreatedAt === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J031tAccionRecomendadaPeer::CO_CREATED_AT, $this->co_usuario);

				$count = J031tAccionRecomendadaPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J031tAccionRecomendadaPeer::CO_CREATED_AT, $this->co_usuario);

				if (!isset($this->lastJ031tAccionRecomendadaRelatedByCoCreatedAtCriteria) || !$this->lastJ031tAccionRecomendadaRelatedByCoCreatedAtCriteria->equals($criteria)) {
					$count = J031tAccionRecomendadaPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ031tAccionRecomendadasRelatedByCoCreatedAt);
				}
			} else {
				$count = count($this->collJ031tAccionRecomendadasRelatedByCoCreatedAt);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J031tAccionRecomendada object to this object
	 * through the J031tAccionRecomendada foreign key attribute.
	 *
	 * @param      J031tAccionRecomendada $l J031tAccionRecomendada
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ031tAccionRecomendadaRelatedByCoCreatedAt(J031tAccionRecomendada $l)
	{
		if ($this->collJ031tAccionRecomendadasRelatedByCoCreatedAt === null) {
			$this->initJ031tAccionRecomendadasRelatedByCoCreatedAt();
		}
		if (!in_array($l, $this->collJ031tAccionRecomendadasRelatedByCoCreatedAt, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ031tAccionRecomendadasRelatedByCoCreatedAt, $l);
			$l->setJ002tUsuarioRelatedByCoCreatedAt($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J031tAccionRecomendadasRelatedByCoCreatedAt from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ031tAccionRecomendadasRelatedByCoCreatedAtJoinJ034tIncidente($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ031tAccionRecomendadasRelatedByCoCreatedAt === null) {
			if ($this->isNew()) {
				$this->collJ031tAccionRecomendadasRelatedByCoCreatedAt = array();
			} else {

				$criteria->add(J031tAccionRecomendadaPeer::CO_CREATED_AT, $this->co_usuario);

				$this->collJ031tAccionRecomendadasRelatedByCoCreatedAt = J031tAccionRecomendadaPeer::doSelectJoinJ034tIncidente($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J031tAccionRecomendadaPeer::CO_CREATED_AT, $this->co_usuario);

			if (!isset($this->lastJ031tAccionRecomendadaRelatedByCoCreatedAtCriteria) || !$this->lastJ031tAccionRecomendadaRelatedByCoCreatedAtCriteria->equals($criteria)) {
				$this->collJ031tAccionRecomendadasRelatedByCoCreatedAt = J031tAccionRecomendadaPeer::doSelectJoinJ034tIncidente($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ031tAccionRecomendadaRelatedByCoCreatedAtCriteria = $criteria;

		return $this->collJ031tAccionRecomendadasRelatedByCoCreatedAt;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J031tAccionRecomendadasRelatedByCoCreatedAt from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ031tAccionRecomendadasRelatedByCoCreatedAtJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ031tAccionRecomendadasRelatedByCoCreatedAt === null) {
			if ($this->isNew()) {
				$this->collJ031tAccionRecomendadasRelatedByCoCreatedAt = array();
			} else {

				$criteria->add(J031tAccionRecomendadaPeer::CO_CREATED_AT, $this->co_usuario);

				$this->collJ031tAccionRecomendadasRelatedByCoCreatedAt = J031tAccionRecomendadaPeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J031tAccionRecomendadaPeer::CO_CREATED_AT, $this->co_usuario);

			if (!isset($this->lastJ031tAccionRecomendadaRelatedByCoCreatedAtCriteria) || !$this->lastJ031tAccionRecomendadaRelatedByCoCreatedAtCriteria->equals($criteria)) {
				$this->collJ031tAccionRecomendadasRelatedByCoCreatedAt = J031tAccionRecomendadaPeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ031tAccionRecomendadaRelatedByCoCreatedAtCriteria = $criteria;

		return $this->collJ031tAccionRecomendadasRelatedByCoCreatedAt;
	}

	/**
	 * Clears out the collJ031tAccionRecomendadasRelatedByCoUpdateAt collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ031tAccionRecomendadasRelatedByCoUpdateAt()
	 */
	public function clearJ031tAccionRecomendadasRelatedByCoUpdateAt()
	{
		$this->collJ031tAccionRecomendadasRelatedByCoUpdateAt = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ031tAccionRecomendadasRelatedByCoUpdateAt collection (array).
	 *
	 * By default this just sets the collJ031tAccionRecomendadasRelatedByCoUpdateAt collection to an empty array (like clearcollJ031tAccionRecomendadasRelatedByCoUpdateAt());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ031tAccionRecomendadasRelatedByCoUpdateAt()
	{
		$this->collJ031tAccionRecomendadasRelatedByCoUpdateAt = array();
	}

	/**
	 * Gets an array of J031tAccionRecomendada objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J031tAccionRecomendadasRelatedByCoUpdateAt from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J031tAccionRecomendada[]
	 * @throws     PropelException
	 */
	public function getJ031tAccionRecomendadasRelatedByCoUpdateAt($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ031tAccionRecomendadasRelatedByCoUpdateAt === null) {
			if ($this->isNew()) {
			   $this->collJ031tAccionRecomendadasRelatedByCoUpdateAt = array();
			} else {

				$criteria->add(J031tAccionRecomendadaPeer::CO_UPDATE_AT, $this->co_usuario);

				J031tAccionRecomendadaPeer::addSelectColumns($criteria);
				$this->collJ031tAccionRecomendadasRelatedByCoUpdateAt = J031tAccionRecomendadaPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J031tAccionRecomendadaPeer::CO_UPDATE_AT, $this->co_usuario);

				J031tAccionRecomendadaPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ031tAccionRecomendadaRelatedByCoUpdateAtCriteria) || !$this->lastJ031tAccionRecomendadaRelatedByCoUpdateAtCriteria->equals($criteria)) {
					$this->collJ031tAccionRecomendadasRelatedByCoUpdateAt = J031tAccionRecomendadaPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ031tAccionRecomendadaRelatedByCoUpdateAtCriteria = $criteria;
		return $this->collJ031tAccionRecomendadasRelatedByCoUpdateAt;
	}

	/**
	 * Returns the number of related J031tAccionRecomendada objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J031tAccionRecomendada objects.
	 * @throws     PropelException
	 */
	public function countJ031tAccionRecomendadasRelatedByCoUpdateAt(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ031tAccionRecomendadasRelatedByCoUpdateAt === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J031tAccionRecomendadaPeer::CO_UPDATE_AT, $this->co_usuario);

				$count = J031tAccionRecomendadaPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J031tAccionRecomendadaPeer::CO_UPDATE_AT, $this->co_usuario);

				if (!isset($this->lastJ031tAccionRecomendadaRelatedByCoUpdateAtCriteria) || !$this->lastJ031tAccionRecomendadaRelatedByCoUpdateAtCriteria->equals($criteria)) {
					$count = J031tAccionRecomendadaPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ031tAccionRecomendadasRelatedByCoUpdateAt);
				}
			} else {
				$count = count($this->collJ031tAccionRecomendadasRelatedByCoUpdateAt);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J031tAccionRecomendada object to this object
	 * through the J031tAccionRecomendada foreign key attribute.
	 *
	 * @param      J031tAccionRecomendada $l J031tAccionRecomendada
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ031tAccionRecomendadaRelatedByCoUpdateAt(J031tAccionRecomendada $l)
	{
		if ($this->collJ031tAccionRecomendadasRelatedByCoUpdateAt === null) {
			$this->initJ031tAccionRecomendadasRelatedByCoUpdateAt();
		}
		if (!in_array($l, $this->collJ031tAccionRecomendadasRelatedByCoUpdateAt, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ031tAccionRecomendadasRelatedByCoUpdateAt, $l);
			$l->setJ002tUsuarioRelatedByCoUpdateAt($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J031tAccionRecomendadasRelatedByCoUpdateAt from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ031tAccionRecomendadasRelatedByCoUpdateAtJoinJ034tIncidente($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ031tAccionRecomendadasRelatedByCoUpdateAt === null) {
			if ($this->isNew()) {
				$this->collJ031tAccionRecomendadasRelatedByCoUpdateAt = array();
			} else {

				$criteria->add(J031tAccionRecomendadaPeer::CO_UPDATE_AT, $this->co_usuario);

				$this->collJ031tAccionRecomendadasRelatedByCoUpdateAt = J031tAccionRecomendadaPeer::doSelectJoinJ034tIncidente($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J031tAccionRecomendadaPeer::CO_UPDATE_AT, $this->co_usuario);

			if (!isset($this->lastJ031tAccionRecomendadaRelatedByCoUpdateAtCriteria) || !$this->lastJ031tAccionRecomendadaRelatedByCoUpdateAtCriteria->equals($criteria)) {
				$this->collJ031tAccionRecomendadasRelatedByCoUpdateAt = J031tAccionRecomendadaPeer::doSelectJoinJ034tIncidente($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ031tAccionRecomendadaRelatedByCoUpdateAtCriteria = $criteria;

		return $this->collJ031tAccionRecomendadasRelatedByCoUpdateAt;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J031tAccionRecomendadasRelatedByCoUpdateAt from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ031tAccionRecomendadasRelatedByCoUpdateAtJoinJ016tForense($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ031tAccionRecomendadasRelatedByCoUpdateAt === null) {
			if ($this->isNew()) {
				$this->collJ031tAccionRecomendadasRelatedByCoUpdateAt = array();
			} else {

				$criteria->add(J031tAccionRecomendadaPeer::CO_UPDATE_AT, $this->co_usuario);

				$this->collJ031tAccionRecomendadasRelatedByCoUpdateAt = J031tAccionRecomendadaPeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J031tAccionRecomendadaPeer::CO_UPDATE_AT, $this->co_usuario);

			if (!isset($this->lastJ031tAccionRecomendadaRelatedByCoUpdateAtCriteria) || !$this->lastJ031tAccionRecomendadaRelatedByCoUpdateAtCriteria->equals($criteria)) {
				$this->collJ031tAccionRecomendadasRelatedByCoUpdateAt = J031tAccionRecomendadaPeer::doSelectJoinJ016tForense($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ031tAccionRecomendadaRelatedByCoUpdateAtCriteria = $criteria;

		return $this->collJ031tAccionRecomendadasRelatedByCoUpdateAt;
	}

	/**
	 * Clears out the collJ034tIncidentesRelatedByCoUsuarioApertura collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ034tIncidentesRelatedByCoUsuarioApertura()
	 */
	public function clearJ034tIncidentesRelatedByCoUsuarioApertura()
	{
		$this->collJ034tIncidentesRelatedByCoUsuarioApertura = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ034tIncidentesRelatedByCoUsuarioApertura collection (array).
	 *
	 * By default this just sets the collJ034tIncidentesRelatedByCoUsuarioApertura collection to an empty array (like clearcollJ034tIncidentesRelatedByCoUsuarioApertura());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ034tIncidentesRelatedByCoUsuarioApertura()
	{
		$this->collJ034tIncidentesRelatedByCoUsuarioApertura = array();
	}

	/**
	 * Gets an array of J034tIncidente objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J034tIncidentesRelatedByCoUsuarioApertura from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J034tIncidente[]
	 * @throws     PropelException
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioApertura($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioApertura === null) {
			if ($this->isNew()) {
			   $this->collJ034tIncidentesRelatedByCoUsuarioApertura = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				J034tIncidentePeer::addSelectColumns($criteria);
				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = J034tIncidentePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J034tIncidentePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				J034tIncidentePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria->equals($criteria)) {
					$this->collJ034tIncidentesRelatedByCoUsuarioApertura = J034tIncidentePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria = $criteria;
		return $this->collJ034tIncidentesRelatedByCoUsuarioApertura;
	}

	/**
	 * Returns the number of related J034tIncidente objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J034tIncidente objects.
	 * @throws     PropelException
	 */
	public function countJ034tIncidentesRelatedByCoUsuarioApertura(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ034tIncidentesRelatedByCoUsuarioApertura === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				$count = J034tIncidentePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J034tIncidentePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria->equals($criteria)) {
					$count = J034tIncidentePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ034tIncidentesRelatedByCoUsuarioApertura);
				}
			} else {
				$count = count($this->collJ034tIncidentesRelatedByCoUsuarioApertura);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J034tIncidente object to this object
	 * through the J034tIncidente foreign key attribute.
	 *
	 * @param      J034tIncidente $l J034tIncidente
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ034tIncidenteRelatedByCoUsuarioApertura(J034tIncidente $l)
	{
		if ($this->collJ034tIncidentesRelatedByCoUsuarioApertura === null) {
			$this->initJ034tIncidentesRelatedByCoUsuarioApertura();
		}
		if (!in_array($l, $this->collJ034tIncidentesRelatedByCoUsuarioApertura, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ034tIncidentesRelatedByCoUsuarioApertura, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioApertura($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioApertura from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioAperturaJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioApertura === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = J034tIncidentePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_APERTURA, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = J034tIncidentePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioApertura;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioApertura from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioAperturaJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioApertura === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = J034tIncidentePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_APERTURA, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = J034tIncidentePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioApertura;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioApertura from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioAperturaJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioApertura === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = J034tIncidentePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_APERTURA, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = J034tIncidentePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioApertura;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioApertura from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioAperturaJoinJ042tEstadoIncidente($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioApertura === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = J034tIncidentePeer::doSelectJoinJ042tEstadoIncidente($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_APERTURA, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = J034tIncidentePeer::doSelectJoinJ042tEstadoIncidente($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioApertura;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioApertura from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioAperturaJoinJ043tTipoIncidentes($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioApertura === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = J034tIncidentePeer::doSelectJoinJ043tTipoIncidentes($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_APERTURA, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = J034tIncidentePeer::doSelectJoinJ043tTipoIncidentes($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioApertura;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioApertura from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioAperturaJoinJ044tTipoHechos($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioApertura === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_APERTURA, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = J034tIncidentePeer::doSelectJoinJ044tTipoHechos($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_APERTURA, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioApertura = J034tIncidentePeer::doSelectJoinJ044tTipoHechos($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioAperturaCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioApertura;
	}

	/**
	 * Clears out the collJ034tIncidentesRelatedByCoUsuarioEscala collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ034tIncidentesRelatedByCoUsuarioEscala()
	 */
	public function clearJ034tIncidentesRelatedByCoUsuarioEscala()
	{
		$this->collJ034tIncidentesRelatedByCoUsuarioEscala = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ034tIncidentesRelatedByCoUsuarioEscala collection (array).
	 *
	 * By default this just sets the collJ034tIncidentesRelatedByCoUsuarioEscala collection to an empty array (like clearcollJ034tIncidentesRelatedByCoUsuarioEscala());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ034tIncidentesRelatedByCoUsuarioEscala()
	{
		$this->collJ034tIncidentesRelatedByCoUsuarioEscala = array();
	}

	/**
	 * Gets an array of J034tIncidente objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J034tIncidentesRelatedByCoUsuarioEscala from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J034tIncidente[]
	 * @throws     PropelException
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioEscala($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioEscala === null) {
			if ($this->isNew()) {
			   $this->collJ034tIncidentesRelatedByCoUsuarioEscala = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_ESCALA, $this->co_usuario);

				J034tIncidentePeer::addSelectColumns($criteria);
				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = J034tIncidentePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J034tIncidentePeer::CO_USUARIO_ESCALA, $this->co_usuario);

				J034tIncidentePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria->equals($criteria)) {
					$this->collJ034tIncidentesRelatedByCoUsuarioEscala = J034tIncidentePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria = $criteria;
		return $this->collJ034tIncidentesRelatedByCoUsuarioEscala;
	}

	/**
	 * Returns the number of related J034tIncidente objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J034tIncidente objects.
	 * @throws     PropelException
	 */
	public function countJ034tIncidentesRelatedByCoUsuarioEscala(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ034tIncidentesRelatedByCoUsuarioEscala === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_ESCALA, $this->co_usuario);

				$count = J034tIncidentePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J034tIncidentePeer::CO_USUARIO_ESCALA, $this->co_usuario);

				if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria->equals($criteria)) {
					$count = J034tIncidentePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ034tIncidentesRelatedByCoUsuarioEscala);
				}
			} else {
				$count = count($this->collJ034tIncidentesRelatedByCoUsuarioEscala);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J034tIncidente object to this object
	 * through the J034tIncidente foreign key attribute.
	 *
	 * @param      J034tIncidente $l J034tIncidente
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ034tIncidenteRelatedByCoUsuarioEscala(J034tIncidente $l)
	{
		if ($this->collJ034tIncidentesRelatedByCoUsuarioEscala === null) {
			$this->initJ034tIncidentesRelatedByCoUsuarioEscala();
		}
		if (!in_array($l, $this->collJ034tIncidentesRelatedByCoUsuarioEscala, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ034tIncidentesRelatedByCoUsuarioEscala, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioEscala($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioEscala from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioEscalaJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioEscala === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_ESCALA, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = J034tIncidentePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_ESCALA, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = J034tIncidentePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioEscala;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioEscala from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioEscalaJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioEscala === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_ESCALA, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = J034tIncidentePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_ESCALA, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = J034tIncidentePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioEscala;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioEscala from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioEscalaJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioEscala === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_ESCALA, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = J034tIncidentePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_ESCALA, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = J034tIncidentePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioEscala;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioEscala from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioEscalaJoinJ042tEstadoIncidente($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioEscala === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_ESCALA, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = J034tIncidentePeer::doSelectJoinJ042tEstadoIncidente($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_ESCALA, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = J034tIncidentePeer::doSelectJoinJ042tEstadoIncidente($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioEscala;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioEscala from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioEscalaJoinJ043tTipoIncidentes($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioEscala === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_ESCALA, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = J034tIncidentePeer::doSelectJoinJ043tTipoIncidentes($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_ESCALA, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = J034tIncidentePeer::doSelectJoinJ043tTipoIncidentes($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioEscala;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioEscala from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioEscalaJoinJ044tTipoHechos($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioEscala === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_ESCALA, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = J034tIncidentePeer::doSelectJoinJ044tTipoHechos($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_ESCALA, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioEscala = J034tIncidentePeer::doSelectJoinJ044tTipoHechos($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioEscalaCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioEscala;
	}

	/**
	 * Clears out the collJ034tIncidentesRelatedByCoUsuarioCierre collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ034tIncidentesRelatedByCoUsuarioCierre()
	 */
	public function clearJ034tIncidentesRelatedByCoUsuarioCierre()
	{
		$this->collJ034tIncidentesRelatedByCoUsuarioCierre = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ034tIncidentesRelatedByCoUsuarioCierre collection (array).
	 *
	 * By default this just sets the collJ034tIncidentesRelatedByCoUsuarioCierre collection to an empty array (like clearcollJ034tIncidentesRelatedByCoUsuarioCierre());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ034tIncidentesRelatedByCoUsuarioCierre()
	{
		$this->collJ034tIncidentesRelatedByCoUsuarioCierre = array();
	}

	/**
	 * Gets an array of J034tIncidente objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J034tIncidentesRelatedByCoUsuarioCierre from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J034tIncidente[]
	 * @throws     PropelException
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioCierre($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioCierre === null) {
			if ($this->isNew()) {
			   $this->collJ034tIncidentesRelatedByCoUsuarioCierre = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				J034tIncidentePeer::addSelectColumns($criteria);
				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = J034tIncidentePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J034tIncidentePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				J034tIncidentePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria->equals($criteria)) {
					$this->collJ034tIncidentesRelatedByCoUsuarioCierre = J034tIncidentePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria = $criteria;
		return $this->collJ034tIncidentesRelatedByCoUsuarioCierre;
	}

	/**
	 * Returns the number of related J034tIncidente objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J034tIncidente objects.
	 * @throws     PropelException
	 */
	public function countJ034tIncidentesRelatedByCoUsuarioCierre(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ034tIncidentesRelatedByCoUsuarioCierre === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				$count = J034tIncidentePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J034tIncidentePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria->equals($criteria)) {
					$count = J034tIncidentePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ034tIncidentesRelatedByCoUsuarioCierre);
				}
			} else {
				$count = count($this->collJ034tIncidentesRelatedByCoUsuarioCierre);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J034tIncidente object to this object
	 * through the J034tIncidente foreign key attribute.
	 *
	 * @param      J034tIncidente $l J034tIncidente
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ034tIncidenteRelatedByCoUsuarioCierre(J034tIncidente $l)
	{
		if ($this->collJ034tIncidentesRelatedByCoUsuarioCierre === null) {
			$this->initJ034tIncidentesRelatedByCoUsuarioCierre();
		}
		if (!in_array($l, $this->collJ034tIncidentesRelatedByCoUsuarioCierre, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ034tIncidentesRelatedByCoUsuarioCierre, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCierre($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioCierre from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioCierreJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioCierre === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = J034tIncidentePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_CIERRE, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = J034tIncidentePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioCierre;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioCierre from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioCierreJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioCierre === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = J034tIncidentePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_CIERRE, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = J034tIncidentePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioCierre;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioCierre from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioCierreJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioCierre === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = J034tIncidentePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_CIERRE, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = J034tIncidentePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioCierre;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioCierre from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioCierreJoinJ042tEstadoIncidente($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioCierre === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = J034tIncidentePeer::doSelectJoinJ042tEstadoIncidente($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_CIERRE, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = J034tIncidentePeer::doSelectJoinJ042tEstadoIncidente($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioCierre;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioCierre from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioCierreJoinJ043tTipoIncidentes($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioCierre === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = J034tIncidentePeer::doSelectJoinJ043tTipoIncidentes($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_CIERRE, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = J034tIncidentePeer::doSelectJoinJ043tTipoIncidentes($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioCierre;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioCierre from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioCierreJoinJ044tTipoHechos($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioCierre === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_CIERRE, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = J034tIncidentePeer::doSelectJoinJ044tTipoHechos($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_CIERRE, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioCierre = J034tIncidentePeer::doSelectJoinJ044tTipoHechos($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioCierreCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioCierre;
	}

	/**
	 * Clears out the collJ034tIncidentesRelatedByCoUsuarioUpdate collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ034tIncidentesRelatedByCoUsuarioUpdate()
	 */
	public function clearJ034tIncidentesRelatedByCoUsuarioUpdate()
	{
		$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ034tIncidentesRelatedByCoUsuarioUpdate collection (array).
	 *
	 * By default this just sets the collJ034tIncidentesRelatedByCoUsuarioUpdate collection to an empty array (like clearcollJ034tIncidentesRelatedByCoUsuarioUpdate());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ034tIncidentesRelatedByCoUsuarioUpdate()
	{
		$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = array();
	}

	/**
	 * Gets an array of J034tIncidente objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J034tIncidentesRelatedByCoUsuarioUpdate from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J034tIncidente[]
	 * @throws     PropelException
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioUpdate($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
			   $this->collJ034tIncidentesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				J034tIncidentePeer::addSelectColumns($criteria);
				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = J034tIncidentePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J034tIncidentePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				J034tIncidentePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
					$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = J034tIncidentePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria = $criteria;
		return $this->collJ034tIncidentesRelatedByCoUsuarioUpdate;
	}

	/**
	 * Returns the number of related J034tIncidente objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J034tIncidente objects.
	 * @throws     PropelException
	 */
	public function countJ034tIncidentesRelatedByCoUsuarioUpdate(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ034tIncidentesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$count = J034tIncidentePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J034tIncidentePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
					$count = J034tIncidentePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ034tIncidentesRelatedByCoUsuarioUpdate);
				}
			} else {
				$count = count($this->collJ034tIncidentesRelatedByCoUsuarioUpdate);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J034tIncidente object to this object
	 * through the J034tIncidente foreign key attribute.
	 *
	 * @param      J034tIncidente $l J034tIncidente
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ034tIncidenteRelatedByCoUsuarioUpdate(J034tIncidente $l)
	{
		if ($this->collJ034tIncidentesRelatedByCoUsuarioUpdate === null) {
			$this->initJ034tIncidentesRelatedByCoUsuarioUpdate();
		}
		if (!in_array($l, $this->collJ034tIncidentesRelatedByCoUsuarioUpdate, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ034tIncidentesRelatedByCoUsuarioUpdate, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdate($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioUpdateJoinJ007tRegion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = J034tIncidentePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = J034tIncidentePeer::doSelectJoinJ007tRegion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioUpdateJoinJ014tNegocio($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = J034tIncidentePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = J034tIncidentePeer::doSelectJoinJ014tNegocio($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioUpdateJoinJ008tDivision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = J034tIncidentePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = J034tIncidentePeer::doSelectJoinJ008tDivision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioUpdateJoinJ042tEstadoIncidente($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = J034tIncidentePeer::doSelectJoinJ042tEstadoIncidente($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = J034tIncidentePeer::doSelectJoinJ042tEstadoIncidente($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioUpdateJoinJ043tTipoIncidentes($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = J034tIncidentePeer::doSelectJoinJ043tTipoIncidentes($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = J034tIncidentePeer::doSelectJoinJ043tTipoIncidentes($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J034tIncidentesRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ034tIncidentesRelatedByCoUsuarioUpdateJoinJ044tTipoHechos($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ034tIncidentesRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J034tIncidentePeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = J034tIncidentePeer::doSelectJoinJ044tTipoHechos($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J034tIncidentePeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = J034tIncidentePeer::doSelectJoinJ044tTipoHechos($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ034tIncidenteRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ034tIncidentesRelatedByCoUsuarioUpdate;
	}

	/**
	 * Clears out the collJ042tEstadoIncidentesRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ042tEstadoIncidentesRelatedByCoUsuarioCreated()
	 */
	public function clearJ042tEstadoIncidentesRelatedByCoUsuarioCreated()
	{
		$this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ042tEstadoIncidentesRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ042tEstadoIncidentesRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ042tEstadoIncidentesRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ042tEstadoIncidentesRelatedByCoUsuarioCreated()
	{
		$this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J042tEstadoIncidente objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J042tEstadoIncidentesRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J042tEstadoIncidente[]
	 * @throws     PropelException
	 */
	public function getJ042tEstadoIncidentesRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J042tEstadoIncidentePeer::CO_USUARIO_CREATED, $this->co_usuario);

				J042tEstadoIncidentePeer::addSelectColumns($criteria);
				$this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated = J042tEstadoIncidentePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J042tEstadoIncidentePeer::CO_USUARIO_CREATED, $this->co_usuario);

				J042tEstadoIncidentePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ042tEstadoIncidenteRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ042tEstadoIncidenteRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated = J042tEstadoIncidentePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ042tEstadoIncidenteRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J042tEstadoIncidente objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J042tEstadoIncidente objects.
	 * @throws     PropelException
	 */
	public function countJ042tEstadoIncidentesRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J042tEstadoIncidentePeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J042tEstadoIncidentePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J042tEstadoIncidentePeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ042tEstadoIncidenteRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ042tEstadoIncidenteRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J042tEstadoIncidentePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J042tEstadoIncidente object to this object
	 * through the J042tEstadoIncidente foreign key attribute.
	 *
	 * @param      J042tEstadoIncidente $l J042tEstadoIncidente
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ042tEstadoIncidenteRelatedByCoUsuarioCreated(J042tEstadoIncidente $l)
	{
		if ($this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated === null) {
			$this->initJ042tEstadoIncidentesRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}

	/**
	 * Clears out the collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ042tEstadoIncidentesRelatedByCoUsuarioUpdated()
	 */
	public function clearJ042tEstadoIncidentesRelatedByCoUsuarioUpdated()
	{
		$this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated collection (array).
	 *
	 * By default this just sets the collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated collection to an empty array (like clearcollJ042tEstadoIncidentesRelatedByCoUsuarioUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ042tEstadoIncidentesRelatedByCoUsuarioUpdated()
	{
		$this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated = array();
	}

	/**
	 * Gets an array of J042tEstadoIncidente objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J042tEstadoIncidentesRelatedByCoUsuarioUpdated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J042tEstadoIncidente[]
	 * @throws     PropelException
	 */
	public function getJ042tEstadoIncidentesRelatedByCoUsuarioUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
			   $this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated = array();
			} else {

				$criteria->add(J042tEstadoIncidentePeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J042tEstadoIncidentePeer::addSelectColumns($criteria);
				$this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated = J042tEstadoIncidentePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J042tEstadoIncidentePeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J042tEstadoIncidentePeer::addSelectColumns($criteria);
				if (!isset($this->lastJ042tEstadoIncidenteRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ042tEstadoIncidenteRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated = J042tEstadoIncidentePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ042tEstadoIncidenteRelatedByCoUsuarioUpdatedCriteria = $criteria;
		return $this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated;
	}

	/**
	 * Returns the number of related J042tEstadoIncidente objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J042tEstadoIncidente objects.
	 * @throws     PropelException
	 */
	public function countJ042tEstadoIncidentesRelatedByCoUsuarioUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J042tEstadoIncidentePeer::CO_USUARIO_UPDATED, $this->co_usuario);

				$count = J042tEstadoIncidentePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J042tEstadoIncidentePeer::CO_USUARIO_UPDATED, $this->co_usuario);

				if (!isset($this->lastJ042tEstadoIncidenteRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ042tEstadoIncidenteRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$count = J042tEstadoIncidentePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated);
				}
			} else {
				$count = count($this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J042tEstadoIncidente object to this object
	 * through the J042tEstadoIncidente foreign key attribute.
	 *
	 * @param      J042tEstadoIncidente $l J042tEstadoIncidente
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ042tEstadoIncidenteRelatedByCoUsuarioUpdated(J042tEstadoIncidente $l)
	{
		if ($this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated === null) {
			$this->initJ042tEstadoIncidentesRelatedByCoUsuarioUpdated();
		}
		if (!in_array($l, $this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdated($this);
		}
	}

	/**
	 * Clears out the collJ047tDocumentoNormativosRelatedByCoAprueba1 collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ047tDocumentoNormativosRelatedByCoAprueba1()
	 */
	public function clearJ047tDocumentoNormativosRelatedByCoAprueba1()
	{
		$this->collJ047tDocumentoNormativosRelatedByCoAprueba1 = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ047tDocumentoNormativosRelatedByCoAprueba1 collection (array).
	 *
	 * By default this just sets the collJ047tDocumentoNormativosRelatedByCoAprueba1 collection to an empty array (like clearcollJ047tDocumentoNormativosRelatedByCoAprueba1());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ047tDocumentoNormativosRelatedByCoAprueba1()
	{
		$this->collJ047tDocumentoNormativosRelatedByCoAprueba1 = array();
	}

	/**
	 * Gets an array of J047tDocumentoNormativo objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J047tDocumentoNormativosRelatedByCoAprueba1 from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J047tDocumentoNormativo[]
	 * @throws     PropelException
	 */
	public function getJ047tDocumentoNormativosRelatedByCoAprueba1($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoAprueba1 === null) {
			if ($this->isNew()) {
			   $this->collJ047tDocumentoNormativosRelatedByCoAprueba1 = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_APRUEBA1, $this->co_usuario);

				J047tDocumentoNormativoPeer::addSelectColumns($criteria);
				$this->collJ047tDocumentoNormativosRelatedByCoAprueba1 = J047tDocumentoNormativoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J047tDocumentoNormativoPeer::CO_APRUEBA1, $this->co_usuario);

				J047tDocumentoNormativoPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoAprueba1Criteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoAprueba1Criteria->equals($criteria)) {
					$this->collJ047tDocumentoNormativosRelatedByCoAprueba1 = J047tDocumentoNormativoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoAprueba1Criteria = $criteria;
		return $this->collJ047tDocumentoNormativosRelatedByCoAprueba1;
	}

	/**
	 * Returns the number of related J047tDocumentoNormativo objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J047tDocumentoNormativo objects.
	 * @throws     PropelException
	 */
	public function countJ047tDocumentoNormativosRelatedByCoAprueba1(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ047tDocumentoNormativosRelatedByCoAprueba1 === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_APRUEBA1, $this->co_usuario);

				$count = J047tDocumentoNormativoPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J047tDocumentoNormativoPeer::CO_APRUEBA1, $this->co_usuario);

				if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoAprueba1Criteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoAprueba1Criteria->equals($criteria)) {
					$count = J047tDocumentoNormativoPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ047tDocumentoNormativosRelatedByCoAprueba1);
				}
			} else {
				$count = count($this->collJ047tDocumentoNormativosRelatedByCoAprueba1);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J047tDocumentoNormativo object to this object
	 * through the J047tDocumentoNormativo foreign key attribute.
	 *
	 * @param      J047tDocumentoNormativo $l J047tDocumentoNormativo
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ047tDocumentoNormativoRelatedByCoAprueba1(J047tDocumentoNormativo $l)
	{
		if ($this->collJ047tDocumentoNormativosRelatedByCoAprueba1 === null) {
			$this->initJ047tDocumentoNormativosRelatedByCoAprueba1();
		}
		if (!in_array($l, $this->collJ047tDocumentoNormativosRelatedByCoAprueba1, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ047tDocumentoNormativosRelatedByCoAprueba1, $l);
			$l->setJ002tUsuarioRelatedByCoAprueba1($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J047tDocumentoNormativosRelatedByCoAprueba1 from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ047tDocumentoNormativosRelatedByCoAprueba1JoinJ049tTipoMarco($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoAprueba1 === null) {
			if ($this->isNew()) {
				$this->collJ047tDocumentoNormativosRelatedByCoAprueba1 = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_APRUEBA1, $this->co_usuario);

				$this->collJ047tDocumentoNormativosRelatedByCoAprueba1 = J047tDocumentoNormativoPeer::doSelectJoinJ049tTipoMarco($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J047tDocumentoNormativoPeer::CO_APRUEBA1, $this->co_usuario);

			if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoAprueba1Criteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoAprueba1Criteria->equals($criteria)) {
				$this->collJ047tDocumentoNormativosRelatedByCoAprueba1 = J047tDocumentoNormativoPeer::doSelectJoinJ049tTipoMarco($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoAprueba1Criteria = $criteria;

		return $this->collJ047tDocumentoNormativosRelatedByCoAprueba1;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J047tDocumentoNormativosRelatedByCoAprueba1 from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ047tDocumentoNormativosRelatedByCoAprueba1JoinJ048tEstadoDocumento($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoAprueba1 === null) {
			if ($this->isNew()) {
				$this->collJ047tDocumentoNormativosRelatedByCoAprueba1 = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_APRUEBA1, $this->co_usuario);

				$this->collJ047tDocumentoNormativosRelatedByCoAprueba1 = J047tDocumentoNormativoPeer::doSelectJoinJ048tEstadoDocumento($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J047tDocumentoNormativoPeer::CO_APRUEBA1, $this->co_usuario);

			if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoAprueba1Criteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoAprueba1Criteria->equals($criteria)) {
				$this->collJ047tDocumentoNormativosRelatedByCoAprueba1 = J047tDocumentoNormativoPeer::doSelectJoinJ048tEstadoDocumento($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoAprueba1Criteria = $criteria;

		return $this->collJ047tDocumentoNormativosRelatedByCoAprueba1;
	}

	/**
	 * Clears out the collJ047tDocumentoNormativosRelatedByCoAprueba2 collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ047tDocumentoNormativosRelatedByCoAprueba2()
	 */
	public function clearJ047tDocumentoNormativosRelatedByCoAprueba2()
	{
		$this->collJ047tDocumentoNormativosRelatedByCoAprueba2 = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ047tDocumentoNormativosRelatedByCoAprueba2 collection (array).
	 *
	 * By default this just sets the collJ047tDocumentoNormativosRelatedByCoAprueba2 collection to an empty array (like clearcollJ047tDocumentoNormativosRelatedByCoAprueba2());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ047tDocumentoNormativosRelatedByCoAprueba2()
	{
		$this->collJ047tDocumentoNormativosRelatedByCoAprueba2 = array();
	}

	/**
	 * Gets an array of J047tDocumentoNormativo objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J047tDocumentoNormativosRelatedByCoAprueba2 from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J047tDocumentoNormativo[]
	 * @throws     PropelException
	 */
	public function getJ047tDocumentoNormativosRelatedByCoAprueba2($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoAprueba2 === null) {
			if ($this->isNew()) {
			   $this->collJ047tDocumentoNormativosRelatedByCoAprueba2 = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_APRUEBA2, $this->co_usuario);

				J047tDocumentoNormativoPeer::addSelectColumns($criteria);
				$this->collJ047tDocumentoNormativosRelatedByCoAprueba2 = J047tDocumentoNormativoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J047tDocumentoNormativoPeer::CO_APRUEBA2, $this->co_usuario);

				J047tDocumentoNormativoPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoAprueba2Criteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoAprueba2Criteria->equals($criteria)) {
					$this->collJ047tDocumentoNormativosRelatedByCoAprueba2 = J047tDocumentoNormativoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoAprueba2Criteria = $criteria;
		return $this->collJ047tDocumentoNormativosRelatedByCoAprueba2;
	}

	/**
	 * Returns the number of related J047tDocumentoNormativo objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J047tDocumentoNormativo objects.
	 * @throws     PropelException
	 */
	public function countJ047tDocumentoNormativosRelatedByCoAprueba2(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ047tDocumentoNormativosRelatedByCoAprueba2 === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_APRUEBA2, $this->co_usuario);

				$count = J047tDocumentoNormativoPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J047tDocumentoNormativoPeer::CO_APRUEBA2, $this->co_usuario);

				if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoAprueba2Criteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoAprueba2Criteria->equals($criteria)) {
					$count = J047tDocumentoNormativoPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ047tDocumentoNormativosRelatedByCoAprueba2);
				}
			} else {
				$count = count($this->collJ047tDocumentoNormativosRelatedByCoAprueba2);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J047tDocumentoNormativo object to this object
	 * through the J047tDocumentoNormativo foreign key attribute.
	 *
	 * @param      J047tDocumentoNormativo $l J047tDocumentoNormativo
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ047tDocumentoNormativoRelatedByCoAprueba2(J047tDocumentoNormativo $l)
	{
		if ($this->collJ047tDocumentoNormativosRelatedByCoAprueba2 === null) {
			$this->initJ047tDocumentoNormativosRelatedByCoAprueba2();
		}
		if (!in_array($l, $this->collJ047tDocumentoNormativosRelatedByCoAprueba2, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ047tDocumentoNormativosRelatedByCoAprueba2, $l);
			$l->setJ002tUsuarioRelatedByCoAprueba2($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J047tDocumentoNormativosRelatedByCoAprueba2 from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ047tDocumentoNormativosRelatedByCoAprueba2JoinJ049tTipoMarco($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoAprueba2 === null) {
			if ($this->isNew()) {
				$this->collJ047tDocumentoNormativosRelatedByCoAprueba2 = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_APRUEBA2, $this->co_usuario);

				$this->collJ047tDocumentoNormativosRelatedByCoAprueba2 = J047tDocumentoNormativoPeer::doSelectJoinJ049tTipoMarco($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J047tDocumentoNormativoPeer::CO_APRUEBA2, $this->co_usuario);

			if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoAprueba2Criteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoAprueba2Criteria->equals($criteria)) {
				$this->collJ047tDocumentoNormativosRelatedByCoAprueba2 = J047tDocumentoNormativoPeer::doSelectJoinJ049tTipoMarco($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoAprueba2Criteria = $criteria;

		return $this->collJ047tDocumentoNormativosRelatedByCoAprueba2;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J047tDocumentoNormativosRelatedByCoAprueba2 from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ047tDocumentoNormativosRelatedByCoAprueba2JoinJ048tEstadoDocumento($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoAprueba2 === null) {
			if ($this->isNew()) {
				$this->collJ047tDocumentoNormativosRelatedByCoAprueba2 = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_APRUEBA2, $this->co_usuario);

				$this->collJ047tDocumentoNormativosRelatedByCoAprueba2 = J047tDocumentoNormativoPeer::doSelectJoinJ048tEstadoDocumento($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J047tDocumentoNormativoPeer::CO_APRUEBA2, $this->co_usuario);

			if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoAprueba2Criteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoAprueba2Criteria->equals($criteria)) {
				$this->collJ047tDocumentoNormativosRelatedByCoAprueba2 = J047tDocumentoNormativoPeer::doSelectJoinJ048tEstadoDocumento($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoAprueba2Criteria = $criteria;

		return $this->collJ047tDocumentoNormativosRelatedByCoAprueba2;
	}

	/**
	 * Clears out the collJ047tDocumentoNormativosRelatedByCoElimina1 collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ047tDocumentoNormativosRelatedByCoElimina1()
	 */
	public function clearJ047tDocumentoNormativosRelatedByCoElimina1()
	{
		$this->collJ047tDocumentoNormativosRelatedByCoElimina1 = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ047tDocumentoNormativosRelatedByCoElimina1 collection (array).
	 *
	 * By default this just sets the collJ047tDocumentoNormativosRelatedByCoElimina1 collection to an empty array (like clearcollJ047tDocumentoNormativosRelatedByCoElimina1());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ047tDocumentoNormativosRelatedByCoElimina1()
	{
		$this->collJ047tDocumentoNormativosRelatedByCoElimina1 = array();
	}

	/**
	 * Gets an array of J047tDocumentoNormativo objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J047tDocumentoNormativosRelatedByCoElimina1 from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J047tDocumentoNormativo[]
	 * @throws     PropelException
	 */
	public function getJ047tDocumentoNormativosRelatedByCoElimina1($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoElimina1 === null) {
			if ($this->isNew()) {
			   $this->collJ047tDocumentoNormativosRelatedByCoElimina1 = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_ELIMINA1, $this->co_usuario);

				J047tDocumentoNormativoPeer::addSelectColumns($criteria);
				$this->collJ047tDocumentoNormativosRelatedByCoElimina1 = J047tDocumentoNormativoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J047tDocumentoNormativoPeer::CO_ELIMINA1, $this->co_usuario);

				J047tDocumentoNormativoPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoElimina1Criteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoElimina1Criteria->equals($criteria)) {
					$this->collJ047tDocumentoNormativosRelatedByCoElimina1 = J047tDocumentoNormativoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoElimina1Criteria = $criteria;
		return $this->collJ047tDocumentoNormativosRelatedByCoElimina1;
	}

	/**
	 * Returns the number of related J047tDocumentoNormativo objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J047tDocumentoNormativo objects.
	 * @throws     PropelException
	 */
	public function countJ047tDocumentoNormativosRelatedByCoElimina1(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ047tDocumentoNormativosRelatedByCoElimina1 === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_ELIMINA1, $this->co_usuario);

				$count = J047tDocumentoNormativoPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J047tDocumentoNormativoPeer::CO_ELIMINA1, $this->co_usuario);

				if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoElimina1Criteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoElimina1Criteria->equals($criteria)) {
					$count = J047tDocumentoNormativoPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ047tDocumentoNormativosRelatedByCoElimina1);
				}
			} else {
				$count = count($this->collJ047tDocumentoNormativosRelatedByCoElimina1);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J047tDocumentoNormativo object to this object
	 * through the J047tDocumentoNormativo foreign key attribute.
	 *
	 * @param      J047tDocumentoNormativo $l J047tDocumentoNormativo
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ047tDocumentoNormativoRelatedByCoElimina1(J047tDocumentoNormativo $l)
	{
		if ($this->collJ047tDocumentoNormativosRelatedByCoElimina1 === null) {
			$this->initJ047tDocumentoNormativosRelatedByCoElimina1();
		}
		if (!in_array($l, $this->collJ047tDocumentoNormativosRelatedByCoElimina1, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ047tDocumentoNormativosRelatedByCoElimina1, $l);
			$l->setJ002tUsuarioRelatedByCoElimina1($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J047tDocumentoNormativosRelatedByCoElimina1 from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ047tDocumentoNormativosRelatedByCoElimina1JoinJ049tTipoMarco($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoElimina1 === null) {
			if ($this->isNew()) {
				$this->collJ047tDocumentoNormativosRelatedByCoElimina1 = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_ELIMINA1, $this->co_usuario);

				$this->collJ047tDocumentoNormativosRelatedByCoElimina1 = J047tDocumentoNormativoPeer::doSelectJoinJ049tTipoMarco($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J047tDocumentoNormativoPeer::CO_ELIMINA1, $this->co_usuario);

			if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoElimina1Criteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoElimina1Criteria->equals($criteria)) {
				$this->collJ047tDocumentoNormativosRelatedByCoElimina1 = J047tDocumentoNormativoPeer::doSelectJoinJ049tTipoMarco($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoElimina1Criteria = $criteria;

		return $this->collJ047tDocumentoNormativosRelatedByCoElimina1;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J047tDocumentoNormativosRelatedByCoElimina1 from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ047tDocumentoNormativosRelatedByCoElimina1JoinJ048tEstadoDocumento($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoElimina1 === null) {
			if ($this->isNew()) {
				$this->collJ047tDocumentoNormativosRelatedByCoElimina1 = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_ELIMINA1, $this->co_usuario);

				$this->collJ047tDocumentoNormativosRelatedByCoElimina1 = J047tDocumentoNormativoPeer::doSelectJoinJ048tEstadoDocumento($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J047tDocumentoNormativoPeer::CO_ELIMINA1, $this->co_usuario);

			if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoElimina1Criteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoElimina1Criteria->equals($criteria)) {
				$this->collJ047tDocumentoNormativosRelatedByCoElimina1 = J047tDocumentoNormativoPeer::doSelectJoinJ048tEstadoDocumento($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoElimina1Criteria = $criteria;

		return $this->collJ047tDocumentoNormativosRelatedByCoElimina1;
	}

	/**
	 * Clears out the collJ047tDocumentoNormativosRelatedByCoElimina2 collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ047tDocumentoNormativosRelatedByCoElimina2()
	 */
	public function clearJ047tDocumentoNormativosRelatedByCoElimina2()
	{
		$this->collJ047tDocumentoNormativosRelatedByCoElimina2 = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ047tDocumentoNormativosRelatedByCoElimina2 collection (array).
	 *
	 * By default this just sets the collJ047tDocumentoNormativosRelatedByCoElimina2 collection to an empty array (like clearcollJ047tDocumentoNormativosRelatedByCoElimina2());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ047tDocumentoNormativosRelatedByCoElimina2()
	{
		$this->collJ047tDocumentoNormativosRelatedByCoElimina2 = array();
	}

	/**
	 * Gets an array of J047tDocumentoNormativo objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J047tDocumentoNormativosRelatedByCoElimina2 from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J047tDocumentoNormativo[]
	 * @throws     PropelException
	 */
	public function getJ047tDocumentoNormativosRelatedByCoElimina2($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoElimina2 === null) {
			if ($this->isNew()) {
			   $this->collJ047tDocumentoNormativosRelatedByCoElimina2 = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_ELIMINA2, $this->co_usuario);

				J047tDocumentoNormativoPeer::addSelectColumns($criteria);
				$this->collJ047tDocumentoNormativosRelatedByCoElimina2 = J047tDocumentoNormativoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J047tDocumentoNormativoPeer::CO_ELIMINA2, $this->co_usuario);

				J047tDocumentoNormativoPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoElimina2Criteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoElimina2Criteria->equals($criteria)) {
					$this->collJ047tDocumentoNormativosRelatedByCoElimina2 = J047tDocumentoNormativoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoElimina2Criteria = $criteria;
		return $this->collJ047tDocumentoNormativosRelatedByCoElimina2;
	}

	/**
	 * Returns the number of related J047tDocumentoNormativo objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J047tDocumentoNormativo objects.
	 * @throws     PropelException
	 */
	public function countJ047tDocumentoNormativosRelatedByCoElimina2(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ047tDocumentoNormativosRelatedByCoElimina2 === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_ELIMINA2, $this->co_usuario);

				$count = J047tDocumentoNormativoPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J047tDocumentoNormativoPeer::CO_ELIMINA2, $this->co_usuario);

				if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoElimina2Criteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoElimina2Criteria->equals($criteria)) {
					$count = J047tDocumentoNormativoPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ047tDocumentoNormativosRelatedByCoElimina2);
				}
			} else {
				$count = count($this->collJ047tDocumentoNormativosRelatedByCoElimina2);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J047tDocumentoNormativo object to this object
	 * through the J047tDocumentoNormativo foreign key attribute.
	 *
	 * @param      J047tDocumentoNormativo $l J047tDocumentoNormativo
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ047tDocumentoNormativoRelatedByCoElimina2(J047tDocumentoNormativo $l)
	{
		if ($this->collJ047tDocumentoNormativosRelatedByCoElimina2 === null) {
			$this->initJ047tDocumentoNormativosRelatedByCoElimina2();
		}
		if (!in_array($l, $this->collJ047tDocumentoNormativosRelatedByCoElimina2, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ047tDocumentoNormativosRelatedByCoElimina2, $l);
			$l->setJ002tUsuarioRelatedByCoElimina2($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J047tDocumentoNormativosRelatedByCoElimina2 from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ047tDocumentoNormativosRelatedByCoElimina2JoinJ049tTipoMarco($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoElimina2 === null) {
			if ($this->isNew()) {
				$this->collJ047tDocumentoNormativosRelatedByCoElimina2 = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_ELIMINA2, $this->co_usuario);

				$this->collJ047tDocumentoNormativosRelatedByCoElimina2 = J047tDocumentoNormativoPeer::doSelectJoinJ049tTipoMarco($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J047tDocumentoNormativoPeer::CO_ELIMINA2, $this->co_usuario);

			if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoElimina2Criteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoElimina2Criteria->equals($criteria)) {
				$this->collJ047tDocumentoNormativosRelatedByCoElimina2 = J047tDocumentoNormativoPeer::doSelectJoinJ049tTipoMarco($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoElimina2Criteria = $criteria;

		return $this->collJ047tDocumentoNormativosRelatedByCoElimina2;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J047tDocumentoNormativosRelatedByCoElimina2 from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ047tDocumentoNormativosRelatedByCoElimina2JoinJ048tEstadoDocumento($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoElimina2 === null) {
			if ($this->isNew()) {
				$this->collJ047tDocumentoNormativosRelatedByCoElimina2 = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_ELIMINA2, $this->co_usuario);

				$this->collJ047tDocumentoNormativosRelatedByCoElimina2 = J047tDocumentoNormativoPeer::doSelectJoinJ048tEstadoDocumento($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J047tDocumentoNormativoPeer::CO_ELIMINA2, $this->co_usuario);

			if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoElimina2Criteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoElimina2Criteria->equals($criteria)) {
				$this->collJ047tDocumentoNormativosRelatedByCoElimina2 = J047tDocumentoNormativoPeer::doSelectJoinJ048tEstadoDocumento($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoElimina2Criteria = $criteria;

		return $this->collJ047tDocumentoNormativosRelatedByCoElimina2;
	}

	/**
	 * Clears out the collJ047tDocumentoNormativosRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ047tDocumentoNormativosRelatedByCoUsuarioCreated()
	 */
	public function clearJ047tDocumentoNormativosRelatedByCoUsuarioCreated()
	{
		$this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ047tDocumentoNormativosRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ047tDocumentoNormativosRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ047tDocumentoNormativosRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ047tDocumentoNormativosRelatedByCoUsuarioCreated()
	{
		$this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J047tDocumentoNormativo objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J047tDocumentoNormativosRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J047tDocumentoNormativo[]
	 * @throws     PropelException
	 */
	public function getJ047tDocumentoNormativosRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J047tDocumentoNormativoPeer::addSelectColumns($criteria);
				$this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated = J047tDocumentoNormativoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J047tDocumentoNormativoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J047tDocumentoNormativoPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated = J047tDocumentoNormativoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J047tDocumentoNormativo objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J047tDocumentoNormativo objects.
	 * @throws     PropelException
	 */
	public function countJ047tDocumentoNormativosRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J047tDocumentoNormativoPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J047tDocumentoNormativoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J047tDocumentoNormativoPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J047tDocumentoNormativo object to this object
	 * through the J047tDocumentoNormativo foreign key attribute.
	 *
	 * @param      J047tDocumentoNormativo $l J047tDocumentoNormativo
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ047tDocumentoNormativoRelatedByCoUsuarioCreated(J047tDocumentoNormativo $l)
	{
		if ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated === null) {
			$this->initJ047tDocumentoNormativosRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J047tDocumentoNormativosRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ047tDocumentoNormativosRelatedByCoUsuarioCreatedJoinJ049tTipoMarco($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated = J047tDocumentoNormativoPeer::doSelectJoinJ049tTipoMarco($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J047tDocumentoNormativoPeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated = J047tDocumentoNormativoPeer::doSelectJoinJ049tTipoMarco($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J047tDocumentoNormativosRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ047tDocumentoNormativosRelatedByCoUsuarioCreatedJoinJ048tEstadoDocumento($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated = J047tDocumentoNormativoPeer::doSelectJoinJ048tEstadoDocumento($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J047tDocumentoNormativoPeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated = J047tDocumentoNormativoPeer::doSelectJoinJ048tEstadoDocumento($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated;
	}

	/**
	 * Clears out the collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ047tDocumentoNormativosRelatedByCoUsuarioUpdated()
	 */
	public function clearJ047tDocumentoNormativosRelatedByCoUsuarioUpdated()
	{
		$this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated collection (array).
	 *
	 * By default this just sets the collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated collection to an empty array (like clearcollJ047tDocumentoNormativosRelatedByCoUsuarioUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ047tDocumentoNormativosRelatedByCoUsuarioUpdated()
	{
		$this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated = array();
	}

	/**
	 * Gets an array of J047tDocumentoNormativo objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J047tDocumentoNormativosRelatedByCoUsuarioUpdated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J047tDocumentoNormativo[]
	 * @throws     PropelException
	 */
	public function getJ047tDocumentoNormativosRelatedByCoUsuarioUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
			   $this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J047tDocumentoNormativoPeer::addSelectColumns($criteria);
				$this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated = J047tDocumentoNormativoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J047tDocumentoNormativoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J047tDocumentoNormativoPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated = J047tDocumentoNormativoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoUsuarioUpdatedCriteria = $criteria;
		return $this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated;
	}

	/**
	 * Returns the number of related J047tDocumentoNormativo objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J047tDocumentoNormativo objects.
	 * @throws     PropelException
	 */
	public function countJ047tDocumentoNormativosRelatedByCoUsuarioUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				$count = J047tDocumentoNormativoPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J047tDocumentoNormativoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$count = J047tDocumentoNormativoPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated);
				}
			} else {
				$count = count($this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J047tDocumentoNormativo object to this object
	 * through the J047tDocumentoNormativo foreign key attribute.
	 *
	 * @param      J047tDocumentoNormativo $l J047tDocumentoNormativo
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ047tDocumentoNormativoRelatedByCoUsuarioUpdated(J047tDocumentoNormativo $l)
	{
		if ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated === null) {
			$this->initJ047tDocumentoNormativosRelatedByCoUsuarioUpdated();
		}
		if (!in_array($l, $this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J047tDocumentoNormativosRelatedByCoUsuarioUpdated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ047tDocumentoNormativosRelatedByCoUsuarioUpdatedJoinJ049tTipoMarco($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
				$this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				$this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated = J047tDocumentoNormativoPeer::doSelectJoinJ049tTipoMarco($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J047tDocumentoNormativoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

			if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
				$this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated = J047tDocumentoNormativoPeer::doSelectJoinJ049tTipoMarco($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoUsuarioUpdatedCriteria = $criteria;

		return $this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J047tDocumentoNormativosRelatedByCoUsuarioUpdated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ047tDocumentoNormativosRelatedByCoUsuarioUpdatedJoinJ048tEstadoDocumento($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
				$this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated = array();
			} else {

				$criteria->add(J047tDocumentoNormativoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				$this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated = J047tDocumentoNormativoPeer::doSelectJoinJ048tEstadoDocumento($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J047tDocumentoNormativoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

			if (!isset($this->lastJ047tDocumentoNormativoRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ047tDocumentoNormativoRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
				$this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated = J047tDocumentoNormativoPeer::doSelectJoinJ048tEstadoDocumento($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ047tDocumentoNormativoRelatedByCoUsuarioUpdatedCriteria = $criteria;

		return $this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated;
	}

	/**
	 * Clears out the collJ048tEstadoDocumentosRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ048tEstadoDocumentosRelatedByCoUsuarioCreated()
	 */
	public function clearJ048tEstadoDocumentosRelatedByCoUsuarioCreated()
	{
		$this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ048tEstadoDocumentosRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ048tEstadoDocumentosRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ048tEstadoDocumentosRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ048tEstadoDocumentosRelatedByCoUsuarioCreated()
	{
		$this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J048tEstadoDocumento objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J048tEstadoDocumentosRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J048tEstadoDocumento[]
	 * @throws     PropelException
	 */
	public function getJ048tEstadoDocumentosRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J048tEstadoDocumentoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J048tEstadoDocumentoPeer::addSelectColumns($criteria);
				$this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated = J048tEstadoDocumentoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J048tEstadoDocumentoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J048tEstadoDocumentoPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ048tEstadoDocumentoRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ048tEstadoDocumentoRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated = J048tEstadoDocumentoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ048tEstadoDocumentoRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J048tEstadoDocumento objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J048tEstadoDocumento objects.
	 * @throws     PropelException
	 */
	public function countJ048tEstadoDocumentosRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J048tEstadoDocumentoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J048tEstadoDocumentoPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J048tEstadoDocumentoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ048tEstadoDocumentoRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ048tEstadoDocumentoRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J048tEstadoDocumentoPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J048tEstadoDocumento object to this object
	 * through the J048tEstadoDocumento foreign key attribute.
	 *
	 * @param      J048tEstadoDocumento $l J048tEstadoDocumento
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ048tEstadoDocumentoRelatedByCoUsuarioCreated(J048tEstadoDocumento $l)
	{
		if ($this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated === null) {
			$this->initJ048tEstadoDocumentosRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}

	/**
	 * Clears out the collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ048tEstadoDocumentosRelatedByCoUsuarioUpdated()
	 */
	public function clearJ048tEstadoDocumentosRelatedByCoUsuarioUpdated()
	{
		$this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated collection (array).
	 *
	 * By default this just sets the collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated collection to an empty array (like clearcollJ048tEstadoDocumentosRelatedByCoUsuarioUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ048tEstadoDocumentosRelatedByCoUsuarioUpdated()
	{
		$this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated = array();
	}

	/**
	 * Gets an array of J048tEstadoDocumento objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J048tEstadoDocumentosRelatedByCoUsuarioUpdated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J048tEstadoDocumento[]
	 * @throws     PropelException
	 */
	public function getJ048tEstadoDocumentosRelatedByCoUsuarioUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
			   $this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated = array();
			} else {

				$criteria->add(J048tEstadoDocumentoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J048tEstadoDocumentoPeer::addSelectColumns($criteria);
				$this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated = J048tEstadoDocumentoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J048tEstadoDocumentoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J048tEstadoDocumentoPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ048tEstadoDocumentoRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ048tEstadoDocumentoRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated = J048tEstadoDocumentoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ048tEstadoDocumentoRelatedByCoUsuarioUpdatedCriteria = $criteria;
		return $this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated;
	}

	/**
	 * Returns the number of related J048tEstadoDocumento objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J048tEstadoDocumento objects.
	 * @throws     PropelException
	 */
	public function countJ048tEstadoDocumentosRelatedByCoUsuarioUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J048tEstadoDocumentoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				$count = J048tEstadoDocumentoPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J048tEstadoDocumentoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				if (!isset($this->lastJ048tEstadoDocumentoRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ048tEstadoDocumentoRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$count = J048tEstadoDocumentoPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated);
				}
			} else {
				$count = count($this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J048tEstadoDocumento object to this object
	 * through the J048tEstadoDocumento foreign key attribute.
	 *
	 * @param      J048tEstadoDocumento $l J048tEstadoDocumento
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ048tEstadoDocumentoRelatedByCoUsuarioUpdated(J048tEstadoDocumento $l)
	{
		if ($this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated === null) {
			$this->initJ048tEstadoDocumentosRelatedByCoUsuarioUpdated();
		}
		if (!in_array($l, $this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdated($this);
		}
	}

	/**
	 * Clears out the collJ049tTipoMarcosRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ049tTipoMarcosRelatedByCoUsuarioCreated()
	 */
	public function clearJ049tTipoMarcosRelatedByCoUsuarioCreated()
	{
		$this->collJ049tTipoMarcosRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ049tTipoMarcosRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ049tTipoMarcosRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ049tTipoMarcosRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ049tTipoMarcosRelatedByCoUsuarioCreated()
	{
		$this->collJ049tTipoMarcosRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J049tTipoMarco objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J049tTipoMarcosRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J049tTipoMarco[]
	 * @throws     PropelException
	 */
	public function getJ049tTipoMarcosRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ049tTipoMarcosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ049tTipoMarcosRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J049tTipoMarcoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J049tTipoMarcoPeer::addSelectColumns($criteria);
				$this->collJ049tTipoMarcosRelatedByCoUsuarioCreated = J049tTipoMarcoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J049tTipoMarcoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J049tTipoMarcoPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ049tTipoMarcoRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ049tTipoMarcoRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ049tTipoMarcosRelatedByCoUsuarioCreated = J049tTipoMarcoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ049tTipoMarcoRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ049tTipoMarcosRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J049tTipoMarco objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J049tTipoMarco objects.
	 * @throws     PropelException
	 */
	public function countJ049tTipoMarcosRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ049tTipoMarcosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J049tTipoMarcoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J049tTipoMarcoPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J049tTipoMarcoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ049tTipoMarcoRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ049tTipoMarcoRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J049tTipoMarcoPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ049tTipoMarcosRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ049tTipoMarcosRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J049tTipoMarco object to this object
	 * through the J049tTipoMarco foreign key attribute.
	 *
	 * @param      J049tTipoMarco $l J049tTipoMarco
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ049tTipoMarcoRelatedByCoUsuarioCreated(J049tTipoMarco $l)
	{
		if ($this->collJ049tTipoMarcosRelatedByCoUsuarioCreated === null) {
			$this->initJ049tTipoMarcosRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ049tTipoMarcosRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ049tTipoMarcosRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}

	/**
	 * Clears out the collJ049tTipoMarcosRelatedByCoUsuarioUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ049tTipoMarcosRelatedByCoUsuarioUpdated()
	 */
	public function clearJ049tTipoMarcosRelatedByCoUsuarioUpdated()
	{
		$this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ049tTipoMarcosRelatedByCoUsuarioUpdated collection (array).
	 *
	 * By default this just sets the collJ049tTipoMarcosRelatedByCoUsuarioUpdated collection to an empty array (like clearcollJ049tTipoMarcosRelatedByCoUsuarioUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ049tTipoMarcosRelatedByCoUsuarioUpdated()
	{
		$this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated = array();
	}

	/**
	 * Gets an array of J049tTipoMarco objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J049tTipoMarcosRelatedByCoUsuarioUpdated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J049tTipoMarco[]
	 * @throws     PropelException
	 */
	public function getJ049tTipoMarcosRelatedByCoUsuarioUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
			   $this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated = array();
			} else {

				$criteria->add(J049tTipoMarcoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J049tTipoMarcoPeer::addSelectColumns($criteria);
				$this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated = J049tTipoMarcoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J049tTipoMarcoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J049tTipoMarcoPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ049tTipoMarcoRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ049tTipoMarcoRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated = J049tTipoMarcoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ049tTipoMarcoRelatedByCoUsuarioUpdatedCriteria = $criteria;
		return $this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated;
	}

	/**
	 * Returns the number of related J049tTipoMarco objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J049tTipoMarco objects.
	 * @throws     PropelException
	 */
	public function countJ049tTipoMarcosRelatedByCoUsuarioUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J049tTipoMarcoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				$count = J049tTipoMarcoPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J049tTipoMarcoPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				if (!isset($this->lastJ049tTipoMarcoRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ049tTipoMarcoRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$count = J049tTipoMarcoPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated);
				}
			} else {
				$count = count($this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J049tTipoMarco object to this object
	 * through the J049tTipoMarco foreign key attribute.
	 *
	 * @param      J049tTipoMarco $l J049tTipoMarco
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ049tTipoMarcoRelatedByCoUsuarioUpdated(J049tTipoMarco $l)
	{
		if ($this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated === null) {
			$this->initJ049tTipoMarcosRelatedByCoUsuarioUpdated();
		}
		if (!in_array($l, $this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdated($this);
		}
	}

	/**
	 * Clears out the collJ050tInformeMarcosRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ050tInformeMarcosRelatedByCoUsuarioCreated()
	 */
	public function clearJ050tInformeMarcosRelatedByCoUsuarioCreated()
	{
		$this->collJ050tInformeMarcosRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ050tInformeMarcosRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ050tInformeMarcosRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ050tInformeMarcosRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ050tInformeMarcosRelatedByCoUsuarioCreated()
	{
		$this->collJ050tInformeMarcosRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J050tInformeMarco objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J050tInformeMarcosRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J050tInformeMarco[]
	 * @throws     PropelException
	 */
	public function getJ050tInformeMarcosRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ050tInformeMarcosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ050tInformeMarcosRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J050tInformeMarcoPeer::addSelectColumns($criteria);
				$this->collJ050tInformeMarcosRelatedByCoUsuarioCreated = J050tInformeMarcoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J050tInformeMarcoPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ050tInformeMarcoRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ050tInformeMarcoRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ050tInformeMarcosRelatedByCoUsuarioCreated = J050tInformeMarcoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ050tInformeMarcoRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ050tInformeMarcosRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J050tInformeMarco objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J050tInformeMarco objects.
	 * @throws     PropelException
	 */
	public function countJ050tInformeMarcosRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ050tInformeMarcosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J050tInformeMarcoPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ050tInformeMarcoRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ050tInformeMarcoRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J050tInformeMarcoPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ050tInformeMarcosRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ050tInformeMarcosRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J050tInformeMarco object to this object
	 * through the J050tInformeMarco foreign key attribute.
	 *
	 * @param      J050tInformeMarco $l J050tInformeMarco
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ050tInformeMarcoRelatedByCoUsuarioCreated(J050tInformeMarco $l)
	{
		if ($this->collJ050tInformeMarcosRelatedByCoUsuarioCreated === null) {
			$this->initJ050tInformeMarcosRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ050tInformeMarcosRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ050tInformeMarcosRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J050tInformeMarcosRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ050tInformeMarcosRelatedByCoUsuarioCreatedJoinJ051tTipoRevision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ050tInformeMarcosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ050tInformeMarcosRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ050tInformeMarcosRelatedByCoUsuarioCreated = J050tInformeMarcoPeer::doSelectJoinJ051tTipoRevision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ050tInformeMarcoRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ050tInformeMarcoRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ050tInformeMarcosRelatedByCoUsuarioCreated = J050tInformeMarcoPeer::doSelectJoinJ051tTipoRevision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ050tInformeMarcoRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ050tInformeMarcosRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J050tInformeMarcosRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ050tInformeMarcosRelatedByCoUsuarioCreatedJoinJ046tMarcoNormativo($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ050tInformeMarcosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ050tInformeMarcosRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ050tInformeMarcosRelatedByCoUsuarioCreated = J050tInformeMarcoPeer::doSelectJoinJ046tMarcoNormativo($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ050tInformeMarcoRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ050tInformeMarcoRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ050tInformeMarcosRelatedByCoUsuarioCreated = J050tInformeMarcoPeer::doSelectJoinJ046tMarcoNormativo($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ050tInformeMarcoRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ050tInformeMarcosRelatedByCoUsuarioCreated;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J050tInformeMarcosRelatedByCoUsuarioCreated from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ050tInformeMarcosRelatedByCoUsuarioCreatedJoinJ052tTipoJustificacion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ050tInformeMarcosRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$this->collJ050tInformeMarcosRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$this->collJ050tInformeMarcosRelatedByCoUsuarioCreated = J050tInformeMarcoPeer::doSelectJoinJ052tTipoJustificacion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_CREATED, $this->co_usuario);

			if (!isset($this->lastJ050tInformeMarcoRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ050tInformeMarcoRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
				$this->collJ050tInformeMarcosRelatedByCoUsuarioCreated = J050tInformeMarcoPeer::doSelectJoinJ052tTipoJustificacion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ050tInformeMarcoRelatedByCoUsuarioCreatedCriteria = $criteria;

		return $this->collJ050tInformeMarcosRelatedByCoUsuarioCreated;
	}

	/**
	 * Clears out the collJ050tInformeMarcosRelatedByCoUsuarioUpdate collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ050tInformeMarcosRelatedByCoUsuarioUpdate()
	 */
	public function clearJ050tInformeMarcosRelatedByCoUsuarioUpdate()
	{
		$this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ050tInformeMarcosRelatedByCoUsuarioUpdate collection (array).
	 *
	 * By default this just sets the collJ050tInformeMarcosRelatedByCoUsuarioUpdate collection to an empty array (like clearcollJ050tInformeMarcosRelatedByCoUsuarioUpdate());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ050tInformeMarcosRelatedByCoUsuarioUpdate()
	{
		$this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate = array();
	}

	/**
	 * Gets an array of J050tInformeMarco objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J050tInformeMarcosRelatedByCoUsuarioUpdate from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J050tInformeMarco[]
	 * @throws     PropelException
	 */
	public function getJ050tInformeMarcosRelatedByCoUsuarioUpdate($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
			   $this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				J050tInformeMarcoPeer::addSelectColumns($criteria);
				$this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate = J050tInformeMarcoPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				J050tInformeMarcoPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ050tInformeMarcoRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ050tInformeMarcoRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
					$this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate = J050tInformeMarcoPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ050tInformeMarcoRelatedByCoUsuarioUpdateCriteria = $criteria;
		return $this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate;
	}

	/**
	 * Returns the number of related J050tInformeMarco objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J050tInformeMarco objects.
	 * @throws     PropelException
	 */
	public function countJ050tInformeMarcosRelatedByCoUsuarioUpdate(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$count = J050tInformeMarcoPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				if (!isset($this->lastJ050tInformeMarcoRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ050tInformeMarcoRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
					$count = J050tInformeMarcoPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate);
				}
			} else {
				$count = count($this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J050tInformeMarco object to this object
	 * through the J050tInformeMarco foreign key attribute.
	 *
	 * @param      J050tInformeMarco $l J050tInformeMarco
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ050tInformeMarcoRelatedByCoUsuarioUpdate(J050tInformeMarco $l)
	{
		if ($this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate === null) {
			$this->initJ050tInformeMarcosRelatedByCoUsuarioUpdate();
		}
		if (!in_array($l, $this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdate($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J050tInformeMarcosRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ050tInformeMarcosRelatedByCoUsuarioUpdateJoinJ051tTipoRevision($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate = J050tInformeMarcoPeer::doSelectJoinJ051tTipoRevision($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ050tInformeMarcoRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ050tInformeMarcoRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate = J050tInformeMarcoPeer::doSelectJoinJ051tTipoRevision($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ050tInformeMarcoRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J050tInformeMarcosRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ050tInformeMarcosRelatedByCoUsuarioUpdateJoinJ046tMarcoNormativo($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate = J050tInformeMarcoPeer::doSelectJoinJ046tMarcoNormativo($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ050tInformeMarcoRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ050tInformeMarcoRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate = J050tInformeMarcoPeer::doSelectJoinJ046tMarcoNormativo($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ050tInformeMarcoRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this J002tUsuario is new, it will return
	 * an empty collection; or if this J002tUsuario has previously
	 * been saved, it will retrieve related J050tInformeMarcosRelatedByCoUsuarioUpdate from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in J002tUsuario.
	 */
	public function getJ050tInformeMarcosRelatedByCoUsuarioUpdateJoinJ052tTipoJustificacion($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate === null) {
			if ($this->isNew()) {
				$this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate = array();
			} else {

				$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_UPDATE, $this->co_usuario);

				$this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate = J050tInformeMarcoPeer::doSelectJoinJ052tTipoJustificacion($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(J050tInformeMarcoPeer::CO_USUARIO_UPDATE, $this->co_usuario);

			if (!isset($this->lastJ050tInformeMarcoRelatedByCoUsuarioUpdateCriteria) || !$this->lastJ050tInformeMarcoRelatedByCoUsuarioUpdateCriteria->equals($criteria)) {
				$this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate = J050tInformeMarcoPeer::doSelectJoinJ052tTipoJustificacion($criteria, $con, $join_behavior);
			}
		}
		$this->lastJ050tInformeMarcoRelatedByCoUsuarioUpdateCriteria = $criteria;

		return $this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate;
	}

	/**
	 * Clears out the collJ051tTipoRevisionsRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ051tTipoRevisionsRelatedByCoUsuarioCreated()
	 */
	public function clearJ051tTipoRevisionsRelatedByCoUsuarioCreated()
	{
		$this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ051tTipoRevisionsRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ051tTipoRevisionsRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ051tTipoRevisionsRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ051tTipoRevisionsRelatedByCoUsuarioCreated()
	{
		$this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J051tTipoRevision objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J051tTipoRevisionsRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J051tTipoRevision[]
	 * @throws     PropelException
	 */
	public function getJ051tTipoRevisionsRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J051tTipoRevisionPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J051tTipoRevisionPeer::addSelectColumns($criteria);
				$this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated = J051tTipoRevisionPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J051tTipoRevisionPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J051tTipoRevisionPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ051tTipoRevisionRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ051tTipoRevisionRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated = J051tTipoRevisionPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ051tTipoRevisionRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J051tTipoRevision objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J051tTipoRevision objects.
	 * @throws     PropelException
	 */
	public function countJ051tTipoRevisionsRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J051tTipoRevisionPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J051tTipoRevisionPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J051tTipoRevisionPeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ051tTipoRevisionRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ051tTipoRevisionRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J051tTipoRevisionPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J051tTipoRevision object to this object
	 * through the J051tTipoRevision foreign key attribute.
	 *
	 * @param      J051tTipoRevision $l J051tTipoRevision
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ051tTipoRevisionRelatedByCoUsuarioCreated(J051tTipoRevision $l)
	{
		if ($this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated === null) {
			$this->initJ051tTipoRevisionsRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}

	/**
	 * Clears out the collJ051tTipoRevisionsRelatedByCoUsuarioUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ051tTipoRevisionsRelatedByCoUsuarioUpdated()
	 */
	public function clearJ051tTipoRevisionsRelatedByCoUsuarioUpdated()
	{
		$this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ051tTipoRevisionsRelatedByCoUsuarioUpdated collection (array).
	 *
	 * By default this just sets the collJ051tTipoRevisionsRelatedByCoUsuarioUpdated collection to an empty array (like clearcollJ051tTipoRevisionsRelatedByCoUsuarioUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ051tTipoRevisionsRelatedByCoUsuarioUpdated()
	{
		$this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated = array();
	}

	/**
	 * Gets an array of J051tTipoRevision objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J051tTipoRevisionsRelatedByCoUsuarioUpdated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J051tTipoRevision[]
	 * @throws     PropelException
	 */
	public function getJ051tTipoRevisionsRelatedByCoUsuarioUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
			   $this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated = array();
			} else {

				$criteria->add(J051tTipoRevisionPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J051tTipoRevisionPeer::addSelectColumns($criteria);
				$this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated = J051tTipoRevisionPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J051tTipoRevisionPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J051tTipoRevisionPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ051tTipoRevisionRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ051tTipoRevisionRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated = J051tTipoRevisionPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ051tTipoRevisionRelatedByCoUsuarioUpdatedCriteria = $criteria;
		return $this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated;
	}

	/**
	 * Returns the number of related J051tTipoRevision objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J051tTipoRevision objects.
	 * @throws     PropelException
	 */
	public function countJ051tTipoRevisionsRelatedByCoUsuarioUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J051tTipoRevisionPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				$count = J051tTipoRevisionPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J051tTipoRevisionPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				if (!isset($this->lastJ051tTipoRevisionRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ051tTipoRevisionRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$count = J051tTipoRevisionPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated);
				}
			} else {
				$count = count($this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J051tTipoRevision object to this object
	 * through the J051tTipoRevision foreign key attribute.
	 *
	 * @param      J051tTipoRevision $l J051tTipoRevision
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ051tTipoRevisionRelatedByCoUsuarioUpdated(J051tTipoRevision $l)
	{
		if ($this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated === null) {
			$this->initJ051tTipoRevisionsRelatedByCoUsuarioUpdated();
		}
		if (!in_array($l, $this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdated($this);
		}
	}

	/**
	 * Clears out the collJ052tTipoJustificacionsRelatedByCoUsuarioCreated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ052tTipoJustificacionsRelatedByCoUsuarioCreated()
	 */
	public function clearJ052tTipoJustificacionsRelatedByCoUsuarioCreated()
	{
		$this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ052tTipoJustificacionsRelatedByCoUsuarioCreated collection (array).
	 *
	 * By default this just sets the collJ052tTipoJustificacionsRelatedByCoUsuarioCreated collection to an empty array (like clearcollJ052tTipoJustificacionsRelatedByCoUsuarioCreated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ052tTipoJustificacionsRelatedByCoUsuarioCreated()
	{
		$this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated = array();
	}

	/**
	 * Gets an array of J052tTipoJustificacion objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J052tTipoJustificacionsRelatedByCoUsuarioCreated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J052tTipoJustificacion[]
	 * @throws     PropelException
	 */
	public function getJ052tTipoJustificacionsRelatedByCoUsuarioCreated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
			   $this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated = array();
			} else {

				$criteria->add(J052tTipoJustificacionPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J052tTipoJustificacionPeer::addSelectColumns($criteria);
				$this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated = J052tTipoJustificacionPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J052tTipoJustificacionPeer::CO_USUARIO_CREATED, $this->co_usuario);

				J052tTipoJustificacionPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ052tTipoJustificacionRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ052tTipoJustificacionRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated = J052tTipoJustificacionPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ052tTipoJustificacionRelatedByCoUsuarioCreatedCriteria = $criteria;
		return $this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated;
	}

	/**
	 * Returns the number of related J052tTipoJustificacion objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J052tTipoJustificacion objects.
	 * @throws     PropelException
	 */
	public function countJ052tTipoJustificacionsRelatedByCoUsuarioCreated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J052tTipoJustificacionPeer::CO_USUARIO_CREATED, $this->co_usuario);

				$count = J052tTipoJustificacionPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J052tTipoJustificacionPeer::CO_USUARIO_CREATED, $this->co_usuario);

				if (!isset($this->lastJ052tTipoJustificacionRelatedByCoUsuarioCreatedCriteria) || !$this->lastJ052tTipoJustificacionRelatedByCoUsuarioCreatedCriteria->equals($criteria)) {
					$count = J052tTipoJustificacionPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated);
				}
			} else {
				$count = count($this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J052tTipoJustificacion object to this object
	 * through the J052tTipoJustificacion foreign key attribute.
	 *
	 * @param      J052tTipoJustificacion $l J052tTipoJustificacion
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ052tTipoJustificacionRelatedByCoUsuarioCreated(J052tTipoJustificacion $l)
	{
		if ($this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated === null) {
			$this->initJ052tTipoJustificacionsRelatedByCoUsuarioCreated();
		}
		if (!in_array($l, $this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioCreated($this);
		}
	}

	/**
	 * Clears out the collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addJ052tTipoJustificacionsRelatedByCoUsuarioUpdated()
	 */
	public function clearJ052tTipoJustificacionsRelatedByCoUsuarioUpdated()
	{
		$this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated collection (array).
	 *
	 * By default this just sets the collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated collection to an empty array (like clearcollJ052tTipoJustificacionsRelatedByCoUsuarioUpdated());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initJ052tTipoJustificacionsRelatedByCoUsuarioUpdated()
	{
		$this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated = array();
	}

	/**
	 * Gets an array of J052tTipoJustificacion objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this J002tUsuario has previously been saved, it will retrieve
	 * related J052tTipoJustificacionsRelatedByCoUsuarioUpdated from storage. If this J002tUsuario is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array J052tTipoJustificacion[]
	 * @throws     PropelException
	 */
	public function getJ052tTipoJustificacionsRelatedByCoUsuarioUpdated($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
			   $this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated = array();
			} else {

				$criteria->add(J052tTipoJustificacionPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J052tTipoJustificacionPeer::addSelectColumns($criteria);
				$this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated = J052tTipoJustificacionPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(J052tTipoJustificacionPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				J052tTipoJustificacionPeer::addSelectColumns($criteria);
				if (!isset($this->lastJ052tTipoJustificacionRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ052tTipoJustificacionRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated = J052tTipoJustificacionPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastJ052tTipoJustificacionRelatedByCoUsuarioUpdatedCriteria = $criteria;
		return $this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated;
	}

	/**
	 * Returns the number of related J052tTipoJustificacion objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related J052tTipoJustificacion objects.
	 * @throws     PropelException
	 */
	public function countJ052tTipoJustificacionsRelatedByCoUsuarioUpdated(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(J002tUsuarioPeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(J052tTipoJustificacionPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				$count = J052tTipoJustificacionPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(J052tTipoJustificacionPeer::CO_USUARIO_UPDATED, $this->co_usuario);

				if (!isset($this->lastJ052tTipoJustificacionRelatedByCoUsuarioUpdatedCriteria) || !$this->lastJ052tTipoJustificacionRelatedByCoUsuarioUpdatedCriteria->equals($criteria)) {
					$count = J052tTipoJustificacionPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated);
				}
			} else {
				$count = count($this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a J052tTipoJustificacion object to this object
	 * through the J052tTipoJustificacion foreign key attribute.
	 *
	 * @param      J052tTipoJustificacion $l J052tTipoJustificacion
	 * @return     void
	 * @throws     PropelException
	 */
	public function addJ052tTipoJustificacionRelatedByCoUsuarioUpdated(J052tTipoJustificacion $l)
	{
		if ($this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated === null) {
			$this->initJ052tTipoJustificacionsRelatedByCoUsuarioUpdated();
		}
		if (!in_array($l, $this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated, true)) { // only add it if the **same** object is not already associated
			array_push($this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated, $l);
			$l->setJ002tUsuarioRelatedByCoUsuarioUpdated($this);
		}
	}

	/**
	 * Resets all collections of referencing foreign keys.
	 *
	 * This method is a user-space workaround for PHP's inability to garbage collect objects
	 * with circular references.  This is currently necessary when using Propel in certain
	 * daemon or large-volumne/high-memory operations.
	 *
	 * @param      boolean $deep Whether to also clear the references on all associated objects.
	 */
	public function clearAllReferences($deep = false)
	{
		if ($deep) {
			if ($this->collC024tRecursosRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collC024tRecursosRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collC024tRecursosRelatedByCoUsuarioUpdated) {
				foreach ((array) $this->collC024tRecursosRelatedByCoUsuarioUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ005tTransaccions) {
				foreach ((array) $this->collJ005tTransaccions as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ010tEvaluacions) {
				foreach ((array) $this->collJ010tEvaluacions as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ012tCronogramas) {
				foreach ((array) $this->collJ012tCronogramas as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ016tForensesRelatedByCoUsuarioApertura) {
				foreach ((array) $this->collJ016tForensesRelatedByCoUsuarioApertura as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ016tForensesRelatedByCoUsuarioCierre) {
				foreach ((array) $this->collJ016tForensesRelatedByCoUsuarioCierre as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ016tForensesRelatedByCoUsuarioUpdate) {
				foreach ((array) $this->collJ016tForensesRelatedByCoUsuarioUpdate as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated) {
				foreach ((array) $this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ018tInformeForensesRelatedByCoRevisa) {
				foreach ((array) $this->collJ018tInformeForensesRelatedByCoRevisa as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ018tInformeForensesRelatedByCoAprueba) {
				foreach ((array) $this->collJ018tInformeForensesRelatedByCoAprueba as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ018tInformeForensesRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ018tInformeForensesRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ018tInformeForensesRelatedByCoUsuarioUpdate) {
				foreach ((array) $this->collJ018tInformeForensesRelatedByCoUsuarioUpdate as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ019tParticipantess) {
				foreach ((array) $this->collJ019tParticipantess as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ020tActaAccsRelatedByCoElabora) {
				foreach ((array) $this->collJ020tActaAccsRelatedByCoElabora as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ020tActaAccsRelatedByCoDestruye) {
				foreach ((array) $this->collJ020tActaAccsRelatedByCoDestruye as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ020tActaAccsRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ020tActaAccsRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ020tActaAccsRelatedByCoUsuarioUpdate) {
				foreach ((array) $this->collJ020tActaAccsRelatedByCoUsuarioUpdate as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ021tActaAiesRelatedByCoElabora) {
				foreach ((array) $this->collJ021tActaAiesRelatedByCoElabora as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ021tActaAiesRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ021tActaAiesRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ021tActaAiesRelatedByCoUsuarioUpdate) {
				foreach ((array) $this->collJ021tActaAiesRelatedByCoUsuarioUpdate as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ022tActaAniesRelatedByCoElabora) {
				foreach ((array) $this->collJ022tActaAniesRelatedByCoElabora as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ022tActaAniesRelatedByCoCustodioNiega) {
				foreach ((array) $this->collJ022tActaAniesRelatedByCoCustodioNiega as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ022tActaAniesRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ022tActaAniesRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ022tActaAniesRelatedByCoUsuarioUpdate) {
				foreach ((array) $this->collJ022tActaAniesRelatedByCoUsuarioUpdate as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ023tEvidenciasRelatedByCoRegistro) {
				foreach ((array) $this->collJ023tEvidenciasRelatedByCoRegistro as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ023tEvidenciasRelatedByCoColecta) {
				foreach ((array) $this->collJ023tEvidenciasRelatedByCoColecta as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ023tEvidenciasRelatedByCoCustodioSti) {
				foreach ((array) $this->collJ023tEvidenciasRelatedByCoCustodioSti as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ023tEvidenciasRelatedByCoUpdateAt) {
				foreach ((array) $this->collJ023tEvidenciasRelatedByCoUpdateAt as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated) {
				foreach ((array) $this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated) {
				foreach ((array) $this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ027tLugarSegurosRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ027tLugarSegurosRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated) {
				foreach ((array) $this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ028tRepositoriosRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ028tRepositoriosRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ028tRepositoriosRelatedByCoUsuarioUpdated) {
				foreach ((array) $this->collJ028tRepositoriosRelatedByCoUsuarioUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ030tInformeRecomendacionessRelatedByCoRevisa) {
				foreach ((array) $this->collJ030tInformeRecomendacionessRelatedByCoRevisa as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ030tInformeRecomendacionessRelatedByCoAprueba) {
				foreach ((array) $this->collJ030tInformeRecomendacionessRelatedByCoAprueba as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate) {
				foreach ((array) $this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar) {
				foreach ((array) $this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ031tAccionRecomendadasRelatedByCoCreatedAt) {
				foreach ((array) $this->collJ031tAccionRecomendadasRelatedByCoCreatedAt as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ031tAccionRecomendadasRelatedByCoUpdateAt) {
				foreach ((array) $this->collJ031tAccionRecomendadasRelatedByCoUpdateAt as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ034tIncidentesRelatedByCoUsuarioApertura) {
				foreach ((array) $this->collJ034tIncidentesRelatedByCoUsuarioApertura as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ034tIncidentesRelatedByCoUsuarioEscala) {
				foreach ((array) $this->collJ034tIncidentesRelatedByCoUsuarioEscala as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ034tIncidentesRelatedByCoUsuarioCierre) {
				foreach ((array) $this->collJ034tIncidentesRelatedByCoUsuarioCierre as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ034tIncidentesRelatedByCoUsuarioUpdate) {
				foreach ((array) $this->collJ034tIncidentesRelatedByCoUsuarioUpdate as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated) {
				foreach ((array) $this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ047tDocumentoNormativosRelatedByCoAprueba1) {
				foreach ((array) $this->collJ047tDocumentoNormativosRelatedByCoAprueba1 as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ047tDocumentoNormativosRelatedByCoAprueba2) {
				foreach ((array) $this->collJ047tDocumentoNormativosRelatedByCoAprueba2 as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ047tDocumentoNormativosRelatedByCoElimina1) {
				foreach ((array) $this->collJ047tDocumentoNormativosRelatedByCoElimina1 as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ047tDocumentoNormativosRelatedByCoElimina2) {
				foreach ((array) $this->collJ047tDocumentoNormativosRelatedByCoElimina2 as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated) {
				foreach ((array) $this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated) {
				foreach ((array) $this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ049tTipoMarcosRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ049tTipoMarcosRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated) {
				foreach ((array) $this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ050tInformeMarcosRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ050tInformeMarcosRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate) {
				foreach ((array) $this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated) {
				foreach ((array) $this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated) {
				foreach ((array) $this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated) {
				foreach ((array) $this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated as $o) {
					$o->clearAllReferences($deep);
				}
			}
		} // if ($deep)

		$this->collC024tRecursosRelatedByCoUsuarioCreated = null;
		$this->collC024tRecursosRelatedByCoUsuarioUpdated = null;
		$this->collJ005tTransaccions = null;
		$this->collJ010tEvaluacions = null;
		$this->collJ012tCronogramas = null;
		$this->collJ016tForensesRelatedByCoUsuarioApertura = null;
		$this->collJ016tForensesRelatedByCoUsuarioCierre = null;
		$this->collJ016tForensesRelatedByCoUsuarioUpdate = null;
		$this->collJ017tAlcanceForensesRelatedByCoUsuarioCreated = null;
		$this->collJ017tAlcanceForensesRelatedByCoUsuarioUpdated = null;
		$this->collJ018tInformeForensesRelatedByCoRevisa = null;
		$this->collJ018tInformeForensesRelatedByCoAprueba = null;
		$this->collJ018tInformeForensesRelatedByCoUsuarioCreated = null;
		$this->collJ018tInformeForensesRelatedByCoUsuarioUpdate = null;
		$this->collJ019tParticipantess = null;
		$this->collJ020tActaAccsRelatedByCoElabora = null;
		$this->collJ020tActaAccsRelatedByCoDestruye = null;
		$this->collJ020tActaAccsRelatedByCoUsuarioCreated = null;
		$this->collJ020tActaAccsRelatedByCoUsuarioUpdate = null;
		$this->collJ021tActaAiesRelatedByCoElabora = null;
		$this->collJ021tActaAiesRelatedByCoUsuarioCreated = null;
		$this->collJ021tActaAiesRelatedByCoUsuarioUpdate = null;
		$this->collJ022tActaAniesRelatedByCoElabora = null;
		$this->collJ022tActaAniesRelatedByCoCustodioNiega = null;
		$this->collJ022tActaAniesRelatedByCoUsuarioCreated = null;
		$this->collJ022tActaAniesRelatedByCoUsuarioUpdate = null;
		$this->collJ023tEvidenciasRelatedByCoRegistro = null;
		$this->collJ023tEvidenciasRelatedByCoColecta = null;
		$this->collJ023tEvidenciasRelatedByCoCustodioSti = null;
		$this->collJ023tEvidenciasRelatedByCoUpdateAt = null;
		$this->collJ025tTipoEvidenciasRelatedByCoUsuarioCreated = null;
		$this->collJ025tTipoEvidenciasRelatedByCoUsuarioUpdated = null;
		$this->collJ026tEstadoEvidenciasRelatedByCoUsuarioCreated = null;
		$this->collJ026tEstadoEvidenciasRelatedByCoUsuarioUpdated = null;
		$this->collJ027tLugarSegurosRelatedByCoUsuarioCreated = null;
		$this->collJ027tLugarSegurosRelatedByCoUsuarioUpdated = null;
		$this->collJ028tRepositoriosRelatedByCoUsuarioCreated = null;
		$this->collJ028tRepositoriosRelatedByCoUsuarioUpdated = null;
		$this->collJ030tInformeRecomendacionessRelatedByCoRevisa = null;
		$this->collJ030tInformeRecomendacionessRelatedByCoAprueba = null;
		$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioCreated = null;
		$this->collJ030tInformeRecomendacionessRelatedByCoUsuarioUpdate = null;
		$this->collJ031tAccionRecomendadasRelatedByCoResponsableStiEjecutar = null;
		$this->collJ031tAccionRecomendadasRelatedByCoCreatedAt = null;
		$this->collJ031tAccionRecomendadasRelatedByCoUpdateAt = null;
		$this->collJ034tIncidentesRelatedByCoUsuarioApertura = null;
		$this->collJ034tIncidentesRelatedByCoUsuarioEscala = null;
		$this->collJ034tIncidentesRelatedByCoUsuarioCierre = null;
		$this->collJ034tIncidentesRelatedByCoUsuarioUpdate = null;
		$this->collJ042tEstadoIncidentesRelatedByCoUsuarioCreated = null;
		$this->collJ042tEstadoIncidentesRelatedByCoUsuarioUpdated = null;
		$this->collJ047tDocumentoNormativosRelatedByCoAprueba1 = null;
		$this->collJ047tDocumentoNormativosRelatedByCoAprueba2 = null;
		$this->collJ047tDocumentoNormativosRelatedByCoElimina1 = null;
		$this->collJ047tDocumentoNormativosRelatedByCoElimina2 = null;
		$this->collJ047tDocumentoNormativosRelatedByCoUsuarioCreated = null;
		$this->collJ047tDocumentoNormativosRelatedByCoUsuarioUpdated = null;
		$this->collJ048tEstadoDocumentosRelatedByCoUsuarioCreated = null;
		$this->collJ048tEstadoDocumentosRelatedByCoUsuarioUpdated = null;
		$this->collJ049tTipoMarcosRelatedByCoUsuarioCreated = null;
		$this->collJ049tTipoMarcosRelatedByCoUsuarioUpdated = null;
		$this->collJ050tInformeMarcosRelatedByCoUsuarioCreated = null;
		$this->collJ050tInformeMarcosRelatedByCoUsuarioUpdate = null;
		$this->collJ051tTipoRevisionsRelatedByCoUsuarioCreated = null;
		$this->collJ051tTipoRevisionsRelatedByCoUsuarioUpdated = null;
		$this->collJ052tTipoJustificacionsRelatedByCoUsuarioCreated = null;
		$this->collJ052tTipoJustificacionsRelatedByCoUsuarioUpdated = null;
			$this->aJ008tDivision = null;
			$this->aJ003tRol = null;
			$this->aJ007tRegion = null;
			$this->aJ014tNegocio = null;
	}


  public function __call($method, $arguments)
  {
    if (!$callable = sfMixer::getCallable('BaseJ002tUsuario:'.$method))
    {
      throw new sfException(sprintf('Call to undefined method BaseJ002tUsuario::%s', $method));
    }

    array_unshift($arguments, $this);

    return call_user_func_array($callable, $arguments);
  }


} // BaseJ002tUsuario
